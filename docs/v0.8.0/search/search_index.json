{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Opal Documentation Opal is a full stack framework that makes building digital tools for health care easy. Opal builds deep clinical domain specific functionality on top of Django , Angular and Bootstrap to help developers quickly build easy to maintain, robust clinical applications. This is the developer documentation . Opal is an entirely Open Source , Open Governance product, as are the wide library of plugins. First Steps If you're new to Opal, then you'll want to take a look at the Installation instructions , and then maybe take the tutorial . Full documentation While Topic guides are available for many key areas of Opal, the Detailed reference material is a work in progress. If you find any issues or missing areas of this documentation, please do raise it with the team on the Github issue tracker .","title":"Home"},{"location":"#opal-documentation","text":"","title":"Opal Documentation"},{"location":"#opal-is-a-full-stack-framework-that-makes-building-digital-tools-for-health-care-easy","text":"Opal builds deep clinical domain specific functionality on top of Django , Angular and Bootstrap to help developers quickly build easy to maintain, robust clinical applications. This is the developer documentation . Opal is an entirely Open Source , Open Governance product, as are the wide library of plugins.","title":"Opal is a full stack framework that makes building digital tools for health care easy."},{"location":"#first-steps","text":"If you're new to Opal, then you'll want to take a look at the Installation instructions , and then maybe take the tutorial .","title":"First Steps"},{"location":"#full-documentation","text":"While Topic guides are available for many key areas of Opal, the Detailed reference material is a work in progress. If you find any issues or missing areas of this documentation, please do raise it with the team on the Github issue tracker .","title":"Full documentation"},{"location":"installation/","text":"Installing Opal Installation should be simple. Step 1: The Prerequisites Before you install Opal, you'll need to make sure that you have Python and pip installed on your system. Let's just check that you do: $ python --version Python 2.7.5 $ pip --version pip 1.5.6 Step 2: Use Pip Now we can install Opal using pip: $ pip install opal You should now have the opal commandline tools installed. Let's just check that you do: $ opal --version Opal 0.8.0 Step 3: There is no step 3. Maybe make yourself some tea then try the Tutorial instead ?","title":"Installation"},{"location":"installation/#installing-opal","text":"Installation should be simple.","title":"Installing Opal"},{"location":"installation/#step-1-the-prerequisites","text":"Before you install Opal, you'll need to make sure that you have Python and pip installed on your system. Let's just check that you do: $ python --version Python 2.7.5 $ pip --version pip 1.5.6","title":"Step 1: The Prerequisites"},{"location":"installation/#step-2-use-pip","text":"Now we can install Opal using pip: $ pip install opal You should now have the opal commandline tools installed. Let's just check that you do: $ opal --version Opal 0.8.0","title":"Step 2: Use Pip"},{"location":"installation/#step-3-there-is-no-step-3","text":"Maybe make yourself some tea then try the Tutorial instead ?","title":"Step 3: There is no step 3."},{"location":"overview/","text":"","title":"Overview"},{"location":"tutorial/","text":"Writing a clinical service with Opal This tutorial will walk you through the creation of a new Opal service. The application we're going to be building will help clinical users to manage the patients on a ward in a hospital. As a Doctor I want to know what's going on with the patients under my care So that I can treat them effectively and safely. Bootstrapping a new project We assume that you've already Installed Opal . You can tell which version of opal is installed by running this command $ opal --version At the start a new project, Opal will bootstrap the initial project structure, including a Djano project, some core datamodels (complete with JSON APIs) and a general application structure. From the commandline: $ opal startproject mynewapp This will create a mynewap directory where your new project lives. Let's have a look at what that created for you: mynewapp/ # Your project directory LICENSE # A dummy LICENSE file Procfile # A procfile ready for deployment to e.g. Heroku README.md manage.py # Django's manage.py script requirements.txt # Requirements file ready for your project data/ # A dummy directory for fixtures lookuplists/ # A dummy directory for reference data mynewapp/ # The actual python package for your application __init__.py models.py # Data models for your application settings.py # Helpfully tweaked Django settings tests.py # Dummy unittests urls.py # Django Urlconf wsgi.py patient_lists.py # these create the [lists](/guides/list_views/) for you application assets/ # Your static files directory templates/ # Your template directory migrations/ # Your Database migrations directory opal.sqlite # The Sqlite development database Test it out The scaffolding step has generated you a working project - so let's check that out cd mynewapp python manage.py runserver If you now visit http://localhost:8000 in your browser, you should see the standard login screen: The scaffolding step created you a superuser, so try logging in with the credentials: Username: super Password: super1 When you log in you should be presented with a welcome screen that shows you the three areas that are enabled by default - team lists, search and the admin area. Opal applications are a collection of single page Angular apps that talk to the Django server-side layer via JSON APIs. The Team Lists and Search options here are two examples of front-end Angular single page apps. Team lists Most clinical services will need at some stage to generate a list of patients - so Opal provides this functionality enabled by default. The list view is a spreadhseet-style list of patients - try navigating to the list view and adding a patient with the add patient button. Each column contains a different type of information about a patient, while each row represents one patient. Strictly speaking each row is an episode of care for a patient - but we'll come to that in a second. The columns you see initially are just a few of the standard clinical models that come with Opal - for instance the Diagnosis model in your new application inherits from a model that looks a lot like this: class Diagnosis(EpisodeSubrecord): condition = ForeignKeyOrFreeText(Condition) provisional = models.BooleanField(default=False) details = models.CharField(max_length=255, blank=True) date_of_diagnosis = models.DateField(blank=True, null=True) class Meta: abstract = True Reference data You will notice that the condition field has a custom field type - ForeignKeyOrFreeText . This is a custom field type that we use with Opal when we want to use a Lookup List . Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. That means that we can ensure that we record high quality coded data, while allowing users an easy way to enter unusual edge cases. You'll need to import the data for a terminology before you can start to take advantage of that. For now, let's use the reference data from elCID (An Opal application maintained by Open Health Care): wget https://raw.githubusercontent.com/openhealthcare/elcid/master/data/lookuplists/lookuplists.json -P yourapp/data/lookuplists By convention, we store data in the ./data/lookuplists directory of our project. Now let's import the data: python manage.py load_lookup_lists Now refresh your application and try adding a new diagnosis to your patient. As you start to type in the condition field, you'l see that the conditions we just imported appear as suggestions: You can add your own Lookup Lists to your application. For more details consult the Reference Data guide . Add your own data models So far we've begun to get a sense of the batteries-included parts of Opal, but before long, you're going to need to create models for your own needs. Most Opal models are Subrecords - they relate to either a patient, or an episode (an episode is for example, an admission to hospital). Let's see how that works by creating a TODO list model that is assigned to episodes of care. In your mynewapp/models.py : class TODOItem(models.EpisodeSubrecord): job = fields.CharField(max_length=200) due_date = fields.DateField(blank=True, null=True) details = fields.TextField(blank=True, null=True) completed = fields.BooleanField(default=False) This is simply a Django model, apart from the parent class models.EpisodeSubrecord which provides us with some extra functionality: A relationship to an episode, linked to a patient JSON APIs for creating, retrieving and updating it Ensuring that the Opal Angular layer knows it exists Some metadata fields, like created, updated, created_by, updated_by Next, we're going to let Opal take care of the boilerplate that we'll need to use this model in our application. From the commandline: $ opal scaffold mynewapp Let's take a look at what that did: It created a Django migration It ran that migration for you It created a detail template mynewapp/templates/records/todo_item.html It created a form template mynewapp/templates/forms/todo_item_forml.html Detail template The default detail template simply displays each field on a new line: span ng-show=\"item.job\" [[ item.job ]] br / /span span ng-show=\"item.due_date\" [[ item.due_date | shortDate ]] br / /span span ng-show=\"item.details\" [[ item.details ]] br / /span span ng-show=\"item.completed\" [[ item.completed ]] br / /span Form template The default form template will display each field on a new line, with some basic appropriate form field types set. It uses the Opal form helpers templatetag library. {% load forms %} {% input field= TODOItem.job %} {% datepicker field= TODOItem.due_date %} {% textarea field= TODOItem.details %} {% checkbox field= TODOItem.completed %} Adding TODOs to our Team Lists Now let's add our TODO list model as a column in the Spreadsheet-like list view. Patient Lists in Opal are subclasses of opal.core.patient_lists.PatientList , and they live in patient_lists.py files of our Django apps. Technically these can live anywhere you like - although if you put them in other places you're responsible for making sure that they're imported at startup. Opal guarantees to autodiscover lists in `app.patient_list` modules. You can see the basic list that the Opal application scaffold created for you in yournewapp/patient_lists.py . class AllPatientsList(core.patient_lists.PatientList): display_name = 'All Patients' schema = [ models.Demographics, models.Diagnosis, models.Treatment ] def get_queryset(self): return Episode.objects.all() The columns for lists are set in the schema property of the PatientList class. To add our TODO model to the list, just add the model to the schema: schema = [ models.Demographics, models.Diagnosis, models.Treatment, models.TODOItem ] Refresh the lists page in your browser, and you'll see your new column on the end - add a TODO item, noting how we automatically get appropriate form types like datepickers and checkboxes. You can edit any entry in the list view by double clicking on it. Tweaking the default scaffolding The scaffolding templates are only really supposed to get you started - you'll often need to tweak the templates they generate with whatever logic makes sense for your application. For us, you'll notice that the value of TODOItem.completed simply displays as false - which is not particularly useful. So let's update that using the Opal Boxed filter . In mynewapp/templates/records/todo_item.html change the last line to look like this: span ng-show=\"item.completed\" [[ item.completed | boxed ]] br / /span Set an Icon for your model You'll notice that your new column is the only one without an icon - we set the icon by adding the following property to your TODOItem class: _icon = 'fa fa-th-list' Some other batteries included Let's take a look at some of the other core functionality that we now have out of the box: Search By default, we also enable the search module, which allows you to search by patient name or unique identifier: Detail views We also have a detail view for our patients, which you can access via search results. This view will typically allow for a more detailed display and editing of all the events comprising a patient's care than is available on the list page. JSON APIs Opal automatically creates self-documenting JSON APIs for your interacting with the data in your application. You can inspect these APIs interactively at the url: http://localhost:8000/api/v0.1/ What next? This is just a glimpse at the full range of functionality that comes with Opal - there is much more to discover in the Topic Guides .","title":"Tutorial"},{"location":"tutorial/#writing-a-clinical-service-with-opal","text":"This tutorial will walk you through the creation of a new Opal service. The application we're going to be building will help clinical users to manage the patients on a ward in a hospital. As a Doctor I want to know what's going on with the patients under my care So that I can treat them effectively and safely.","title":"Writing a clinical service with Opal"},{"location":"tutorial/#bootstrapping-a-new-project","text":"We assume that you've already Installed Opal . You can tell which version of opal is installed by running this command $ opal --version At the start a new project, Opal will bootstrap the initial project structure, including a Djano project, some core datamodels (complete with JSON APIs) and a general application structure. From the commandline: $ opal startproject mynewapp This will create a mynewap directory where your new project lives. Let's have a look at what that created for you: mynewapp/ # Your project directory LICENSE # A dummy LICENSE file Procfile # A procfile ready for deployment to e.g. Heroku README.md manage.py # Django's manage.py script requirements.txt # Requirements file ready for your project data/ # A dummy directory for fixtures lookuplists/ # A dummy directory for reference data mynewapp/ # The actual python package for your application __init__.py models.py # Data models for your application settings.py # Helpfully tweaked Django settings tests.py # Dummy unittests urls.py # Django Urlconf wsgi.py patient_lists.py # these create the [lists](/guides/list_views/) for you application assets/ # Your static files directory templates/ # Your template directory migrations/ # Your Database migrations directory opal.sqlite # The Sqlite development database","title":"Bootstrapping a new project"},{"location":"tutorial/#test-it-out","text":"The scaffolding step has generated you a working project - so let's check that out cd mynewapp python manage.py runserver If you now visit http://localhost:8000 in your browser, you should see the standard login screen: The scaffolding step created you a superuser, so try logging in with the credentials: Username: super Password: super1 When you log in you should be presented with a welcome screen that shows you the three areas that are enabled by default - team lists, search and the admin area. Opal applications are a collection of single page Angular apps that talk to the Django server-side layer via JSON APIs. The Team Lists and Search options here are two examples of front-end Angular single page apps.","title":"Test it out"},{"location":"tutorial/#team-lists","text":"Most clinical services will need at some stage to generate a list of patients - so Opal provides this functionality enabled by default. The list view is a spreadhseet-style list of patients - try navigating to the list view and adding a patient with the add patient button. Each column contains a different type of information about a patient, while each row represents one patient. Strictly speaking each row is an episode of care for a patient - but we'll come to that in a second. The columns you see initially are just a few of the standard clinical models that come with Opal - for instance the Diagnosis model in your new application inherits from a model that looks a lot like this: class Diagnosis(EpisodeSubrecord): condition = ForeignKeyOrFreeText(Condition) provisional = models.BooleanField(default=False) details = models.CharField(max_length=255, blank=True) date_of_diagnosis = models.DateField(blank=True, null=True) class Meta: abstract = True","title":"Team lists"},{"location":"tutorial/#reference-data","text":"You will notice that the condition field has a custom field type - ForeignKeyOrFreeText . This is a custom field type that we use with Opal when we want to use a Lookup List . Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. That means that we can ensure that we record high quality coded data, while allowing users an easy way to enter unusual edge cases. You'll need to import the data for a terminology before you can start to take advantage of that. For now, let's use the reference data from elCID (An Opal application maintained by Open Health Care): wget https://raw.githubusercontent.com/openhealthcare/elcid/master/data/lookuplists/lookuplists.json -P yourapp/data/lookuplists By convention, we store data in the ./data/lookuplists directory of our project. Now let's import the data: python manage.py load_lookup_lists Now refresh your application and try adding a new diagnosis to your patient. As you start to type in the condition field, you'l see that the conditions we just imported appear as suggestions: You can add your own Lookup Lists to your application. For more details consult the Reference Data guide .","title":"Reference data"},{"location":"tutorial/#add-your-own-data-models","text":"So far we've begun to get a sense of the batteries-included parts of Opal, but before long, you're going to need to create models for your own needs. Most Opal models are Subrecords - they relate to either a patient, or an episode (an episode is for example, an admission to hospital). Let's see how that works by creating a TODO list model that is assigned to episodes of care. In your mynewapp/models.py : class TODOItem(models.EpisodeSubrecord): job = fields.CharField(max_length=200) due_date = fields.DateField(blank=True, null=True) details = fields.TextField(blank=True, null=True) completed = fields.BooleanField(default=False) This is simply a Django model, apart from the parent class models.EpisodeSubrecord which provides us with some extra functionality: A relationship to an episode, linked to a patient JSON APIs for creating, retrieving and updating it Ensuring that the Opal Angular layer knows it exists Some metadata fields, like created, updated, created_by, updated_by Next, we're going to let Opal take care of the boilerplate that we'll need to use this model in our application. From the commandline: $ opal scaffold mynewapp Let's take a look at what that did: It created a Django migration It ran that migration for you It created a detail template mynewapp/templates/records/todo_item.html It created a form template mynewapp/templates/forms/todo_item_forml.html","title":"Add your own data models"},{"location":"tutorial/#detail-template","text":"The default detail template simply displays each field on a new line: span ng-show=\"item.job\" [[ item.job ]] br / /span span ng-show=\"item.due_date\" [[ item.due_date | shortDate ]] br / /span span ng-show=\"item.details\" [[ item.details ]] br / /span span ng-show=\"item.completed\" [[ item.completed ]] br / /span","title":"Detail template"},{"location":"tutorial/#form-template","text":"The default form template will display each field on a new line, with some basic appropriate form field types set. It uses the Opal form helpers templatetag library. {% load forms %} {% input field= TODOItem.job %} {% datepicker field= TODOItem.due_date %} {% textarea field= TODOItem.details %} {% checkbox field= TODOItem.completed %}","title":"Form template"},{"location":"tutorial/#adding-todos-to-our-team-lists","text":"Now let's add our TODO list model as a column in the Spreadsheet-like list view. Patient Lists in Opal are subclasses of opal.core.patient_lists.PatientList , and they live in patient_lists.py files of our Django apps. Technically these can live anywhere you like - although if you put them in other places you're responsible for making sure that they're imported at startup. Opal guarantees to autodiscover lists in `app.patient_list` modules. You can see the basic list that the Opal application scaffold created for you in yournewapp/patient_lists.py . class AllPatientsList(core.patient_lists.PatientList): display_name = 'All Patients' schema = [ models.Demographics, models.Diagnosis, models.Treatment ] def get_queryset(self): return Episode.objects.all() The columns for lists are set in the schema property of the PatientList class. To add our TODO model to the list, just add the model to the schema: schema = [ models.Demographics, models.Diagnosis, models.Treatment, models.TODOItem ] Refresh the lists page in your browser, and you'll see your new column on the end - add a TODO item, noting how we automatically get appropriate form types like datepickers and checkboxes. You can edit any entry in the list view by double clicking on it.","title":"Adding TODOs to our Team Lists"},{"location":"tutorial/#tweaking-the-default-scaffolding","text":"The scaffolding templates are only really supposed to get you started - you'll often need to tweak the templates they generate with whatever logic makes sense for your application. For us, you'll notice that the value of TODOItem.completed simply displays as false - which is not particularly useful. So let's update that using the Opal Boxed filter . In mynewapp/templates/records/todo_item.html change the last line to look like this: span ng-show=\"item.completed\" [[ item.completed | boxed ]] br / /span","title":"Tweaking the default scaffolding"},{"location":"tutorial/#set-an-icon-for-your-model","text":"You'll notice that your new column is the only one without an icon - we set the icon by adding the following property to your TODOItem class: _icon = 'fa fa-th-list'","title":"Set an Icon for your model"},{"location":"tutorial/#some-other-batteries-included","text":"Let's take a look at some of the other core functionality that we now have out of the box:","title":"Some other batteries included"},{"location":"tutorial/#search","text":"By default, we also enable the search module, which allows you to search by patient name or unique identifier:","title":"Search"},{"location":"tutorial/#detail-views","text":"We also have a detail view for our patients, which you can access via search results. This view will typically allow for a more detailed display and editing of all the events comprising a patient's care than is available on the list page.","title":"Detail views"},{"location":"tutorial/#json-apis","text":"Opal automatically creates self-documenting JSON APIs for your interacting with the data in your application. You can inspect these APIs interactively at the url: http://localhost:8000/api/v0.1/","title":"JSON APIs"},{"location":"tutorial/#what-next","text":"This is just a glimpse at the full range of functionality that comes with Opal - there is much more to discover in the Topic Guides .","title":"What next?"},{"location":"guides/CONTRIBUTING/","text":"Contributing to Opal Opal is developed as an open source project, and as such we welcome contributions in the form of bug reports, documentation, and code. Reporting bugs If you find what looks like a bug, add an issue to the Github Issue tracker . Unclear documentation, unexpected error messages definitely count as bugs - feel free to raise issues about them. Please try to include steps to reproduce your bug in the issue - it helps us enormously to find and fix it. Contributing enhancements or fixes If you want to contribute an enhancement or fix to Opal: Fork the project on Github Make a feature branch from the latest default branch (this will be named vX.Y.Z and set as the default branch on Github) Make your changes Make sure that our test suite still runs, and that your changes are covered by tests (running opal test -c in the root directory of the repository will run both python and javascript tests, as well as generate HTML code coverage reports.) Update the Opal documentation to be Commit the changes and push to your fork Submi a pull request to Opal At this stage, we will assign someone to review your changes before merging. We might ask you to make some changes to your pull request before merging, but in general, we are biased towards accepting contributions from the community. That said, we won't merge your pull request if: It doesn't come with tests It doesn't update the relevant documentation Don't worry though - we're happy to guide new contributors through this process. If you want to discuss ideas you have for changes before making them, you can always propose enhancements on the Github Issue tracker or post questions and open discussions on the mailing list . Issues suitable for new contributors Issues in the github issue tracker labelled 'easy' have been identified as particularly appropriate for new contributors.","title":"CONTRIBUTING"},{"location":"guides/CONTRIBUTING/#contributing-to-opal","text":"Opal is developed as an open source project, and as such we welcome contributions in the form of bug reports, documentation, and code.","title":"Contributing to Opal"},{"location":"guides/CONTRIBUTING/#reporting-bugs","text":"If you find what looks like a bug, add an issue to the Github Issue tracker . Unclear documentation, unexpected error messages definitely count as bugs - feel free to raise issues about them. Please try to include steps to reproduce your bug in the issue - it helps us enormously to find and fix it.","title":"Reporting bugs"},{"location":"guides/CONTRIBUTING/#contributing-enhancements-or-fixes","text":"If you want to contribute an enhancement or fix to Opal: Fork the project on Github Make a feature branch from the latest default branch (this will be named vX.Y.Z and set as the default branch on Github) Make your changes Make sure that our test suite still runs, and that your changes are covered by tests (running opal test -c in the root directory of the repository will run both python and javascript tests, as well as generate HTML code coverage reports.) Update the Opal documentation to be Commit the changes and push to your fork Submi a pull request to Opal At this stage, we will assign someone to review your changes before merging. We might ask you to make some changes to your pull request before merging, but in general, we are biased towards accepting contributions from the community. That said, we won't merge your pull request if: It doesn't come with tests It doesn't update the relevant documentation Don't worry though - we're happy to guide new contributors through this process. If you want to discuss ideas you have for changes before making them, you can always propose enhancements on the Github Issue tracker or post questions and open discussions on the mailing list .","title":"Contributing enhancements or fixes"},{"location":"guides/CONTRIBUTING/#issues-suitable-for-new-contributors","text":"Issues in the github issue tracker labelled 'easy' have been identified as particularly appropriate for new contributors.","title":"Issues suitable for new contributors"},{"location":"guides/archetypes/","text":"Core Clinical Archetypes Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Common Metadata fields All subrecords will contain the following fields, which are not repreated individually Field Type Length created_by FK User ID created Date updated_by FK User ID update Date The details of each individual archetype are set out below: Patient Subrecords Demographics Field Type Length hospital_number Char 255 nhs_number Char 255 date_of_birth Date place_of_birth FKorFT(Destination) ethnicity FKorFT(Ethnicity) surname Char 255 first_name Char 255 middle_name Char 255 sex FKorFT(Gender) Allergies Field Type Length drug FKorFT(Drug) provisional Boolean details Char 255 Episode Subrecords Location Field Type Length category Char 255 hospital Char 255 ward Char 255 bed Char 255 Treatment Field Type Length drug FKorFT(Drug) dose Char 255 route FKorFT(Drugroute) start_date Date end_date Date frequency FKorFT(Drugfreq) Diagnosis Field Type Length condition FKorFT(Condition) provisional Boolean details Char 255 date_of_diagnosis Date PastMedicalHistory Field Type Length condition FKorFT(Condition) year Char 4 details Char 255 SymptomComplex Field Type Length symptoms ManyToMany(Symptom) duration Char 255 details Text ReferralRoute Field Type Length internal NullBoolean referral_route FKorFT(ReferralOrganisation) referral_name Char 255 date_of_referral Date referral_team FKorFT(Speciality) referral_reason FKorFT(ReferralReason) PatientConsultation Field Type Length when Datetime initials Char 255 reason_for_interaction FKorFT(Patient_consultation_reason_for_interaction) discussion Text Investigation Field Type Length test Char 255 date_ordered Date details Char 255 microscopy Char 255 organism Char 255 sensitive_antibiotics Char 255 resistant_antibiotics Char 255 result Char 255 igm Char 20 igg Char 20 vca_igm Char 20 vca_igg Char 20 ebna_igg Char 20 hbsag Char 20 anti_hbs Char 20 anti_hbcore_igm Char 20 anti_hbcore_igg Char 20 rpr Char 20 tppa Char 20 viral_load Char 20 parasitaemia Char 20 hsv Char 20 vzv Char 20 syphilis Char 20 c_difficile_antigen Char 20 c_difficile_toxin Char 20 species Char 20 hsv_1 Char 20 hsv_2 Char 20 enterovirus Char 20 cmv Char 20 ebv Char 20 influenza_a Char 20 influenza_b Char 20 parainfluenza Char 20 metapneumovirus Char 20 rsv Char 20 adenovirus Char 20 norovirus Char 20 rotavirus Char 20 giardia Char 20 entamoeba_histolytica Char 20 cryptosporidium Char 20","title":"Archetypes"},{"location":"guides/archetypes/#core-clinical-archetypes","text":"Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application.","title":"Core Clinical Archetypes"},{"location":"guides/archetypes/#common-metadata-fields","text":"All subrecords will contain the following fields, which are not repreated individually Field Type Length created_by FK User ID created Date updated_by FK User ID update Date The details of each individual archetype are set out below:","title":"Common Metadata fields"},{"location":"guides/archetypes/#patient-subrecords","text":"","title":"Patient Subrecords"},{"location":"guides/archetypes/#demographics","text":"Field Type Length hospital_number Char 255 nhs_number Char 255 date_of_birth Date place_of_birth FKorFT(Destination) ethnicity FKorFT(Ethnicity) surname Char 255 first_name Char 255 middle_name Char 255 sex FKorFT(Gender)","title":"Demographics"},{"location":"guides/archetypes/#allergies","text":"Field Type Length drug FKorFT(Drug) provisional Boolean details Char 255","title":"Allergies"},{"location":"guides/archetypes/#episode-subrecords","text":"","title":"Episode Subrecords"},{"location":"guides/archetypes/#location","text":"Field Type Length category Char 255 hospital Char 255 ward Char 255 bed Char 255","title":"Location"},{"location":"guides/archetypes/#treatment","text":"Field Type Length drug FKorFT(Drug) dose Char 255 route FKorFT(Drugroute) start_date Date end_date Date frequency FKorFT(Drugfreq)","title":"Treatment"},{"location":"guides/archetypes/#diagnosis","text":"Field Type Length condition FKorFT(Condition) provisional Boolean details Char 255 date_of_diagnosis Date","title":"Diagnosis"},{"location":"guides/archetypes/#pastmedicalhistory","text":"Field Type Length condition FKorFT(Condition) year Char 4 details Char 255","title":"PastMedicalHistory"},{"location":"guides/archetypes/#symptomcomplex","text":"Field Type Length symptoms ManyToMany(Symptom) duration Char 255 details Text","title":"SymptomComplex"},{"location":"guides/archetypes/#referralroute","text":"Field Type Length internal NullBoolean referral_route FKorFT(ReferralOrganisation) referral_name Char 255 date_of_referral Date referral_team FKorFT(Speciality) referral_reason FKorFT(ReferralReason)","title":"ReferralRoute"},{"location":"guides/archetypes/#patientconsultation","text":"Field Type Length when Datetime initials Char 255 reason_for_interaction FKorFT(Patient_consultation_reason_for_interaction) discussion Text","title":"PatientConsultation"},{"location":"guides/archetypes/#investigation","text":"Field Type Length test Char 255 date_ordered Date details Char 255 microscopy Char 255 organism Char 255 sensitive_antibiotics Char 255 resistant_antibiotics Char 255 result Char 255 igm Char 20 igg Char 20 vca_igm Char 20 vca_igg Char 20 ebna_igg Char 20 hbsag Char 20 anti_hbs Char 20 anti_hbcore_igm Char 20 anti_hbcore_igg Char 20 rpr Char 20 tppa Char 20 viral_load Char 20 parasitaemia Char 20 hsv Char 20 vzv Char 20 syphilis Char 20 c_difficile_antigen Char 20 c_difficile_toxin Char 20 species Char 20 hsv_1 Char 20 hsv_2 Char 20 enterovirus Char 20 cmv Char 20 ebv Char 20 influenza_a Char 20 influenza_b Char 20 parainfluenza Char 20 metapneumovirus Char 20 rsv Char 20 adenovirus Char 20 norovirus Char 20 rotavirus Char 20 giardia Char 20 entamoeba_histolytica Char 20 cryptosporidium Char 20","title":"Investigation"},{"location":"guides/command_line_tool/","text":"The Opal Command line tool Opal ships with a helpful command line tool that helps with administrative tasks. The opal script should be on your system path if you installed Opal via setup.py or pip. You can check whether it is available by running this command: $ opal -v startproject name Creates a new Opal project. This creates boilerplate and a default configuration for your new project, including creating a new underlying Django project, updating default settings to be compatible with Opal, creating directories and code boilerplate, and running initial migrations. startplugin name Creates boilerplate code, and directory structures for a new Opal plugin. scaffold appname Use with new record models. Creates and runs automatic migrations, creates display and form (modal) templates. Running with --dry-run will run makemigrations with --dry-run and print display and form templates that would be generated. test what Run our tests suites. Defaults to running both Python and Javascript tests. If specified, will only run one specific kind of test. $ opal test py $ opal test js When running Python tests, the -t or --test option allows the user to specify a single test module, case or method to run. $ opal test py -t opal.tests.test_models checkout Ensure that all of our application plugins and packages are on the correct branch. This is particularly useful when working on Opal itself, or when you have multiple projects that use different versions of Opal or plugins. It will assume that github based requirements will be installed in development via python setup.py develop . This command will parse your project's requirements.txt , and then ensure that any Github sources are checked out loclaly to the branch specified therein.","title":"Command Line tool"},{"location":"guides/command_line_tool/#the-opal-command-line-tool","text":"Opal ships with a helpful command line tool that helps with administrative tasks. The opal script should be on your system path if you installed Opal via setup.py or pip. You can check whether it is available by running this command: $ opal -v","title":"The Opal Command line tool"},{"location":"guides/command_line_tool/#startproject-name","text":"Creates a new Opal project. This creates boilerplate and a default configuration for your new project, including creating a new underlying Django project, updating default settings to be compatible with Opal, creating directories and code boilerplate, and running initial migrations.","title":"startproject &lt;name&gt;"},{"location":"guides/command_line_tool/#startplugin-name","text":"Creates boilerplate code, and directory structures for a new Opal plugin.","title":"startplugin &lt;name&gt;"},{"location":"guides/command_line_tool/#scaffold-appname","text":"Use with new record models. Creates and runs automatic migrations, creates display and form (modal) templates. Running with --dry-run will run makemigrations with --dry-run and print display and form templates that would be generated.","title":"scaffold &lt;appname&gt;"},{"location":"guides/command_line_tool/#test-what","text":"Run our tests suites. Defaults to running both Python and Javascript tests. If specified, will only run one specific kind of test. $ opal test py $ opal test js When running Python tests, the -t or --test option allows the user to specify a single test module, case or method to run. $ opal test py -t opal.tests.test_models","title":"test &lt;what&gt;"},{"location":"guides/command_line_tool/#checkout","text":"Ensure that all of our application plugins and packages are on the correct branch. This is particularly useful when working on Opal itself, or when you have multiple projects that use different versions of Opal or plugins. It will assume that github based requirements will be installed in development via python setup.py develop . This command will parse your project's requirements.txt , and then ensure that any Github sources are checked out loclaly to the branch specified therein.","title":"checkout"},{"location":"guides/components_overview/","text":"Components of an Opal application Opal applications will typically be made up of several types of components. Opal The core Opal framework provides you with a range of commonly required elements of clinical applications. It contains a core data model for persisting clinical information, as well core clinical archetypes out of the box that build on many years of collaboratively modelling clinical concepts by medical domain experts. Opal also makes it easy to integrate standard clinical reference data into your application - things like medical diagnoses, tests, drugs et cetera. Some common functional components end up in to most clinical applications, and many of these come with Opal as \"batteries included\" - immediately available modular features that can be simply re-used without having to reinvent the wheel. For example: Patient lists Search Authentication and Permissions Forms for data entry JSON based REST APIs for all of your models ... and many more ... Plugins Opal plugins are intended to provide high quality generic, composable, re-usable chunks of functionality that can be \"dropped in\" to an application. For example, installing the Dashboards plugin allows you to easily create clinical dashboards within your application. The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. Plugins have a rich plugin API they can hook into to, and many examples can be found by inspecting the source of existing plugins . Applications An application is the collection of configuration and bespoke functionality that would be provided to an individual institution - it's the thing that you would look to deploy. Example applications include elCID - a for managing infection patients, or Opal-Renal - an MDT handover tool for Renal wards. A hospital might have multiple clinical services running on one application, or multiple applications that integrate with one another. Opinionated but Pluggable Opal is an opinionated framework. It expects the developer to structure code in a certain way. Opal expects features to be implemented as single page Angular.js applications, with the server mostly figuring as an API endpoint for reading and writing data. That said, the technology stack of Django, Angular Bootstrap allows the confident user a huge degree of flexibility when writing their own applications and plugins. For instance, there is nothing to stop a developer from implementing a part of the functionality in some other Javascript framework, and simply calling the JSON API . However, by doing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera. While possible, this approach is not likely to be officially supported in the medium term.","title":"Component Overview"},{"location":"guides/components_overview/#components-of-an-opal-application","text":"Opal applications will typically be made up of several types of components.","title":"Components of an Opal application"},{"location":"guides/components_overview/#opal","text":"The core Opal framework provides you with a range of commonly required elements of clinical applications. It contains a core data model for persisting clinical information, as well core clinical archetypes out of the box that build on many years of collaboratively modelling clinical concepts by medical domain experts. Opal also makes it easy to integrate standard clinical reference data into your application - things like medical diagnoses, tests, drugs et cetera. Some common functional components end up in to most clinical applications, and many of these come with Opal as \"batteries included\" - immediately available modular features that can be simply re-used without having to reinvent the wheel. For example: Patient lists Search Authentication and Permissions Forms for data entry JSON based REST APIs for all of your models ... and many more ...","title":"Opal"},{"location":"guides/components_overview/#plugins","text":"Opal plugins are intended to provide high quality generic, composable, re-usable chunks of functionality that can be \"dropped in\" to an application. For example, installing the Dashboards plugin allows you to easily create clinical dashboards within your application. The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. Plugins have a rich plugin API they can hook into to, and many examples can be found by inspecting the source of existing plugins .","title":"Plugins"},{"location":"guides/components_overview/#applications","text":"An application is the collection of configuration and bespoke functionality that would be provided to an individual institution - it's the thing that you would look to deploy. Example applications include elCID - a for managing infection patients, or Opal-Renal - an MDT handover tool for Renal wards. A hospital might have multiple clinical services running on one application, or multiple applications that integrate with one another.","title":"Applications"},{"location":"guides/components_overview/#opinionated-but-pluggable","text":"Opal is an opinionated framework. It expects the developer to structure code in a certain way. Opal expects features to be implemented as single page Angular.js applications, with the server mostly figuring as an API endpoint for reading and writing data. That said, the technology stack of Django, Angular Bootstrap allows the confident user a huge degree of flexibility when writing their own applications and plugins. For instance, there is nothing to stop a developer from implementing a part of the functionality in some other Javascript framework, and simply calling the JSON API . However, by doing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera. While possible, this approach is not likely to be officially supported in the medium term.","title":"Opinionated but Pluggable"},{"location":"guides/context_processors/","text":"Default context Processors settings all settings are copied into the context of the template models all subrecords are copied into the context of the template under the namespace models, e.g. the allergies subrecord can be referred to by models.Allergy","title":"Context Processors"},{"location":"guides/context_processors/#default-context-processors","text":"","title":"Default context Processors"},{"location":"guides/context_processors/#settings","text":"all settings are copied into the context of the template","title":"settings"},{"location":"guides/context_processors/#models","text":"all subrecords are copied into the context of the template under the namespace models, e.g. the allergies subrecord can be referred to by models.Allergy","title":"models"},{"location":"guides/datamodel/","text":"The Opal Data model The Opal data model allows for patients to have multiple sequential or concurrent Episodes of care . Some information is linked to an Episode , some is linked to a Patient . Patients A Patient may have many Episodes . An Episode is something like an Inpatient admission, a telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic. Applications or plugins may define their own Episode categories, and a common pattern is to alter the display or available functionality by episode type. (e.g. You may associate templates for discharge summaries with particular episode types) A Patient will have Subrecords (such as e.g. Demographics) which follow them across multiple episodes. These are information linked to a particular person, and should be implemented as Django models that inherit from the opal.models.PatientSubrecord base class. Episodes An Episode is linked to a Patient , and will contain some metadata about the type and date of the episode. The field Episode.category_name stores a string representing the relevant EpisodeCategory e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned from the episode.category field. The start and end dates of an Episode may be retrieved from the start and end properties. An Episode will have Subrecords (such as e.g. Diagnosis) which are linked to this episode of care. These should be implemented as Django models that inherit from the opal.models.EpisodeSubRecord base class. Records A Subrecord consists of a collection of fields that constitute a record. For example, one could implement a Demograpics Subrecord as follows: class Demographics(PatientSubrecord): name = models.CharField(max_length=255, blank=True) hospital_number = models.CharField(max_length=255, blank=True) date_of_birth = models.DateField(null=True, blank=True) ethnicity = models.CharField(max_length=255, blank=True, null=True) gender = models.CharField(max_length=255, blank=True, null=True) Subrecords also define various properties that will provide metadata about their display or structure, which are documented in the Subrecord reference material Core Clinical Data Model Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Full documentation of these models is available in the Archetypes documentation. Reference Data Opal comes with a set of clinical terminology data models out of the box. - we often want to link our records to one of these - for example to record a type of condition a patient might have, or a drug they are taking. Full documentation of these is available in the Lookup lists documentation.","title":"Data Model"},{"location":"guides/datamodel/#the-opal-data-model","text":"The Opal data model allows for patients to have multiple sequential or concurrent Episodes of care . Some information is linked to an Episode , some is linked to a Patient .","title":"The Opal Data model"},{"location":"guides/datamodel/#patients","text":"A Patient may have many Episodes . An Episode is something like an Inpatient admission, a telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic. Applications or plugins may define their own Episode categories, and a common pattern is to alter the display or available functionality by episode type. (e.g. You may associate templates for discharge summaries with particular episode types) A Patient will have Subrecords (such as e.g. Demographics) which follow them across multiple episodes. These are information linked to a particular person, and should be implemented as Django models that inherit from the opal.models.PatientSubrecord base class.","title":"Patients"},{"location":"guides/datamodel/#episodes","text":"An Episode is linked to a Patient , and will contain some metadata about the type and date of the episode. The field Episode.category_name stores a string representing the relevant EpisodeCategory e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned from the episode.category field. The start and end dates of an Episode may be retrieved from the start and end properties. An Episode will have Subrecords (such as e.g. Diagnosis) which are linked to this episode of care. These should be implemented as Django models that inherit from the opal.models.EpisodeSubRecord base class.","title":"Episodes"},{"location":"guides/datamodel/#records","text":"A Subrecord consists of a collection of fields that constitute a record. For example, one could implement a Demograpics Subrecord as follows: class Demographics(PatientSubrecord): name = models.CharField(max_length=255, blank=True) hospital_number = models.CharField(max_length=255, blank=True) date_of_birth = models.DateField(null=True, blank=True) ethnicity = models.CharField(max_length=255, blank=True, null=True) gender = models.CharField(max_length=255, blank=True, null=True) Subrecords also define various properties that will provide metadata about their display or structure, which are documented in the Subrecord reference material","title":"Records"},{"location":"guides/datamodel/#core-clinical-data-model","text":"Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Full documentation of these models is available in the Archetypes documentation.","title":"Core Clinical Data Model"},{"location":"guides/datamodel/#reference-data","text":"Opal comes with a set of clinical terminology data models out of the box. - we often want to link our records to one of these - for example to record a type of condition a patient might have, or a drug they are taking. Full documentation of these is available in the Lookup lists documentation.","title":"Reference Data"},{"location":"guides/development_environment/","text":"The Opal development environment Getting the code If you're planning on working on Opal we recommend installing in a Virtualenv - to make that easy, we would suggest installing Virtualenvwrapper. To obtain the code, set up a virtualenv and install Opal and the dependencies you'll need, run the following: git clone git@github.com:openhealthcare/opal cd opal mkvirtualenv -a $PWD opal python setup.py develop pip install -r test-requirements.txt Running the tests In order to run the Opal test suite you'll also need to install the Javascript test runner: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher To run the test suite: opal test You can also run just one suite (Javascript or Python) individually: opal test py opal test js","title":"Development environment"},{"location":"guides/development_environment/#the-opal-development-environment","text":"","title":"The Opal development environment"},{"location":"guides/development_environment/#getting-the-code","text":"If you're planning on working on Opal we recommend installing in a Virtualenv - to make that easy, we would suggest installing Virtualenvwrapper. To obtain the code, set up a virtualenv and install Opal and the dependencies you'll need, run the following: git clone git@github.com:openhealthcare/opal cd opal mkvirtualenv -a $PWD opal python setup.py develop pip install -r test-requirements.txt","title":"Getting the code"},{"location":"guides/development_environment/#running-the-tests","text":"In order to run the Opal test suite you'll also need to install the Javascript test runner: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher To run the test suite: opal test You can also run just one suite (Javascript or Python) individually: opal test py opal test js","title":"Running the tests"},{"location":"guides/discoverable/","text":"Opal Discoverable Features Opal makes extensive use of the case of discoverable features. These are pieces of composable functionality that can be implemented by any plugin or application, simply by declaring a class with the appropriate fields and methods implemented. (Details of exactly which fields and methods vary by feature.) Defining Discoverable Features The only thing required for a discoverable feature, is that it defines the name of the module in which it should expect to find instances. from opal.core import discoverable class MyFeature(discoverable.DiscoverableFeature): module_name = 'myfeature' This now gives us acces to various interfaces which come with the library. We can access all subclasses of MyFeature by calling MyFeature.list() - which will look through all Django apps in our application, and look for a module named myfeature.py . The list() method then returns any subclasses of MyFeature . Slugs and Display Names We often want to define human and machine readable strings to name our features. Display names are intended for people - feel free to include spaces, numbers and puctuation. Slugs are intended for machines - so no spaces, numbers, hypens, periods or other punctuation. By default, if there is a display name and no explicit slug, we wil 'slugify' the display name. class MyNameFeature(MyFeature): display_name = 'Hello World' print MyNameFeature.get_slug() # 'hello_world' class MySlugFeature(MyFeature): slug = 'this_is_a_slug' print MySlugFeature.get_slug() # 'this_is_a_slug' Retrieving Subclasses Once we define a display_name or slug for sublasses of our feature, we can then fetch them via the get() api. class RedFeature(MyFeature): slug = 'red_feature' MyFeature.get('red_feature') # - RedFeature Sortable Features We can make our feature sortable via an order property by including discoverable.SortableFeature as a parent class. This will ensure that MyFeature.list() respects the .order number of any subclass. class MyFeature(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name = 'myfeature' class ThirdFeature(MyFeature): order = 3 class FirstFeature(MyFeature): order = 1 class SecondFeature(MyFeature): order = 2 for f in MyFeature.list(): print f.order, f # class '*.*.FirstFeature' , 1 # class '*.*.SecondFeature' , 2 # class '*.*.ThirdFeature' , 3 Restrictable Features We can ensure that only particular users can access a feature by including discoverable.RestrictableFeature as a parent class, and implementing the visible_to classmethod on any restricted subclasses. class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name = 'myfeature' For instance, a feature that was only visible to superusers could be implemented like this: class SuperuserFeature(MyFeature): @classmethod def visible_to(klass, user): return user.is_superuser Validating Features Sometimes we wish to validate features so that we don't cause unintended consequences when we implement subclasses of them. This is available via the is_valid classmethod. For instance, if we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was true, we could to this as follows: class BombFeature(discoverable.DiscoverableFeature): module_name = 'bombs' blow_up = False @classmethod def is_valid(klass): if klass.blow_up == True: from opal.core.exceptions import InvalidDiscoverableFeatureError raise InvalidDiscoverableFeatureError('BLOWING UP') class Threat(BombFeature): pass # That's fine. class Detonate(BombFeature): blow_up = True # InvalidDiscoverableFeatureError: BLOWING UP Abstract Features Sometimes we want to declare an abstract feature - something with reusable functionality that isn't itself a new feature. We would rather not have our abstract feature show up when we list() our base feature - because it's simply a programming convenience. This is made simple by using opal.utils.AbstractBase . class A(discoverable.DiscoverableFeature): module_name = 'a' class AA(A, AbstractBase): pass class B(A): pass class C(AA): pass class D(AA): pass A.list() # [B, C, D]","title":"Discoverable Features"},{"location":"guides/discoverable/#opal-discoverable-features","text":"Opal makes extensive use of the case of discoverable features. These are pieces of composable functionality that can be implemented by any plugin or application, simply by declaring a class with the appropriate fields and methods implemented. (Details of exactly which fields and methods vary by feature.)","title":"Opal Discoverable Features"},{"location":"guides/discoverable/#defining-discoverable-features","text":"The only thing required for a discoverable feature, is that it defines the name of the module in which it should expect to find instances. from opal.core import discoverable class MyFeature(discoverable.DiscoverableFeature): module_name = 'myfeature' This now gives us acces to various interfaces which come with the library. We can access all subclasses of MyFeature by calling MyFeature.list() - which will look through all Django apps in our application, and look for a module named myfeature.py . The list() method then returns any subclasses of MyFeature .","title":"Defining Discoverable Features"},{"location":"guides/discoverable/#slugs-and-display-names","text":"We often want to define human and machine readable strings to name our features. Display names are intended for people - feel free to include spaces, numbers and puctuation. Slugs are intended for machines - so no spaces, numbers, hypens, periods or other punctuation. By default, if there is a display name and no explicit slug, we wil 'slugify' the display name. class MyNameFeature(MyFeature): display_name = 'Hello World' print MyNameFeature.get_slug() # 'hello_world' class MySlugFeature(MyFeature): slug = 'this_is_a_slug' print MySlugFeature.get_slug() # 'this_is_a_slug'","title":"Slugs and Display Names"},{"location":"guides/discoverable/#retrieving-subclasses","text":"Once we define a display_name or slug for sublasses of our feature, we can then fetch them via the get() api. class RedFeature(MyFeature): slug = 'red_feature' MyFeature.get('red_feature') # - RedFeature","title":"Retrieving Subclasses"},{"location":"guides/discoverable/#sortable-features","text":"We can make our feature sortable via an order property by including discoverable.SortableFeature as a parent class. This will ensure that MyFeature.list() respects the .order number of any subclass. class MyFeature(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name = 'myfeature' class ThirdFeature(MyFeature): order = 3 class FirstFeature(MyFeature): order = 1 class SecondFeature(MyFeature): order = 2 for f in MyFeature.list(): print f.order, f # class '*.*.FirstFeature' , 1 # class '*.*.SecondFeature' , 2 # class '*.*.ThirdFeature' , 3","title":"Sortable Features"},{"location":"guides/discoverable/#restrictable-features","text":"We can ensure that only particular users can access a feature by including discoverable.RestrictableFeature as a parent class, and implementing the visible_to classmethod on any restricted subclasses. class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name = 'myfeature' For instance, a feature that was only visible to superusers could be implemented like this: class SuperuserFeature(MyFeature): @classmethod def visible_to(klass, user): return user.is_superuser","title":"Restrictable Features"},{"location":"guides/discoverable/#validating-features","text":"Sometimes we wish to validate features so that we don't cause unintended consequences when we implement subclasses of them. This is available via the is_valid classmethod. For instance, if we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was true, we could to this as follows: class BombFeature(discoverable.DiscoverableFeature): module_name = 'bombs' blow_up = False @classmethod def is_valid(klass): if klass.blow_up == True: from opal.core.exceptions import InvalidDiscoverableFeatureError raise InvalidDiscoverableFeatureError('BLOWING UP') class Threat(BombFeature): pass # That's fine. class Detonate(BombFeature): blow_up = True # InvalidDiscoverableFeatureError: BLOWING UP","title":"Validating Features"},{"location":"guides/discoverable/#abstract-features","text":"Sometimes we want to declare an abstract feature - something with reusable functionality that isn't itself a new feature. We would rather not have our abstract feature show up when we list() our base feature - because it's simply a programming convenience. This is made simple by using opal.utils.AbstractBase . class A(discoverable.DiscoverableFeature): module_name = 'a' class AA(A, AbstractBase): pass class B(A): pass class C(AA): pass class D(AA): pass A.list() # [B, C, D]","title":"Abstract Features"},{"location":"guides/dump/","text":"Your implementation Your implementation is a Django project with some extras. Opal settings OPAL_LOG_OUT_DURATION = The number of milliseconds after which to log out our user OPAL_BRAND_NAME = The branding to be displayed as the masthead OPAL_EXTRA_APPLICATION = A template to include in the HEAD OPAL_EXTRA_HEADER = A template to include above the main nav Defining Models Models should be defined in your project. They should subclass opal.models.EpisodeSubrecord or opal.models.PatientSubrecord as appropriate. Subrecords have some extra entrypoints that are used by Opal. _is_singleton _is_singleton is a boolean property that ensures that there is only one of this subrecord per patient/episode. Effectively this defaults to False. _title _title sets the column headings in list view. Effectively this defaults to camel_case_to_underscore() on the class name. _sort _sort names a field by which we would like to sorth the display of subrecords. _read_only Marks a field as read only if True _batch_template Allow the list/detail template access to the complete row, not just an item. Template is then responsible for registering click handlers. Will get cix as a variable representing the column index, column_name as the column name. Adding a controller Create the controller file in static/js/opal/controllers. Use the angular module opal.controllers Include this file in templates/opal.html Create a template url in the django layer Creating a Heroku test server $ heroku create $YOUR_APP_NAME (Edit .git/config to give the remote a meaningful name) $ heroku addons:create heroku-postgresql --app $YOUR_APP_NAME $ git push $YOUR_REMOTE_NAME $YOUR_BRANCH:master $ heroku run python manage.py syncdb --migrate --app $YOUR_APP_NAME $ heroku run python manage.py load_lookup_lists $ heroku run python manage.py createinitialrevisions --app $YOUR_APP_NAME","title":"Your implementation"},{"location":"guides/dump/#your-implementation","text":"Your implementation is a Django project with some extras.","title":"Your implementation"},{"location":"guides/dump/#opal-settings","text":"OPAL_LOG_OUT_DURATION = The number of milliseconds after which to log out our user OPAL_BRAND_NAME = The branding to be displayed as the masthead OPAL_EXTRA_APPLICATION = A template to include in the HEAD OPAL_EXTRA_HEADER = A template to include above the main nav","title":"Opal settings"},{"location":"guides/dump/#defining-models","text":"Models should be defined in your project. They should subclass opal.models.EpisodeSubrecord or opal.models.PatientSubrecord as appropriate. Subrecords have some extra entrypoints that are used by Opal.","title":"Defining Models"},{"location":"guides/dump/#_is_singleton","text":"_is_singleton is a boolean property that ensures that there is only one of this subrecord per patient/episode. Effectively this defaults to False.","title":"_is_singleton"},{"location":"guides/dump/#_title","text":"_title sets the column headings in list view. Effectively this defaults to camel_case_to_underscore() on the class name.","title":"_title"},{"location":"guides/dump/#_sort","text":"_sort names a field by which we would like to sorth the display of subrecords.","title":"_sort"},{"location":"guides/dump/#_read_only","text":"Marks a field as read only if True","title":"_read_only"},{"location":"guides/dump/#_batch_template","text":"Allow the list/detail template access to the complete row, not just an item. Template is then responsible for registering click handlers. Will get cix as a variable representing the column index, column_name as the column name.","title":"_batch_template"},{"location":"guides/dump/#adding-a-controller","text":"Create the controller file in static/js/opal/controllers. Use the angular module opal.controllers Include this file in templates/opal.html Create a template url in the django layer","title":"Adding a controller"},{"location":"guides/dump/#creating-a-heroku-test-server","text":"$ heroku create $YOUR_APP_NAME (Edit .git/config to give the remote a meaningful name) $ heroku addons:create heroku-postgresql --app $YOUR_APP_NAME $ git push $YOUR_REMOTE_NAME $YOUR_BRANCH:master $ heroku run python manage.py syncdb --migrate --app $YOUR_APP_NAME $ heroku run python manage.py load_lookup_lists $ heroku run python manage.py createinitialrevisions --app $YOUR_APP_NAME","title":"Creating a Heroku test server"},{"location":"guides/flow/","text":"Flow hooks in Opal Opal provides various hooks that developers can use to customise behaviour at certain key points in a patient's journey through a clinical service - for example when a patient is discharged. These hooks are associated with verbs enter , exit . The Flow service Your application scaffold will have created a file at ./yourapp/assets/js/yourapp/services/flow.js . This file will declare an angular service that your application will use to determine how to move to the correct next step for a patient. To enable this, we must set the following setting: # settings.py OPAL_FLOW_SERVICE = 'MyAppFlow' Flow services must define an enter and an exit method, which both return the appropriate angular controller and template to use. Although Opal provides sensible default controllers and templates for these common actions, applications with custom flows may customise these methods as required. The enter verb The enter verb is called when a patient is added to a service - for instance by adding a patient to a team list. Implementations of enter are expected to return a dictionary of the controller and template they wish to be called. enter: function(){ return { 'controller': 'HospitalNumberCtrl', 'template' : '/templates/modals/hospital_number.html/' } } A common strategy is to examine angular $route or $routeParams to determine where the user is in the application. For instance you may wish to have custom controllers for a particular patient list, or the search results page. The exit verb The exit verb is called when a patient is moving through a service - for instance when we discharge a patient, or end one phase of a clinical pathway. Implementations of exit are expected to return a dictionary of the controller and template they wish to be called. The enter verb will receive the episode that we are acting on - for instance a controller that acts differently for deceased patients might look as follows exit: function(episode){ if(episode.demographics[0].deceased){ return { 'controller': 'DeceasedDischargeEpisodeCtrl', 'template' : '/templates/modals/deceased_discharge.html/' } } return { 'controller': 'DischargeEpisodeCtrl', 'template' : '/templates/modals/discharge_episode.html/' } }","title":"Flow"},{"location":"guides/flow/#flow-hooks-in-opal","text":"Opal provides various hooks that developers can use to customise behaviour at certain key points in a patient's journey through a clinical service - for example when a patient is discharged. These hooks are associated with verbs enter , exit .","title":"Flow hooks in Opal"},{"location":"guides/flow/#the-flow-service","text":"Your application scaffold will have created a file at ./yourapp/assets/js/yourapp/services/flow.js . This file will declare an angular service that your application will use to determine how to move to the correct next step for a patient. To enable this, we must set the following setting: # settings.py OPAL_FLOW_SERVICE = 'MyAppFlow' Flow services must define an enter and an exit method, which both return the appropriate angular controller and template to use. Although Opal provides sensible default controllers and templates for these common actions, applications with custom flows may customise these methods as required.","title":"The Flow service"},{"location":"guides/flow/#the-enter-verb","text":"The enter verb is called when a patient is added to a service - for instance by adding a patient to a team list. Implementations of enter are expected to return a dictionary of the controller and template they wish to be called. enter: function(){ return { 'controller': 'HospitalNumberCtrl', 'template' : '/templates/modals/hospital_number.html/' } } A common strategy is to examine angular $route or $routeParams to determine where the user is in the application. For instance you may wish to have custom controllers for a particular patient list, or the search results page.","title":"The enter verb"},{"location":"guides/flow/#the-exit-verb","text":"The exit verb is called when a patient is moving through a service - for instance when we discharge a patient, or end one phase of a clinical pathway. Implementations of exit are expected to return a dictionary of the controller and template they wish to be called. The enter verb will receive the episode that we are acting on - for instance a controller that acts differently for deceased patients might look as follows exit: function(episode){ if(episode.demographics[0].deceased){ return { 'controller': 'DeceasedDischargeEpisodeCtrl', 'template' : '/templates/modals/deceased_discharge.html/' } } return { 'controller': 'DischargeEpisodeCtrl', 'template' : '/templates/modals/discharge_episode.html/' } }","title":"The exit verb"},{"location":"guides/forms/","text":"Forms Editing Records The editing of records is a key component of any Opal application. A key pattern is to edit or create an individual record in a modal containing the form for just that record. Opal provides the Angular Controller opal.controllers.EditItemCtrl for doing just this Customising the Angular Controller Opal uses the formController attribute of an Item to determine which Angular Controller to use. This defaults to opal.controllers.EditItemCtrl . Individual Subrecords may customise this by implementing an Angualar record Service and overriding the formController attribute. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ record.formController = 'MyCustomDiagnosisFormController'; return record; } }); Custom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved Form and modal templates Subrecords have get_form_template() and get_modal_template() methods, which are used for figuring out how to render forms for interacting with them. These use the following template paths based on the context in which they are called: # Forms forms/{episode_type}/{list slug}/{record_name}_form.html forms/{list_slug}/{record_name}_form.html forms/{episode_type}/{record_name}_form.html forms/{record_name}_form.html # Modals modals/{episode_type}/{list slug}/{record_name}_modal.html modals/{list_slug}/{record_name}_modal.html modals/{episode_type}/{record_name}_modal.html modals/{record_name}_modal.html Autogenerating forms The opal commandline tool has a scaffold command, which will autogenerate missing form templates for subrecord models. Simply run the following command to generate. $ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE (Note this will also generate and run migrations for any unmigrated models.xb) Client side Validation Client side validation for forms requires a pattern and a help block uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input) Helpers Opal contains a number of helpers for developing forms and input modals. Many of these are located in the forms template tag library, which is a Django templatetag library that understands the context of common patterns with Opal for creating forms and modals. It provides helpers for various input types that will allow you to render consistent forms, with less verbose templates. {% load forms %} form class=\"form-horizontal\" {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %} {% datepicker label=\"Date\" model=\"editing.date\" %} {% checkbox label=\"Alone?\" model=\"editing.alone\" %} /form For full documentation of the options, please see the Form templatetags reference material","title":"Forms"},{"location":"guides/forms/#forms","text":"","title":"Forms"},{"location":"guides/forms/#editing-records","text":"The editing of records is a key component of any Opal application. A key pattern is to edit or create an individual record in a modal containing the form for just that record. Opal provides the Angular Controller opal.controllers.EditItemCtrl for doing just this","title":"Editing Records"},{"location":"guides/forms/#customising-the-angular-controller","text":"Opal uses the formController attribute of an Item to determine which Angular Controller to use. This defaults to opal.controllers.EditItemCtrl . Individual Subrecords may customise this by implementing an Angualar record Service and overriding the formController attribute. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ record.formController = 'MyCustomDiagnosisFormController'; return record; } }); Custom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved","title":"Customising the Angular Controller"},{"location":"guides/forms/#form-and-modal-templates","text":"Subrecords have get_form_template() and get_modal_template() methods, which are used for figuring out how to render forms for interacting with them. These use the following template paths based on the context in which they are called: # Forms forms/{episode_type}/{list slug}/{record_name}_form.html forms/{list_slug}/{record_name}_form.html forms/{episode_type}/{record_name}_form.html forms/{record_name}_form.html # Modals modals/{episode_type}/{list slug}/{record_name}_modal.html modals/{list_slug}/{record_name}_modal.html modals/{episode_type}/{record_name}_modal.html modals/{record_name}_modal.html","title":"Form and modal templates"},{"location":"guides/forms/#autogenerating-forms","text":"The opal commandline tool has a scaffold command, which will autogenerate missing form templates for subrecord models. Simply run the following command to generate. $ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE (Note this will also generate and run migrations for any unmigrated models.xb)","title":"Autogenerating forms"},{"location":"guides/forms/#client-side-validation","text":"Client side validation for forms requires a pattern and a help block uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input)","title":"Client side Validation"},{"location":"guides/forms/#helpers","text":"Opal contains a number of helpers for developing forms and input modals. Many of these are located in the forms template tag library, which is a Django templatetag library that understands the context of common patterns with Opal for creating forms and modals. It provides helpers for various input types that will allow you to render consistent forms, with less verbose templates. {% load forms %} form class=\"form-horizontal\" {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %} {% datepicker label=\"Date\" model=\"editing.date\" %} {% checkbox label=\"Alone?\" model=\"editing.alone\" %} /form For full documentation of the options, please see the Form templatetags reference material","title":"Helpers"},{"location":"guides/json_api/","text":"The Opal JSON API Opal features a rich, self documenting set of open JSON APIs. Opal applications are generally simply a collection of Browser-based clients for these APIs. Opal uses Django Rest Framework to provide it's APIs. You may examine the API of any running Opal application by navigating to the url /api/v0.1/ Adding your own APIs You can add your own APIs to the Opal API namespace from plugins or by registering them directly with the router. from rest_framework.viewsets import ViewSet from rest_framework.response import Response from opal.core.api import router class PingViewSet(ViewSet): def list(self, request): return Response('pong') router.register('ping', PingViewSet) APIs can make use of method decorators item_from_pk , episode_from_pk and patient_from_pk that will replace a pk passed into a method with self.model, Episode or Patient respectively. e.g. class SomeBespokeViewset(viewsets.Viewset): model = ClinicialInformation @item_from_pk def some_api_endpoint(self, request, clinical_information): # Some logic Authentication Opal uses Django Rest Framework (DRF) to provide APIs. DRF ships with multiple authentication mechanisms which are highly configurable. By default, Opal applications (e.g. created with the Opal scaffolding) will enable Sesison and Token based authentication. More details on DRF authentication are available in their excellent documentation . Permissioning Opal uses the DRF permissions system for JSON APIs. Opal ships with opal.core.api.LoginRequiredViewset which adds the permission class IsAuthenticated by default. Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. More details on DRF permissions are available in the DRF documentation . Session Based Session based authentication enables users logged in via the standard Django auth mechanism to use the API. This is what most Opal applications in the browser will use. Token Based Token based authentication is targetted at other applications consuming the Opal API, and requires the application to pass an API token as a header. These tokens must be associated with a Django user, and can be created in the Django Admin. An example of a client using token based authentication is found in the OpalAPI project.","title":"JSON API"},{"location":"guides/json_api/#the-opal-json-api","text":"Opal features a rich, self documenting set of open JSON APIs. Opal applications are generally simply a collection of Browser-based clients for these APIs. Opal uses Django Rest Framework to provide it's APIs. You may examine the API of any running Opal application by navigating to the url /api/v0.1/","title":"The Opal JSON API"},{"location":"guides/json_api/#adding-your-own-apis","text":"You can add your own APIs to the Opal API namespace from plugins or by registering them directly with the router. from rest_framework.viewsets import ViewSet from rest_framework.response import Response from opal.core.api import router class PingViewSet(ViewSet): def list(self, request): return Response('pong') router.register('ping', PingViewSet) APIs can make use of method decorators item_from_pk , episode_from_pk and patient_from_pk that will replace a pk passed into a method with self.model, Episode or Patient respectively. e.g. class SomeBespokeViewset(viewsets.Viewset): model = ClinicialInformation @item_from_pk def some_api_endpoint(self, request, clinical_information): # Some logic","title":"Adding your own APIs"},{"location":"guides/json_api/#authentication","text":"Opal uses Django Rest Framework (DRF) to provide APIs. DRF ships with multiple authentication mechanisms which are highly configurable. By default, Opal applications (e.g. created with the Opal scaffolding) will enable Sesison and Token based authentication. More details on DRF authentication are available in their excellent documentation .","title":"Authentication"},{"location":"guides/json_api/#permissioning","text":"Opal uses the DRF permissions system for JSON APIs. Opal ships with opal.core.api.LoginRequiredViewset which adds the permission class IsAuthenticated by default. Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. More details on DRF permissions are available in the DRF documentation .","title":"Permissioning"},{"location":"guides/json_api/#session-based","text":"Session based authentication enables users logged in via the standard Django auth mechanism to use the API. This is what most Opal applications in the browser will use.","title":"Session Based"},{"location":"guides/json_api/#token-based","text":"Token based authentication is targetted at other applications consuming the Opal API, and requires the application to pass an API token as a header. These tokens must be associated with a Django user, and can be created in the Django Admin. An example of a client using token based authentication is found in the OpalAPI project.","title":"Token Based"},{"location":"guides/list_views/","text":"Opal Patient List views Opal provides support for displaying lists of patients, both via a spreadsheet like view, and with a card based view. Defining lists Opal patient lists are subclasses of opal.core.patient_lists.PatientList . Typically these are found in a patient_lists.py module of your application or plugin. (Lists can be defined elsewhere, but may not be autodiscovered.) A basic list needs only define it's display_name a queryset of episodes to display, and a schema of subrecords to show for each episode. # patient_lists.py from opal.models import Episore from opal.core import patient_lists from myapplication import models class AlphabetListA(patient_lists.PatientList): display_name = 'A Patients' queryset = Episode.objects.filter(demographics__name__istartswith='a') schema = [ models.Demographics, models.Location, models.Diagnosis, models.Treatment ] The display_name property is the human readable name for our list - which is displayed as link text to our list. Schemas The schema attribute declares the columns of a PatientList. The entries in a schema may either be Subrecord instances, or instances of opal.core.patient_lists.Column . Custom Columns Although most schema entries will be subrecords, it can be useful to have non-subrecord columns. For instance because you want to allow a composite column fo mulitple Subrecords or because we want to simply render arbitrary markup. Columns require the title, and template_path to be set, and are simply included in the schema list. class MyMarkupList(patient_lists.PatientList): schema = [ patient_lists.Column(title='Foo', template_path='foo/bar') ] Template selection The list view is constructed by rendering a column for each record, in the order defined in the schema, and a row for each episode in the list. The template for each cell should live in ./templates/records/* . In order to select the appropriate template for a given episode, Opal looks in the following locations: records/{episode_type}/{list slug}/{record_name}.html records/{list_slug}/{record_name}.html records/{episode_type}/{record_name}.html records/{record_name}.html Querysets The queryset property of your list should contain all of the episodes for this particular list. On occasion we require a more dynamic queryset, in which case we can ovreride the get_queryset method. # patient_lists.py import datetime from opal.models import Episode from opal.core import patient_lists class MyWeeklyList(patient_lists.PatientList): def get_queryset(self): one_week_ago = datetime.date.today() - datetime.timedelta(days=1) return Episode.objects.filter(date_of_admission__gte=one_week_ago) Ordering Lists As a discoverable.SortableFeature lists may be ordered by setting the order property to an integer. Lists will display in drop-downs, tables et cetera, in this order. Slug As a discoverable feature, the slug for each list is determined by either setting the slug property, or returning a string from the get_slug classmethod. Templates Tagged Patient Lists A common model for working with lists is to use lists based on the tags assigned to an episode. This allows users to add and remove patients from lists as they see fit, rather than attempting to infer it from other properties of the patient (e.g. their current location for instance.) which can be particularly challenging for some clinical services. Opal provides a specific subclass for working with Tagged Patient Lists: # patient_lists.py from opal.core import patient_lists class MyTagList(patient_lists.TaggedPatientList): display_name = 'Tagged blue' tag = 'blue' Tagged lists will automatically fetch the appropriate queryset for patients tagged with the tag you specify. Invalid Tagged Patient Lists Tag names may not have hyphens in them - Opal uses hyphens to distinguish between tags and subtags in the urls for lists, so attempting to define one will raise an exception. class MyList(TaggedPatientList): tag = 'foo-bar' # This will raise InvalidDiscoverableFeatureError ! Direct Add Sometimes, we want to control the flow of patients onto, off, or between lists a little more closely. For instance, we might need to ensure additional data collection at points in a patient journey. In order to accomplish this, we often implement custom patient flows that wil programatically tag episodes to tagged lists. In those cases we will want to prevent users from manually adding or removing the tags themselves. This can be easily accomplished via the direct_add property. When set to false, users will not be able to add the tag for this list. class MyLockedDownList(TaggedPatientList): tag = 'liaisonpatients' direct_add = False Customising Sort order of Episodes By default, PatientLists sort according to the Angular method Episode.compare . You may override this on a list-by-list basis by setting the comparator_service attribute. class MySortedList(PatientList): comparator_service = 'MyComparatorService' This attribute should be the name of an Angular service that returns a list of comparator functions. For instance, to sort by Episode.category_name then Episode id: angular.module('opal.services') .factory('MyComparatorService', function(){ use strict ; return [ function(e){ return e.category_name }, function(e){ return e.id } ] }) The file containing your comparator service must be included in the javascripts of your application or plugin in order to be available on the client. Access Control As PatientLists are a RestrictableFeature , Access control for lists is set by overriding the visible_to classmethod. Your list will only be visible to those users for whom this method returns True . For instance, we could define a Patient List that was only available to Django Superusers: class SuperuserPatientList(PatientList): @classmethod def visible_to(klass, user): return user.is_superuser Grouping related Patient Lists We commonly require groups of patient lists for a single clinical service. For example a busy outpatients cinic might have one list of people in the waiting room, one list of people being triaged, one list for people waiting to see the medical staff, and another for people who have been seen but need review - for instance because they have outstanding test results. Opal provides the TabbedPatientListGroup class to help with this case. Tabbed Patient List Groups are an ordered collection of related Patient Lists that are displayed as tabs at the top of any list in the group. Defining a Tabbed Patient List Group Defining a group can be as simple as declaring member lists in a property. # yourapp/patient_lists.py from opal.core import patient_lists # ... Define your lists here class MyListGroup(patient_lists.TabbedPatientListGroup): member_lists = [MyFirstPatientList, MySecondPatientList, ...] Tabbed Patient List Groups are a Discoverable feature, we expect them to be in a module named patient_lists.py in one of the Django apps in your application. Customising membership The members of your group can be determined dynamically by overriding the get_member_lists classmethod of your group: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def get_member_lists(klass): # return an iterable of PatientList subclasses Restricting access By default, the UI for a TabbedPatientListGroup is shown at the top of any member PatientList as long as there are more than one members of the group visible to the given user. This behaviour can be customised by overriding the visible_to classmethod: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def visible_to(klass, user): # return True or False appropriately Customising templates Applications may customise the UI for Tabbed Patient List Groups by customising the template patient_lists/tabbed_list_group.html . The default template simply extends patient_lists/tabbed_list_group_base.html .","title":"Patient List Views"},{"location":"guides/list_views/#opal-patient-list-views","text":"Opal provides support for displaying lists of patients, both via a spreadsheet like view, and with a card based view.","title":"Opal Patient List views"},{"location":"guides/list_views/#defining-lists","text":"Opal patient lists are subclasses of opal.core.patient_lists.PatientList . Typically these are found in a patient_lists.py module of your application or plugin. (Lists can be defined elsewhere, but may not be autodiscovered.) A basic list needs only define it's display_name a queryset of episodes to display, and a schema of subrecords to show for each episode. # patient_lists.py from opal.models import Episore from opal.core import patient_lists from myapplication import models class AlphabetListA(patient_lists.PatientList): display_name = 'A Patients' queryset = Episode.objects.filter(demographics__name__istartswith='a') schema = [ models.Demographics, models.Location, models.Diagnosis, models.Treatment ] The display_name property is the human readable name for our list - which is displayed as link text to our list.","title":"Defining lists"},{"location":"guides/list_views/#schemas","text":"The schema attribute declares the columns of a PatientList. The entries in a schema may either be Subrecord instances, or instances of opal.core.patient_lists.Column .","title":"Schemas"},{"location":"guides/list_views/#custom-columns","text":"Although most schema entries will be subrecords, it can be useful to have non-subrecord columns. For instance because you want to allow a composite column fo mulitple Subrecords or because we want to simply render arbitrary markup. Columns require the title, and template_path to be set, and are simply included in the schema list. class MyMarkupList(patient_lists.PatientList): schema = [ patient_lists.Column(title='Foo', template_path='foo/bar') ]","title":"Custom Columns"},{"location":"guides/list_views/#template-selection","text":"The list view is constructed by rendering a column for each record, in the order defined in the schema, and a row for each episode in the list. The template for each cell should live in ./templates/records/* . In order to select the appropriate template for a given episode, Opal looks in the following locations: records/{episode_type}/{list slug}/{record_name}.html records/{list_slug}/{record_name}.html records/{episode_type}/{record_name}.html records/{record_name}.html","title":"Template selection"},{"location":"guides/list_views/#querysets","text":"The queryset property of your list should contain all of the episodes for this particular list. On occasion we require a more dynamic queryset, in which case we can ovreride the get_queryset method. # patient_lists.py import datetime from opal.models import Episode from opal.core import patient_lists class MyWeeklyList(patient_lists.PatientList): def get_queryset(self): one_week_ago = datetime.date.today() - datetime.timedelta(days=1) return Episode.objects.filter(date_of_admission__gte=one_week_ago)","title":"Querysets"},{"location":"guides/list_views/#ordering-lists","text":"As a discoverable.SortableFeature lists may be ordered by setting the order property to an integer. Lists will display in drop-downs, tables et cetera, in this order.","title":"Ordering Lists"},{"location":"guides/list_views/#slug","text":"As a discoverable feature, the slug for each list is determined by either setting the slug property, or returning a string from the get_slug classmethod.","title":"Slug"},{"location":"guides/list_views/#templates","text":"","title":"Templates"},{"location":"guides/list_views/#tagged-patient-lists","text":"A common model for working with lists is to use lists based on the tags assigned to an episode. This allows users to add and remove patients from lists as they see fit, rather than attempting to infer it from other properties of the patient (e.g. their current location for instance.) which can be particularly challenging for some clinical services. Opal provides a specific subclass for working with Tagged Patient Lists: # patient_lists.py from opal.core import patient_lists class MyTagList(patient_lists.TaggedPatientList): display_name = 'Tagged blue' tag = 'blue' Tagged lists will automatically fetch the appropriate queryset for patients tagged with the tag you specify.","title":"Tagged Patient Lists"},{"location":"guides/list_views/#invalid-tagged-patient-lists","text":"Tag names may not have hyphens in them - Opal uses hyphens to distinguish between tags and subtags in the urls for lists, so attempting to define one will raise an exception. class MyList(TaggedPatientList): tag = 'foo-bar' # This will raise InvalidDiscoverableFeatureError !","title":"Invalid Tagged Patient Lists"},{"location":"guides/list_views/#direct-add","text":"Sometimes, we want to control the flow of patients onto, off, or between lists a little more closely. For instance, we might need to ensure additional data collection at points in a patient journey. In order to accomplish this, we often implement custom patient flows that wil programatically tag episodes to tagged lists. In those cases we will want to prevent users from manually adding or removing the tags themselves. This can be easily accomplished via the direct_add property. When set to false, users will not be able to add the tag for this list. class MyLockedDownList(TaggedPatientList): tag = 'liaisonpatients' direct_add = False","title":"Direct Add"},{"location":"guides/list_views/#customising-sort-order-of-episodes","text":"By default, PatientLists sort according to the Angular method Episode.compare . You may override this on a list-by-list basis by setting the comparator_service attribute. class MySortedList(PatientList): comparator_service = 'MyComparatorService' This attribute should be the name of an Angular service that returns a list of comparator functions. For instance, to sort by Episode.category_name then Episode id: angular.module('opal.services') .factory('MyComparatorService', function(){ use strict ; return [ function(e){ return e.category_name }, function(e){ return e.id } ] }) The file containing your comparator service must be included in the javascripts of your application or plugin in order to be available on the client.","title":"Customising Sort order of Episodes"},{"location":"guides/list_views/#access-control","text":"As PatientLists are a RestrictableFeature , Access control for lists is set by overriding the visible_to classmethod. Your list will only be visible to those users for whom this method returns True . For instance, we could define a Patient List that was only available to Django Superusers: class SuperuserPatientList(PatientList): @classmethod def visible_to(klass, user): return user.is_superuser","title":"Access Control"},{"location":"guides/list_views/#grouping-related-patient-lists","text":"We commonly require groups of patient lists for a single clinical service. For example a busy outpatients cinic might have one list of people in the waiting room, one list of people being triaged, one list for people waiting to see the medical staff, and another for people who have been seen but need review - for instance because they have outstanding test results. Opal provides the TabbedPatientListGroup class to help with this case. Tabbed Patient List Groups are an ordered collection of related Patient Lists that are displayed as tabs at the top of any list in the group.","title":"Grouping related Patient Lists"},{"location":"guides/list_views/#defining-a-tabbed-patient-list-group","text":"Defining a group can be as simple as declaring member lists in a property. # yourapp/patient_lists.py from opal.core import patient_lists # ... Define your lists here class MyListGroup(patient_lists.TabbedPatientListGroup): member_lists = [MyFirstPatientList, MySecondPatientList, ...] Tabbed Patient List Groups are a Discoverable feature, we expect them to be in a module named patient_lists.py in one of the Django apps in your application.","title":"Defining a Tabbed Patient List Group"},{"location":"guides/list_views/#customising-membership","text":"The members of your group can be determined dynamically by overriding the get_member_lists classmethod of your group: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def get_member_lists(klass): # return an iterable of PatientList subclasses","title":"Customising membership"},{"location":"guides/list_views/#restricting-access","text":"By default, the UI for a TabbedPatientListGroup is shown at the top of any member PatientList as long as there are more than one members of the group visible to the given user. This behaviour can be customised by overriding the visible_to classmethod: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def visible_to(klass, user): # return True or False appropriately","title":"Restricting access"},{"location":"guides/list_views/#customising-templates","text":"Applications may customise the UI for Tabbed Patient List Groups by customising the template patient_lists/tabbed_list_group.html . The default template simply extends patient_lists/tabbed_list_group_base.html .","title":"Customising templates"},{"location":"guides/lookup_lists/","text":"","title":"Lookup Lists"},{"location":"guides/metadata/","text":"Application Metadata Applications commonly need to pass data to the front end which is not either clinical data about a patient or episode of care, or coded reference data . Opal provides a simple API for working with such data via the opal.core.metadata.Metadata discoverable . metadata is made available on the scopes for patient lists and patient details Defining Metadata Defining metadata uses the same pattern as all discoverable features, we define a subclass: from django.conf import settings from opal.core import metadata class FavouriteColours(metadata.Metadata): slug = 'favourite-colour' @classmethod def to_dict(klass, **kwargs): return {'favourite_colour': settings.FAVOURITE_COLOUR} The to_dict method will be passed the current user as a keyword argument. Accessing Metadata on the front end We can access our metadata with the Angular Metadata service. // yourapp/routes.js when('/my/route', { controller: 'MyCtrl', resolve: { metadata: function(Metadata){ return Metadata; } } } // yourapp/yourctrl.js angular.module('yourapp.controllers').controller( 'MyCtrl', function($scope, metadata){ $scope.favourite_colour = metadata.favourite_colour; console.log($scope.favourite_colour); // - Whatever settings.FAVOURITE_COLOUR is set to });","title":"Metadata"},{"location":"guides/metadata/#application-metadata","text":"Applications commonly need to pass data to the front end which is not either clinical data about a patient or episode of care, or coded reference data . Opal provides a simple API for working with such data via the opal.core.metadata.Metadata discoverable . metadata is made available on the scopes for patient lists and patient details","title":"Application Metadata"},{"location":"guides/metadata/#defining-metadata","text":"Defining metadata uses the same pattern as all discoverable features, we define a subclass: from django.conf import settings from opal.core import metadata class FavouriteColours(metadata.Metadata): slug = 'favourite-colour' @classmethod def to_dict(klass, **kwargs): return {'favourite_colour': settings.FAVOURITE_COLOUR} The to_dict method will be passed the current user as a keyword argument.","title":"Defining Metadata"},{"location":"guides/metadata/#accessing-metadata-on-the-front-end","text":"We can access our metadata with the Angular Metadata service. // yourapp/routes.js when('/my/route', { controller: 'MyCtrl', resolve: { metadata: function(Metadata){ return Metadata; } } } // yourapp/yourctrl.js angular.module('yourapp.controllers').controller( 'MyCtrl', function($scope, metadata){ $scope.favourite_colour = metadata.favourite_colour; console.log($scope.favourite_colour); // - Whatever settings.FAVOURITE_COLOUR is set to });","title":"Accessing Metadata on the front end"},{"location":"guides/patient_detail_views/","text":"Opal Patient Detail Views Opal provides all patients with a detail view. The default detail view will allow the user to switch between all of a patient's episodes , as well as editing patient information linked to the patient rather than an episode. (Allergies for example.) Template selection The base template for a patient detail view is ./opal/templates/patient_detail_base.html , although you can override or customise that for your application most easily by implementing a ./templates/patient_detail.html and customising specific blocks, as the Opal implementation simply includes the base template. Each episode will display using the template appropriate for it's EpisodeCategory - for instance an InpatientEpisode will use ./templates/detail/inpatient.html . You may define your own episode types should you require. Record Panels A frequent pattern when constructing detail views is to render a panel for a particular Subrecord type. The panels templatetag library contains some useful helpers for rendering panels based on models. {% load panels %} {% record_panel Diagnosis %} The above code will render a panel for your episode, including the Subrecord detail template for each instance, and allowing editing, deletion and creation of instances of your Subrecord . You may also consult the Detailed reference documentation for Record Panels. Custom Patient Detail Views Sometimes we also need to display information about a patient across multiple episodes, or simlply a particular view of one episode. For instance, you might like to have a specific view for showing all of the lab results for a patient, which would be overwhelming were they all displayed in the episode detail view. Opal's PatientDetailView allows you to do just this. To add an additional view to a patient you simply declare a PatientDetailView class: # detail.py from opal.core import detail class MyCustomView(detail.PatientDetailView): name = 'my_custom_view' title = 'Special View' template = 'detail/my_custom_view.html' This will then be available in the Patient Detail view in the episode switcher menu. You can find details of all the various options for PatientDetailViews in the reference documentation .","title":"Patient Detail Views"},{"location":"guides/patient_detail_views/#opal-patient-detail-views","text":"Opal provides all patients with a detail view. The default detail view will allow the user to switch between all of a patient's episodes , as well as editing patient information linked to the patient rather than an episode. (Allergies for example.)","title":"Opal Patient Detail Views"},{"location":"guides/patient_detail_views/#template-selection","text":"The base template for a patient detail view is ./opal/templates/patient_detail_base.html , although you can override or customise that for your application most easily by implementing a ./templates/patient_detail.html and customising specific blocks, as the Opal implementation simply includes the base template. Each episode will display using the template appropriate for it's EpisodeCategory - for instance an InpatientEpisode will use ./templates/detail/inpatient.html . You may define your own episode types should you require.","title":"Template selection"},{"location":"guides/patient_detail_views/#record-panels","text":"A frequent pattern when constructing detail views is to render a panel for a particular Subrecord type. The panels templatetag library contains some useful helpers for rendering panels based on models. {% load panels %} {% record_panel Diagnosis %} The above code will render a panel for your episode, including the Subrecord detail template for each instance, and allowing editing, deletion and creation of instances of your Subrecord . You may also consult the Detailed reference documentation for Record Panels.","title":"Record Panels"},{"location":"guides/patient_detail_views/#custom-patient-detail-views","text":"Sometimes we also need to display information about a patient across multiple episodes, or simlply a particular view of one episode. For instance, you might like to have a specific view for showing all of the lab results for a patient, which would be overwhelming were they all displayed in the episode detail view. Opal's PatientDetailView allows you to do just this. To add an additional view to a patient you simply declare a PatientDetailView class: # detail.py from opal.core import detail class MyCustomView(detail.PatientDetailView): name = 'my_custom_view' title = 'Special View' template = 'detail/my_custom_view.html' This will then be available in the Patient Detail view in the episode switcher menu. You can find details of all the various options for PatientDetailViews in the reference documentation .","title":"Custom Patient Detail Views"},{"location":"guides/plugins/","text":"Writing Plugins Opal Plugins are Django apps on the server side, and collections of angular.js models for the client. Getting started with your plugin The Opal commandline tool will bootstrap your plugin for you - just run: $ opal startplugin yourcoolplugin Adding Discoverable Functionality A common pattern for plugins is to add functionality that other plugins or applications can use by inheriting a base class that you define in a file with a magic name. (In much the same way that Django provides models.) For example, if you're creating an appointments plugin that helps people to book and schedule appointments in clinics, you would create a base Clinic class that can be subclassed to create specific clinics. class Clinic(opal.core.discoverable.DiscoverableFeature): module_name = 'clinics' We can then create clinics in any installed app, and they will be available from Clinic.list() class OutpatientsClinic(Clinic): name = 'Outpatients' # Add your custom clnic functionality here e.g. def book_appointment(self, date, patient): pass Clinic.list() # - Generator including OutPatientsClinic Clinic.get('outpatients) # - OutpatientsClinic Defining new flows Plugins can define flows. They should return a dictionary of flows from the flows() method of the plugin class. Getting a plugin directory Each plugin has a directory() method that returns the file system location of the module. Adding URLS Add an urls.py, then add to your plugin class as YourPlugin.urls Naturally, these can point to views in your plugin! Adding Javascript add to static, then add to your plugin class as YourPlugin.javascripts There are some restricted namespaces for these... Adding APIs Opal uses Django Rest Framweork to provide APIs, and you may add to these from your plugin. By convention, APIs live in yourplugin/api.py . You are expected to provide a rest_framework.viewsets.ViewSet subclass, which you then detail as the .apis attribute of your plugin. # yourplugin/api.py from rest_framework.viewsets import ViewSet from rest_framework.response import Response class PingViewSet(ViewSet): def list(self, request): return Response('pong') # yourplugin/__init__.py from opal.core.plugins import OpalPlugin from yourplugin import api class YourPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ] These APIs will then be available and self-documenting fom the standard Opal url /api/v0.1/ Permissioning Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. Django Rest Framework ViewSet classes have an extensive permissioning system . Opal ships with the base ViewSet class opal.core.api.LoginRequiredViewset which adds the Django Rest Framework permission class IsAuthenticated to your viewset. class PingViewSet(LoginRequiredViewset): def list(self, request): return Response('pong') Adding Actions to the sidebar Actions can be added to the sidebar by setting the actions attribute of your plugin. Actions is expected to be an iterable of strings which are templates to be included in the sidebar. By convention, actions will live in ./templates/actions/ . # __init__.py: class Plugin(OpalPlugin): actions = ('actions/javascript_alert.html', 'actions/dummy_button.html') And then in the template: p ng-show=\"episode.category == 'YourEpisodeCategory'\" button class=\"btn btn-primary\" ng-click=\"alert('Boom!')\" i href=\"fa fa-warning\" /i ALERT ME /button /p Adding dependencies globally to our angular modules Dependencies listed in angular_module_deps will be added to all Angular modules (as long as they use the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we won't for now. Installing plugins Add to installed apps Add to requirements if appropriate Adding extra markup to the tag Any templates you define in the property .head_extra will be included in the","title":"Plugins"},{"location":"guides/plugins/#writing-plugins","text":"Opal Plugins are Django apps on the server side, and collections of angular.js models for the client.","title":"Writing Plugins"},{"location":"guides/plugins/#getting-started-with-your-plugin","text":"The Opal commandline tool will bootstrap your plugin for you - just run: $ opal startplugin yourcoolplugin","title":"Getting started with your plugin"},{"location":"guides/plugins/#adding-discoverable-functionality","text":"A common pattern for plugins is to add functionality that other plugins or applications can use by inheriting a base class that you define in a file with a magic name. (In much the same way that Django provides models.) For example, if you're creating an appointments plugin that helps people to book and schedule appointments in clinics, you would create a base Clinic class that can be subclassed to create specific clinics. class Clinic(opal.core.discoverable.DiscoverableFeature): module_name = 'clinics' We can then create clinics in any installed app, and they will be available from Clinic.list() class OutpatientsClinic(Clinic): name = 'Outpatients' # Add your custom clnic functionality here e.g. def book_appointment(self, date, patient): pass Clinic.list() # - Generator including OutPatientsClinic Clinic.get('outpatients) # - OutpatientsClinic","title":"Adding Discoverable Functionality"},{"location":"guides/plugins/#defining-new-flows","text":"Plugins can define flows. They should return a dictionary of flows from the flows() method of the plugin class.","title":"Defining new flows"},{"location":"guides/plugins/#getting-a-plugin-directory","text":"Each plugin has a directory() method that returns the file system location of the module.","title":"Getting a plugin directory"},{"location":"guides/plugins/#adding-urls","text":"Add an urls.py, then add to your plugin class as YourPlugin.urls Naturally, these can point to views in your plugin!","title":"Adding URLS"},{"location":"guides/plugins/#adding-javascript","text":"add to static, then add to your plugin class as YourPlugin.javascripts There are some restricted namespaces for these...","title":"Adding Javascript"},{"location":"guides/plugins/#adding-apis","text":"Opal uses Django Rest Framweork to provide APIs, and you may add to these from your plugin. By convention, APIs live in yourplugin/api.py . You are expected to provide a rest_framework.viewsets.ViewSet subclass, which you then detail as the .apis attribute of your plugin. # yourplugin/api.py from rest_framework.viewsets import ViewSet from rest_framework.response import Response class PingViewSet(ViewSet): def list(self, request): return Response('pong') # yourplugin/__init__.py from opal.core.plugins import OpalPlugin from yourplugin import api class YourPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ] These APIs will then be available and self-documenting fom the standard Opal url /api/v0.1/","title":"Adding APIs"},{"location":"guides/plugins/#permissioning","text":"Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. Django Rest Framework ViewSet classes have an extensive permissioning system . Opal ships with the base ViewSet class opal.core.api.LoginRequiredViewset which adds the Django Rest Framework permission class IsAuthenticated to your viewset. class PingViewSet(LoginRequiredViewset): def list(self, request): return Response('pong')","title":"Permissioning"},{"location":"guides/plugins/#adding-actions-to-the-sidebar","text":"Actions can be added to the sidebar by setting the actions attribute of your plugin. Actions is expected to be an iterable of strings which are templates to be included in the sidebar. By convention, actions will live in ./templates/actions/ . # __init__.py: class Plugin(OpalPlugin): actions = ('actions/javascript_alert.html', 'actions/dummy_button.html') And then in the template: p ng-show=\"episode.category == 'YourEpisodeCategory'\" button class=\"btn btn-primary\" ng-click=\"alert('Boom!')\" i href=\"fa fa-warning\" /i ALERT ME /button /p","title":"Adding Actions to the sidebar"},{"location":"guides/plugins/#adding-dependencies-globally-to-our-angular-modules","text":"Dependencies listed in angular_module_deps will be added to all Angular modules (as long as they use the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we won't for now.","title":"Adding dependencies globally to our angular modules"},{"location":"guides/plugins/#installing-plugins","text":"Add to installed apps Add to requirements if appropriate","title":"Installing plugins"},{"location":"guides/plugins/#adding-extra-markup-to-the-tag","text":"Any templates you define in the property .head_extra will be included in the","title":"Adding extra markup to the  tag"},{"location":"guides/plugins_list/","text":"Opal Plugins list The Opal ecosystem has a rich array of re-usable Open Source plugins that can be used as composable units of functionality to build your application. This page lists some of the best available: opal.core.search The Search plugin bundled with Opal core provides a default database based search implementation for your application, and is scheduled to provide hooks for e.g. using Elastic Search as your serach backend. opal.core.collaborative The Collaborative plugin bundled with Opal core provides a mechanism for providing realtime collaborative editing of patient data within lists, by providing a streaming websocket link of updates from other open sessions. (Requires Glossolalia ). opal-opat The OPAT plugin provides a set of teams, flows and record types for running a BSAC OPAT clinic. opal-research The Research plugin allows an Opal application to be used as the data collection method for multiple concurrent research studies, including researcher blinding, a structured role permission framework. opal-walk-in The Walk In plugin supports the operation of drop in services within your institution, including registration, triage, escalation discharge summaries. opal-wardround The Wardround plugin provides structured virtual ward rounds - sequential subsets of patients matching arbitrary criteria that the user may step through in order. opal-dischargesummary The Discharge Summary plugin allows the user to generate templated letters from the data concerning an episode already held in the Application. opal-referral The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. opal-dashboard The Dashboard plugin allows for realtime clinical dashboards featuring arbitrary metrics, displayed within your application. opal-observations The Observations plugin caters for the recording and display of electronic observations data. opal-analytics The Analytics plugin allows you to integrate your application with Google or Piwik Analytics with a minimum of fuss. opal-guidelines The Guidelines plugin presents contextual links to clinical guidelines in use at your institution when viewing records of patients whose condition matches those guidelines. Can be used with national or local guidelines. opal-iframe-api The Iframe Api plugin allows you to set up an api key. With this Api key you can create templates to view subrecords for embedding in for example iframes.","title":"Plugin List"},{"location":"guides/plugins_list/#opal-plugins-list","text":"The Opal ecosystem has a rich array of re-usable Open Source plugins that can be used as composable units of functionality to build your application. This page lists some of the best available:","title":"Opal Plugins list"},{"location":"guides/plugins_list/#opalcoresearch","text":"The Search plugin bundled with Opal core provides a default database based search implementation for your application, and is scheduled to provide hooks for e.g. using Elastic Search as your serach backend.","title":"opal.core.search"},{"location":"guides/plugins_list/#opalcorecollaborative","text":"The Collaborative plugin bundled with Opal core provides a mechanism for providing realtime collaborative editing of patient data within lists, by providing a streaming websocket link of updates from other open sessions. (Requires Glossolalia ).","title":"opal.core.collaborative"},{"location":"guides/plugins_list/#opal-opat","text":"The OPAT plugin provides a set of teams, flows and record types for running a BSAC OPAT clinic.","title":"opal-opat"},{"location":"guides/plugins_list/#opal-research","text":"The Research plugin allows an Opal application to be used as the data collection method for multiple concurrent research studies, including researcher blinding, a structured role permission framework.","title":"opal-research"},{"location":"guides/plugins_list/#opal-walk-in","text":"The Walk In plugin supports the operation of drop in services within your institution, including registration, triage, escalation discharge summaries.","title":"opal-walk-in"},{"location":"guides/plugins_list/#opal-wardround","text":"The Wardround plugin provides structured virtual ward rounds - sequential subsets of patients matching arbitrary criteria that the user may step through in order.","title":"opal-wardround"},{"location":"guides/plugins_list/#opal-dischargesummary","text":"The Discharge Summary plugin allows the user to generate templated letters from the data concerning an episode already held in the Application.","title":"opal-dischargesummary"},{"location":"guides/plugins_list/#opal-referral","text":"The Referral plugin provides the plumbing for building complex inter-team referrals within an institution.","title":"opal-referral"},{"location":"guides/plugins_list/#opal-dashboard","text":"The Dashboard plugin allows for realtime clinical dashboards featuring arbitrary metrics, displayed within your application.","title":"opal-dashboard"},{"location":"guides/plugins_list/#opal-observations","text":"The Observations plugin caters for the recording and display of electronic observations data.","title":"opal-observations"},{"location":"guides/plugins_list/#opal-analytics","text":"The Analytics plugin allows you to integrate your application with Google or Piwik Analytics with a minimum of fuss.","title":"opal-analytics"},{"location":"guides/plugins_list/#opal-guidelines","text":"The Guidelines plugin presents contextual links to clinical guidelines in use at your institution when viewing records of patients whose condition matches those guidelines. Can be used with national or local guidelines.","title":"opal-guidelines"},{"location":"guides/plugins_list/#opal-iframe-api","text":"The Iframe Api plugin allows you to set up an api key. With this Api key you can create templates to view subrecords for embedding in for example iframes.","title":"opal-iframe-api"},{"location":"guides/referencedata/","text":"Reference data Lookup Lists allow us to create or reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. Adding a lookup list Lookup lists are subclasses of opal.core.lookuplists.LookupList . Typically, a specific named lookup list will not need to do anything other than define a class that inherits from the base class. The custom field type opal.core.fields.ForeignKeyOrFreeText allows you to build interfaces that cater for synonyms, and also allow the user to enter a free text string that is not in the lookup list. # yourapp.models from django.db import models from opal.core import lookuplists from opal.core.fields import ForeignKeyOrFreeText from opal.models import EpisodeSubrecord class TreatmentType(lookuplists.LookupList): pass class Treatment(EpisodeSubrecord): treatment = ForeignKeyOrFreeText(TreatmentType) notes = models.CharField(max_length=200) When you create your lookup list, you are creating a new model, so you will need a new migration to accompany it. $ python manage.py schemamigration --atuo yourapp $ python manage.py migrate yourapp The lookup list will automatically be added to the admin, where you can manually add entries. Reference data JSON API Reference data is available over the Opal JSON API. You may either load all lookuplists at once via the /api/v0.1/referencedata/ endpoint, or individual lookuplists by name - for example all diagnoses from /api/v0.1/referencedata/diagnosis/ . The reference data API also loads all synonyms in a flat list - the conversion of synonyms to their canonical form is handled by the save mechanism of subrecords using ForeignKeyOrFreeText fields. Working with reference data on the front end The Angular service Referencedata can be used to fetch all lookuplists at once - for instance loaded in the Angular routing for a controller in your application when('/my/route', { controller: 'MyCtrl', resolve: { referencedata: function(Referencedata){ return Referencedata; } } } Lookuplists will then be available either as properties of the referencedata object. Using referencedata in forms The Opal form templatetag library allow us to easily incorporate referencedata into the forms we build, eiether by detecting their use automatically when we have ForeignKeyOrFreeText fields, or explicitly by passing an argument. {% load forms %} {% input field= Diagnosis.condition %} {% select label= List of Conditions lookuplist= referencedata.diagnosis %} Providing data for lookuplists Reference data can be provided at application or plugin level in a file named lookuplists.json found in the {{ app_or_plugin }}/data/lookuplists directory. This data should be in the Opal JSON format. The name value of each lookuplist should be the return value of that lookuplist's get_api_name() method. { name_of_lookuplist : [ { name : Value of lookuplist item , synonyms : [ Synonym 1 ,] }, ] } Once this data is stored in the lookuplists file, we can batch load it into our application with the command python manage.py load_lookup_lists Management commands Opal ships with some managemnent commands for importing and exporting lookup lists dump_lookup_lists Prints all loockuplists as JSON to stdout. load_lookup_lists Loads lookup lists from all plugins/apps in the Opal JSON format. The lookup lists are expected to be in {{ app }}/data/lookuplists/lookuplists.json delete_all_lookuplists Deletes all currently lookuplist values and related synonyms","title":"Referencedata"},{"location":"guides/referencedata/#reference-data","text":"Lookup Lists allow us to create or reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override.","title":"Reference data"},{"location":"guides/referencedata/#adding-a-lookup-list","text":"Lookup lists are subclasses of opal.core.lookuplists.LookupList . Typically, a specific named lookup list will not need to do anything other than define a class that inherits from the base class. The custom field type opal.core.fields.ForeignKeyOrFreeText allows you to build interfaces that cater for synonyms, and also allow the user to enter a free text string that is not in the lookup list. # yourapp.models from django.db import models from opal.core import lookuplists from opal.core.fields import ForeignKeyOrFreeText from opal.models import EpisodeSubrecord class TreatmentType(lookuplists.LookupList): pass class Treatment(EpisodeSubrecord): treatment = ForeignKeyOrFreeText(TreatmentType) notes = models.CharField(max_length=200) When you create your lookup list, you are creating a new model, so you will need a new migration to accompany it. $ python manage.py schemamigration --atuo yourapp $ python manage.py migrate yourapp The lookup list will automatically be added to the admin, where you can manually add entries.","title":"Adding a lookup list"},{"location":"guides/referencedata/#reference-data-json-api","text":"Reference data is available over the Opal JSON API. You may either load all lookuplists at once via the /api/v0.1/referencedata/ endpoint, or individual lookuplists by name - for example all diagnoses from /api/v0.1/referencedata/diagnosis/ . The reference data API also loads all synonyms in a flat list - the conversion of synonyms to their canonical form is handled by the save mechanism of subrecords using ForeignKeyOrFreeText fields.","title":"Reference data JSON API"},{"location":"guides/referencedata/#working-with-reference-data-on-the-front-end","text":"The Angular service Referencedata can be used to fetch all lookuplists at once - for instance loaded in the Angular routing for a controller in your application when('/my/route', { controller: 'MyCtrl', resolve: { referencedata: function(Referencedata){ return Referencedata; } } } Lookuplists will then be available either as properties of the referencedata object.","title":"Working with reference data on the front end"},{"location":"guides/referencedata/#using-referencedata-in-forms","text":"The Opal form templatetag library allow us to easily incorporate referencedata into the forms we build, eiether by detecting their use automatically when we have ForeignKeyOrFreeText fields, or explicitly by passing an argument. {% load forms %} {% input field= Diagnosis.condition %} {% select label= List of Conditions lookuplist= referencedata.diagnosis %}","title":"Using referencedata in forms"},{"location":"guides/referencedata/#providing-data-for-lookuplists","text":"Reference data can be provided at application or plugin level in a file named lookuplists.json found in the {{ app_or_plugin }}/data/lookuplists directory. This data should be in the Opal JSON format. The name value of each lookuplist should be the return value of that lookuplist's get_api_name() method. { name_of_lookuplist : [ { name : Value of lookuplist item , synonyms : [ Synonym 1 ,] }, ] } Once this data is stored in the lookuplists file, we can batch load it into our application with the command python manage.py load_lookup_lists","title":"Providing data for lookuplists"},{"location":"guides/referencedata/#management-commands","text":"Opal ships with some managemnent commands for importing and exporting lookup lists","title":"Management commands"},{"location":"guides/referencedata/#dump_lookup_lists","text":"Prints all loockuplists as JSON to stdout.","title":"dump_lookup_lists"},{"location":"guides/referencedata/#load_lookup_lists","text":"Loads lookup lists from all plugins/apps in the Opal JSON format. The lookup lists are expected to be in {{ app }}/data/lookuplists/lookuplists.json","title":"load_lookup_lists"},{"location":"guides/referencedata/#delete_all_lookuplists","text":"Deletes all currently lookuplist values and related synonyms","title":"delete_all_lookuplists"},{"location":"guides/roles_and_permissions/","text":"Roles Permissions in Opal Opal provides some global per-user flags, which are set in the UserProfile model, as well as more detailed permissions available via roles. The UserProfile model Some global properties about Users are set in the opal.models.UserProfile model. UserProflie._can_extract Boolean flag to determine whether this user is allowed to download data extracts from the system UserProflie._force_password_change Boolean flag to determine whether we would like to force this user to change their password on their next login. This defaults to True when the User is first created. UserProfile._readonly Boolean flag to determine whether this user has readonly access. UserProfile._restricted_only Boolean flag to determine whether this user should be only shown teams for which they have explicitly been given permission to view or whether they should also see the list of general access teams. UserProfile.get_roles() Return a dictionary of roles in various contexts for our user profile.get_roles() # - { 'default': ['doctor'], 'some_research_study': ['Clinical Lead'] } UserProfile.get_teams() Return a list of Team objects that this user should be allowed to see. Roles A user may be given a particular role. These can be either global - in which case they are returned in the 'default' section of the roles dict from get_roles() , or specific to a team.","title":"Roles & Permissions"},{"location":"guides/roles_and_permissions/#roles-permissions-in-opal","text":"Opal provides some global per-user flags, which are set in the UserProfile model, as well as more detailed permissions available via roles.","title":"Roles &amp; Permissions in Opal"},{"location":"guides/roles_and_permissions/#the-userprofile-model","text":"Some global properties about Users are set in the opal.models.UserProfile model.","title":"The UserProfile model"},{"location":"guides/roles_and_permissions/#userproflie_can_extract","text":"Boolean flag to determine whether this user is allowed to download data extracts from the system","title":"UserProflie._can_extract"},{"location":"guides/roles_and_permissions/#userproflie_force_password_change","text":"Boolean flag to determine whether we would like to force this user to change their password on their next login. This defaults to True when the User is first created.","title":"UserProflie._force_password_change"},{"location":"guides/roles_and_permissions/#userprofile_readonly","text":"Boolean flag to determine whether this user has readonly access.","title":"UserProfile._readonly"},{"location":"guides/roles_and_permissions/#userprofile_restricted_only","text":"Boolean flag to determine whether this user should be only shown teams for which they have explicitly been given permission to view or whether they should also see the list of general access teams.","title":"UserProfile._restricted_only"},{"location":"guides/roles_and_permissions/#userprofileget_roles","text":"Return a dictionary of roles in various contexts for our user profile.get_roles() # - { 'default': ['doctor'], 'some_research_study': ['Clinical Lead'] }","title":"UserProfile.get_roles()"},{"location":"guides/roles_and_permissions/#userprofileget_teams","text":"Return a list of Team objects that this user should be allowed to see.","title":"UserProfile.get_teams()"},{"location":"guides/roles_and_permissions/#roles","text":"A user may be given a particular role. These can be either global - in which case they are returned in the 'default' section of the roles dict from get_roles() , or specific to a team.","title":"Roles"},{"location":"guides/search/","text":"Opal Search overview The Opal Search backend is switchable using the settings value Opal_SEARCH_BACKEND. By default it will do a database query. The backend takes in a dictionary with the following fields { \"queryType\": either \"Equals\" or \"Contains\", \"field\": the label of the column that will be queried, e.g. Hospital Number, \"query\": the value to be queried, e.g. \"1111\", 'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries 'column': the model to be queried e.g. 'demographics' }","title":"Search Overview"},{"location":"guides/search/#opal-search-overview","text":"The Opal Search backend is switchable using the settings value Opal_SEARCH_BACKEND. By default it will do a database query. The backend takes in a dictionary with the following fields { \"queryType\": either \"Equals\" or \"Contains\", \"field\": the label of the column that will be queried, e.g. Hospital Number, \"query\": the value to be queried, e.g. \"1111\", 'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries 'column': the model to be queried e.g. 'demographics' }","title":"Opal Search overview"},{"location":"guides/static_files/","text":"Static Files in Opal As with any Javascript heavy application, Opal apps can quickly accumulate large numbers of static files. Opal ships with the Django Compressor library out of the box, and uses it to manage the Javascript asset pipeline. Do consult the excellent Django Compresor documentation for more details on exactly how this process works.","title":"Static Files"},{"location":"guides/static_files/#static-files-in-opal","text":"As with any Javascript heavy application, Opal apps can quickly accumulate large numbers of static files. Opal ships with the Django Compressor library out of the box, and uses it to manage the Javascript asset pipeline. Do consult the excellent Django Compresor documentation for more details on exactly how this process works.","title":"Static Files in Opal"},{"location":"guides/tagging/","text":"Tagging Episodes in Opal may be tagged. This is commonly used as a mechanism to record that a particular team is looking after a patient - via TaggedPatientList , but also to group patients. For instance, we might like to 'tag' episodes with a particular string when some particular event occurrs so that we can run reports or analyse these groups later. The \"Teams\" modal in list and detail views, is actually an interface over updating the tagging of the episode in question. Metadata concerning tags can be found via the Options API.","title":"Tagging"},{"location":"guides/tagging/#tagging","text":"Episodes in Opal may be tagged. This is commonly used as a mechanism to record that a particular team is looking after a patient - via TaggedPatientList , but also to group patients. For instance, we might like to 'tag' episodes with a particular string when some particular event occurrs so that we can run reports or analyse these groups later. The \"Teams\" modal in list and detail views, is actually an interface over updating the tagging of the episode in question. Metadata concerning tags can be found via the Options API.","title":"Tagging"},{"location":"guides/templates/","text":"Templates in Opal Opal uses a mixture of Django and Angular templates. Angular templates In order to be compatible with Django templating, we use the [[ ... ]] notation for Angular interpolation, which allows us to mix Django template interpolation in templates designed to be rendered by Angular on the client side. !-- app_details_snippet.html -- {{ OPAL_BRAND_NAME }} [[ Opal_VERSION ]] Generic Template URL On many occasions we simply want to fetch a template from the server in our Angular code without any further processing. Opal provides a default catchall HTML template url which will render .html files direct from disk. # opal.urls url(r'templates/(?P template_name [a-z_/]+.html)', views.RawTemplateView.as_view()) So if our template is at ./myapp/templates/foo/bar.html , then the url /templates/foo/bar.html will return it.","title":"Templates"},{"location":"guides/templates/#templates-in-opal","text":"Opal uses a mixture of Django and Angular templates.","title":"Templates in Opal"},{"location":"guides/templates/#angular-templates","text":"In order to be compatible with Django templating, we use the [[ ... ]] notation for Angular interpolation, which allows us to mix Django template interpolation in templates designed to be rendered by Angular on the client side. !-- app_details_snippet.html -- {{ OPAL_BRAND_NAME }} [[ Opal_VERSION ]]","title":"Angular templates"},{"location":"guides/templates/#generic-template-url","text":"On many occasions we simply want to fetch a template from the server in our Angular code without any further processing. Opal provides a default catchall HTML template url which will render .html files direct from disk. # opal.urls url(r'templates/(?P template_name [a-z_/]+.html)', views.RawTemplateView.as_view()) So if our template is at ./myapp/templates/foo/bar.html , then the url /templates/foo/bar.html will return it.","title":"Generic Template URL"},{"location":"guides/topic-guides/","text":"Opal Guides A list of all available topic guides. Opal Opal - Applications, Plugins How Opal components hang together Command line tool running admin tasks from the command line Discoverable design patterns and library for creating easily reusable features Plugins Available interfaces for Opal plugins List of Plugins A list of available high quality plugins Data and Business Logic Data Model How Opal models clinical reality Core Clinical Model The core clinical data model available to Opal applications Reference data Canonical coded terms and reference data App metadata Working with Metadata on the front end Flow Hooks to customise key moments in a patient's flow through a clinical service Angular models Working with Clinical data in Angular Roles Permissions How we handle authorization in Opal Tagging Tagging episodes in Opal JSON API The Opal JSON API Presentation and templating Templates Server and client side templating Default Context Processors Opal Django context processors Static Files How Opal handles static files Forms Forms for entering or editing data Patient Detail Views Detailed views of a Patient Patient List Views Lists of patients Optional Components Search Default search implementation Working on Opal itself Contributing Contributing to Opal Development environment Setting up the Opal development environment","title":"Guides"},{"location":"guides/topic-guides/#opal-guides","text":"A list of all available topic guides.","title":"Opal Guides"},{"location":"guides/topic-guides/#opal","text":"Opal - Applications, Plugins How Opal components hang together Command line tool running admin tasks from the command line Discoverable design patterns and library for creating easily reusable features Plugins Available interfaces for Opal plugins List of Plugins A list of available high quality plugins","title":"Opal"},{"location":"guides/topic-guides/#data-and-business-logic","text":"Data Model How Opal models clinical reality Core Clinical Model The core clinical data model available to Opal applications Reference data Canonical coded terms and reference data App metadata Working with Metadata on the front end Flow Hooks to customise key moments in a patient's flow through a clinical service Angular models Working with Clinical data in Angular Roles Permissions How we handle authorization in Opal Tagging Tagging episodes in Opal JSON API The Opal JSON API","title":"Data and Business Logic"},{"location":"guides/topic-guides/#presentation-and-templating","text":"Templates Server and client side templating Default Context Processors Opal Django context processors Static Files How Opal handles static files Forms Forms for entering or editing data Patient Detail Views Detailed views of a Patient Patient List Views Lists of patients","title":"Presentation and templating"},{"location":"guides/topic-guides/#optional-components","text":"Search Default search implementation","title":"Optional Components"},{"location":"guides/topic-guides/#working-on-opal-itself","text":"Contributing Contributing to Opal Development environment Setting up the Opal development environment","title":"Working on Opal itself"},{"location":"guides/working_with_data_in_angular/","text":"Working with Clinical Data in Angular Opal provides a range of Angular services for working with clinical data on the front end. The Episode Service The Episode Service will return an Episode object that represents an individual episode of care, and provides various methods for interacting with both episodes and subrecords. var episode = new Episode(my_episode_data); var editing = episode.makeCopy(); editing.start_date = new Date(); episode.save(editing); The Item Service The Item Service returns Item objects that represent individual instances of subrecords. They must be initialised with an episode and a schema representing the available data fields for this subrecord type. var diagnosis = new Item({}, episode, $rootScope.fields.diagnosis); var editing = diagnosis.makeCopy(); editing.date_of_diagnosis = new Date(); diagnosis.save(editing); Subrecord CRUD modals The Episode service has a convenient API that allows you to open a modal to edit a new or existing subrecord. epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis Customising Subrecords Sometimes our application will wish to customise a subrecord of a particular type - for instance to set default values. We do this by setting a custom record service. First, we set the name of the service to use as a constructor for this record type as a property on the model. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' Next we must include the file with our new service in our application. # yourapp/__init__.py class YourApp(application.OpalApplication): javascripts = [..., 'js/diagnosis.js', ...] Finally we define an Angular service which expects to be passed the record in order to set defaults. // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()} return record; } });","title":"Angular Models"},{"location":"guides/working_with_data_in_angular/#working-with-clinical-data-in-angular","text":"Opal provides a range of Angular services for working with clinical data on the front end.","title":"Working with Clinical Data in Angular"},{"location":"guides/working_with_data_in_angular/#the-episode-service","text":"The Episode Service will return an Episode object that represents an individual episode of care, and provides various methods for interacting with both episodes and subrecords. var episode = new Episode(my_episode_data); var editing = episode.makeCopy(); editing.start_date = new Date(); episode.save(editing);","title":"The Episode Service"},{"location":"guides/working_with_data_in_angular/#the-item-service","text":"The Item Service returns Item objects that represent individual instances of subrecords. They must be initialised with an episode and a schema representing the available data fields for this subrecord type. var diagnosis = new Item({}, episode, $rootScope.fields.diagnosis); var editing = diagnosis.makeCopy(); editing.date_of_diagnosis = new Date(); diagnosis.save(editing);","title":"The Item Service"},{"location":"guides/working_with_data_in_angular/#subrecord-crud-modals","text":"The Episode service has a convenient API that allows you to open a modal to edit a new or existing subrecord. epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis","title":"Subrecord CRUD modals"},{"location":"guides/working_with_data_in_angular/#customising-subrecords","text":"Sometimes our application will wish to customise a subrecord of a particular type - for instance to set default values. We do this by setting a custom record service. First, we set the name of the service to use as a constructor for this record type as a property on the model. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' Next we must include the file with our new service in our application. # yourapp/__init__.py class YourApp(application.OpalApplication): javascripts = [..., 'js/diagnosis.js', ...] Finally we define an Angular service which expects to be passed the record in order to set defaults. // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()} return record; } });","title":"Customising Subrecords"},{"location":"reference/CHANGELOG/","text":"0.8.0 (Major Release) Plugins Plugins have been refactored and are now DiscoverableFeatures . This should have no impact on existing plugins, however the functions opal.core.plugins.register and opal.core.plugins.plugins are slated for removal in 0.9.0 When creating new plugins we will place the plugin definition class in plugin.py rather than __init__.py opal.core.api.patient_from_pk A decorator that changes a method that is passed a pk, to a method that is passed a patient. ToDictMixin._bulk_serialise Adds a flag to the to dict mixin to determine whether the item is serialised as part of Episode/Patient.to_dict . Fixes bugs in add many subrecord radio buttons Previously multiple radio buttons for the same subrecord field on the same page would not appear to the user to update correctly. This has now been fixed. Angular UI Libraries 0.8.0 consolidates Angular UI libraries bundled with Opal. We have removed Angular Strap, and switched all components using it to their Angular UI Bootstrap equivalents. This is a breaking change. Applications taking advantage of the Forms templatetag library should require no updates, but will see some minor differences in visual style of widgets. Detailed upgrade guides for the components affected (Typeahead, Popover, Tooltip, Datepicker, Timepicker) are available in the upgrade reference documentation. Defaults for Client Side subrecords We pull through default values from subrecord fields into the Opal Schema and use those values when initializing the relevant Item instance for a new subrecord. This should greatly reduce the need to use custom Angular subrecord services to set defaults. Choices in form templatetags Template tags that use the 'field' attribute to point to a subrecord field will now infer a lookup list from the Choices of the field if it exists. Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively. element name in template tags The html attribute 'name' for form elements generated with the Opal {% forms %} templatetag library used to be inferred from the model name. Although this remains the default you can also set it with an angular expression: {% select field= Demographics.first_name element_name= ...Your Angular expression... %} Model removals The models Team , GP , CommunityNurse and LocatedModel - marked for removal since 0.6.0 have now been removed. As part of this change, the add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash. Python 3 Opal 0.8.0 is the first version of Opal to support Python 3. This has meant changing the default ordering of PatientList instances to 0 rather than None. Moving forwards we expect all new code in Opal to be compatible both Python 2.7 / 3.4 / 3.5 / 3.6. This introduces an explicit Opal dependency on the Six module for maintaining codebases that span Python 2.x and 3.x. Tabbed Patient List Groups Adds the class opal.core.patient_lists.TabbedPatientListGroup which displays groups of related lists as tabs at the top of each member list. PatientList sort order To enable custom sort orders for individual PatientList s we introduce the comparator_service attribute. This names an Angular service which will return a list of comparator functions. PatientList Arbitrary columns We now explicitly enable columns in spreadhseet lists that are not tied to subrecords. These can be included in PatientList schema instances as explicit Column() entries. Template re-naming Modal_base has now been moved into a folder called base_templates. Its also now got a form_modal_base and a two_column_form_modal_base. The latter two templates add validation around saving. The standard edit item models and others now inherit from the form_modal_base. Authorization and permissions All APIs should be permissioned with Django REST framework permission classes. The default implementation uses opal.core.api.LoginRequiredViewset, a standard DRF viewset that requires the user to be logged in. We now require the user to be logged in for any use of the search functionality. Added a custom interceptor that logs the user out if the we receive a 403 or 401 from the server Form Validation Adds the checkForm directive e.g. button check-form= form ng-click= sendDataToTheServer click me /button This adds default form submission behaviour to the a button. It will check if the form is valid, and if its not it will mark the button as disabled until it becomes valid. It will also set the form as submitted. We also now show the required error if the form has been submitted or if the field is dirty, so that the user doesn't get an ugly \"fill this field in now\" message when opening the modal/pathway but will get the error after they click submit. Removals Opal 0.8.0 removes a number of un-used features that have been slated for removal for some time: Options - both from the JSON API, and the Angular service. The legacy APIs /api/v0.1/episode/admit and /api/v0.1/episode/refer . The models GP , CommunityNurse and LocatedModel . opal.models.Tagging.import_from_reversion . This one-off classmethod on tagging was introduced to aid with the upgrade from Opal 4.x to 5.0 and has no further utility. The static argument from the forms input tag. Developers should move to the static tag. The _modal option to set on subrecords. This is because we now use large modals across the board. Misc changes The opal.core.api.EpisodeViewSet.create now expects tagging to be an object rather than a list, similar to how it details with demographics and location. The API will no longer serialise the _ft or _fk_id fields of FreeTextOrForeignKey fields - these are internal implementation details of the server that are not useful on the client side. Adds a Unique Together constraint for (Tagging.user, Tagging.episode, Tagging.value) Look up lists now load in from individual apps. The look for a file at {{ app }}/data/lookuplists.json The default admin url is now /admin/ - rather than /admin/? this results in more readable admin urls and is closer to what most applications do with the Django admin. The roles field opal.models.UserProfile.roles has been updated to be blank=True . This allows the editing of users without specific roles assigned in the Django admin. Although this introduces no changes at the database level, this does introduce a migration. Updates to the Dependency Graph Upgrades angular to v1.5.8 (from 1.3.11) you can see their change log here Updates angular-cookies and angular-mocks to v1.5.8 (both from 1.3.11) Updates angular-ui-select to 0.19.4 from 0.13.2 0.7.2 (Minor Release) Fixes a bug with the copy to category API not setting category name. Removes the hangover use of options in the list of teams per episode in the patient list 0.7.1 (Minor Release) Completes the refactor of front end data, no longer using the /api/v0.1/options/ API internally. This is slated for removal in 0.8.0. Updates DRF APIs - we now expect either Token or DjangoSession auth. Fixes several small bugs with scaffolded applications - the setting of STATIC_ROOT and SECRET_KEY , generating forms for NullBooleanFields, requirements.txt. Adds an aligned_pair templatetag to the panels library. Updates the label for Demographics.birth_place to indicate that this should be a country. Adds the clipboard directive to give the user one click copy to clipboard. Adds a tag-select directive that renders a widget for editing the tags for an episode. Adds metadata to the scope for patient detail views Updates to the Dependency Graph Django Axes 1.4.0 - 1.7.0 0.7.0 (Major Release) Episode Categories Refactors EpisodeCategory to be a discoverable feature. Renames Episode.category - Episode.category_name . Episode JSON API The Restful Episode JSON API previously available at /episode/:pk/ is now moved into /api/v0.1/episode/:pk/ for consistency with the rest of our JSON APIs. The Opal Angular layer has been updated to reflect this, and should handle the transition seamlessly, but code calling the API directly should update to reflect the new URL. Defaults for records on the client side Establishes a new way to define defaults for records initialized in Javascript without requiring that we hard-code API names to defaults in a global namespace. Update to Javascript Signatures Flow.enter() and Flow.exit() now no longer take options positional arguments - instead the controllers they initialize have Metadata and Referencedata as optional resolves arguments. AddEpisodeCtrl now no longer requires options as a resolves() option, but requires Referencedata instead. MaxLength for form helpers The input form helper will now infer the max length of char fields from the max length of the database field, and render relevant Angular directives. EpisodeDetail removed The EpisodeDetailCtrl and EpisodeDetailMixin controller and service have been removed - these were not used anywhere other than in the Wardround plugin, and redundant after enhancements to Patient Detail and Custom DetailViews in 0.6. Additional utilities Adds a datetimepicker templatetag that will render widgets for a Datetime field including time. Adds a date_of_birth_field templatetag that renders a date of birth field complete with inteligent validation. (Note this change also includes removing the old _partial/ template) Updates dependency graph: Django - 1.8.13 0.6.0 (Major Release) Detail views Moves from episode oriented detail to patient oriented detail. (All episodes plus x-episode views are available from a patient detail screen) Tagging As a performance optimisation for the frequent access of historic tags, untagging an episode simply renders the tag inactive rather than deleting it and relying on Django-Reversion for access to historical data. Date Formatting We now expect 'd/m/y' date formatting by default. Patient lists Lists are now declarative, and separate from teams. They are implemented as subclasses of opal.core.patient_lists.PatientList. Forms vs. Modals Introduces a distinction between a form and a modal. By default, we now use forms for subrecords, only overriding the modal if there is something we want to do differently specifically in the modal. Command line tools Adds $opal checkout for switching between applications or application versions. Models ContextProcessor The 'opal.context_processors.models' Context Processor will allow you to access your subrecords from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include models.Demographics.get_detail_template %} Upgrade instructions: Full upgrade instructions to work through any backwards incompatible changes are provided in the Opal docs. 0.5.5 (Minor Release) Changes the way old tags are handled. Tags are no longer deleted episodes, rather they're marked as archived. 0.5.4 (Minor Release) Include local storage 0.5.3 (Minor Release) Speed up loading of the lookup lists Fix pagination issues in search Speed up loading of many to many fields Increase test coverage Add some extra help fields to {% forms %} helpers Fixes bug with $rootScope.open_modal() where keystrokes were being intercepted 0.5.2 (Minor Release) Speed improvements on page load allow us to only show record panels if a record of that type exists disable modal buttons while saving 0.5.1 (Minor Release) Minor bug fixes 0.5 (Major release) Search Complete re-design of Search interface to provide a single search box on every page and pagination for resulta. Puts in place a pluggable interface that could be swapped out for e.g. ElasticSearch. New Service for PatientSummary() Analytics Moves Analytics integration into Opal core with the ability to blacklist pages that should never be reported List view Removed old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row. Updated scrolling and loading behaviour to snap to viewport and not display the page build. Subrecord metadata Added four new utility fields to Patient and Episode subrecords: created_by, updated_by, created, updated Select2 and list fields Added support for select2 as an input widget and Subrecord fields that can be lists of things. Also Numerous small bugfixes. Refactoring of the models package into a models module. Updated Underscore.js - 1.8.3 Updated Angular.js - 1.3.11 0.4.3 (Minor release) Refactors opal.models to be a models.py file rather than a package. Adds several improvements to forms helpers - Help argument, other argument to select. Updates dependency graph: Angular-strap - 2.3.1 0.4.2 (Minor release) Upgrades dependency graph: Django - 1.8.3 Django-reversion - 1.8.7 jQuery - 1.11.3 D3 - 3.5.6 C4 - 0.4.10 South has been removed, now using django migrations 0.4.1 (Bugfix release) Fixes some search results appearing duplicated. 0.4 (Major release) New Design Completely re-designed UI following extensive user research and multiple iterations. Managementcommands and scaffolding Features the opal command line tool for common administrative tasks http://opal.openhealthcare.org.uk/docs/guides/command_line_tool/ Form helpers templatetag library New template library for consistent form controls in line with our new interface guidelines http://opal.openhealthcare.org.uk/docs/reference/form_templatetags/ API Documentation Opal JSON APIs are now fully self-documenting for all updated instances http://opal.openhealthcare.org.uk/docs/guides/json_api/ 0.3 (Major release) Bugfixes, significant flexibility in template customisability. Minor UI updates. 0.2.2 (Bugfix release) Numerous small bugfixes. Adds the concept of undischarging patients. 0.2.1 Numerous small bugfixes. 0.2.0 Search overhaul - introduces advanced searches. 0.1.1 Initial public release","title":"CHANGELOG"},{"location":"reference/CHANGELOG/#080-major-release","text":"","title":"0.8.0 (Major Release)"},{"location":"reference/CHANGELOG/#plugins","text":"Plugins have been refactored and are now DiscoverableFeatures . This should have no impact on existing plugins, however the functions opal.core.plugins.register and opal.core.plugins.plugins are slated for removal in 0.9.0 When creating new plugins we will place the plugin definition class in plugin.py rather than __init__.py","title":"Plugins"},{"location":"reference/CHANGELOG/#opalcoreapipatient_from_pk","text":"A decorator that changes a method that is passed a pk, to a method that is passed a patient.","title":"opal.core.api.patient_from_pk"},{"location":"reference/CHANGELOG/#todictmixin_bulk_serialise","text":"Adds a flag to the to dict mixin to determine whether the item is serialised as part of Episode/Patient.to_dict .","title":"ToDictMixin._bulk_serialise"},{"location":"reference/CHANGELOG/#fixes-bugs-in-add-many-subrecord-radio-buttons","text":"Previously multiple radio buttons for the same subrecord field on the same page would not appear to the user to update correctly. This has now been fixed.","title":"Fixes bugs in add many subrecord radio buttons"},{"location":"reference/CHANGELOG/#angular-ui-libraries","text":"0.8.0 consolidates Angular UI libraries bundled with Opal. We have removed Angular Strap, and switched all components using it to their Angular UI Bootstrap equivalents. This is a breaking change. Applications taking advantage of the Forms templatetag library should require no updates, but will see some minor differences in visual style of widgets. Detailed upgrade guides for the components affected (Typeahead, Popover, Tooltip, Datepicker, Timepicker) are available in the upgrade reference documentation.","title":"Angular UI Libraries"},{"location":"reference/CHANGELOG/#defaults-for-client-side-subrecords","text":"We pull through default values from subrecord fields into the Opal Schema and use those values when initializing the relevant Item instance for a new subrecord. This should greatly reduce the need to use custom Angular subrecord services to set defaults.","title":"Defaults for Client Side subrecords"},{"location":"reference/CHANGELOG/#choices-in-form-templatetags","text":"Template tags that use the 'field' attribute to point to a subrecord field will now infer a lookup list from the Choices of the field if it exists. Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively.","title":"Choices in form templatetags"},{"location":"reference/CHANGELOG/#element-name-in-template-tags","text":"The html attribute 'name' for form elements generated with the Opal {% forms %} templatetag library used to be inferred from the model name. Although this remains the default you can also set it with an angular expression: {% select field= Demographics.first_name element_name= ...Your Angular expression... %}","title":"element name in template tags"},{"location":"reference/CHANGELOG/#model-removals","text":"The models Team , GP , CommunityNurse and LocatedModel - marked for removal since 0.6.0 have now been removed. As part of this change, the add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash.","title":"Model removals"},{"location":"reference/CHANGELOG/#python-3","text":"Opal 0.8.0 is the first version of Opal to support Python 3. This has meant changing the default ordering of PatientList instances to 0 rather than None. Moving forwards we expect all new code in Opal to be compatible both Python 2.7 / 3.4 / 3.5 / 3.6. This introduces an explicit Opal dependency on the Six module for maintaining codebases that span Python 2.x and 3.x.","title":"Python 3"},{"location":"reference/CHANGELOG/#tabbed-patient-list-groups","text":"Adds the class opal.core.patient_lists.TabbedPatientListGroup which displays groups of related lists as tabs at the top of each member list.","title":"Tabbed Patient List Groups"},{"location":"reference/CHANGELOG/#patientlist-sort-order","text":"To enable custom sort orders for individual PatientList s we introduce the comparator_service attribute. This names an Angular service which will return a list of comparator functions.","title":"PatientList sort order"},{"location":"reference/CHANGELOG/#patientlist-arbitrary-columns","text":"We now explicitly enable columns in spreadhseet lists that are not tied to subrecords. These can be included in PatientList schema instances as explicit Column() entries.","title":"PatientList Arbitrary columns"},{"location":"reference/CHANGELOG/#template-re-naming","text":"Modal_base has now been moved into a folder called base_templates. Its also now got a form_modal_base and a two_column_form_modal_base. The latter two templates add validation around saving. The standard edit item models and others now inherit from the form_modal_base.","title":"Template re-naming"},{"location":"reference/CHANGELOG/#authorization-and-permissions","text":"All APIs should be permissioned with Django REST framework permission classes. The default implementation uses opal.core.api.LoginRequiredViewset, a standard DRF viewset that requires the user to be logged in. We now require the user to be logged in for any use of the search functionality. Added a custom interceptor that logs the user out if the we receive a 403 or 401 from the server","title":"Authorization and permissions"},{"location":"reference/CHANGELOG/#form-validation","text":"Adds the checkForm directive e.g. button check-form= form ng-click= sendDataToTheServer click me /button This adds default form submission behaviour to the a button. It will check if the form is valid, and if its not it will mark the button as disabled until it becomes valid. It will also set the form as submitted. We also now show the required error if the form has been submitted or if the field is dirty, so that the user doesn't get an ugly \"fill this field in now\" message when opening the modal/pathway but will get the error after they click submit.","title":"Form Validation"},{"location":"reference/CHANGELOG/#removals","text":"Opal 0.8.0 removes a number of un-used features that have been slated for removal for some time: Options - both from the JSON API, and the Angular service. The legacy APIs /api/v0.1/episode/admit and /api/v0.1/episode/refer . The models GP , CommunityNurse and LocatedModel . opal.models.Tagging.import_from_reversion . This one-off classmethod on tagging was introduced to aid with the upgrade from Opal 4.x to 5.0 and has no further utility. The static argument from the forms input tag. Developers should move to the static tag. The _modal option to set on subrecords. This is because we now use large modals across the board.","title":"Removals"},{"location":"reference/CHANGELOG/#misc-changes","text":"The opal.core.api.EpisodeViewSet.create now expects tagging to be an object rather than a list, similar to how it details with demographics and location. The API will no longer serialise the _ft or _fk_id fields of FreeTextOrForeignKey fields - these are internal implementation details of the server that are not useful on the client side. Adds a Unique Together constraint for (Tagging.user, Tagging.episode, Tagging.value) Look up lists now load in from individual apps. The look for a file at {{ app }}/data/lookuplists.json The default admin url is now /admin/ - rather than /admin/? this results in more readable admin urls and is closer to what most applications do with the Django admin. The roles field opal.models.UserProfile.roles has been updated to be blank=True . This allows the editing of users without specific roles assigned in the Django admin. Although this introduces no changes at the database level, this does introduce a migration.","title":"Misc changes"},{"location":"reference/CHANGELOG/#updates-to-the-dependency-graph","text":"Upgrades angular to v1.5.8 (from 1.3.11) you can see their change log here Updates angular-cookies and angular-mocks to v1.5.8 (both from 1.3.11) Updates angular-ui-select to 0.19.4 from 0.13.2","title":"Updates to the Dependency Graph"},{"location":"reference/CHANGELOG/#072-minor-release","text":"Fixes a bug with the copy to category API not setting category name. Removes the hangover use of options in the list of teams per episode in the patient list","title":"0.7.2 (Minor Release)"},{"location":"reference/CHANGELOG/#071-minor-release","text":"Completes the refactor of front end data, no longer using the /api/v0.1/options/ API internally. This is slated for removal in 0.8.0. Updates DRF APIs - we now expect either Token or DjangoSession auth. Fixes several small bugs with scaffolded applications - the setting of STATIC_ROOT and SECRET_KEY , generating forms for NullBooleanFields, requirements.txt. Adds an aligned_pair templatetag to the panels library. Updates the label for Demographics.birth_place to indicate that this should be a country. Adds the clipboard directive to give the user one click copy to clipboard. Adds a tag-select directive that renders a widget for editing the tags for an episode. Adds metadata to the scope for patient detail views","title":"0.7.1 (Minor Release)"},{"location":"reference/CHANGELOG/#updates-to-the-dependency-graph_1","text":"Django Axes 1.4.0 - 1.7.0","title":"Updates to the Dependency Graph"},{"location":"reference/CHANGELOG/#070-major-release","text":"","title":"0.7.0 (Major Release)"},{"location":"reference/CHANGELOG/#episode-categories","text":"Refactors EpisodeCategory to be a discoverable feature. Renames Episode.category - Episode.category_name .","title":"Episode Categories"},{"location":"reference/CHANGELOG/#episode-json-api","text":"The Restful Episode JSON API previously available at /episode/:pk/ is now moved into /api/v0.1/episode/:pk/ for consistency with the rest of our JSON APIs. The Opal Angular layer has been updated to reflect this, and should handle the transition seamlessly, but code calling the API directly should update to reflect the new URL.","title":"Episode JSON API"},{"location":"reference/CHANGELOG/#defaults-for-records-on-the-client-side","text":"Establishes a new way to define defaults for records initialized in Javascript without requiring that we hard-code API names to defaults in a global namespace.","title":"Defaults for records on the client side"},{"location":"reference/CHANGELOG/#update-to-javascript-signatures","text":"Flow.enter() and Flow.exit() now no longer take options positional arguments - instead the controllers they initialize have Metadata and Referencedata as optional resolves arguments. AddEpisodeCtrl now no longer requires options as a resolves() option, but requires Referencedata instead.","title":"Update to Javascript Signatures"},{"location":"reference/CHANGELOG/#maxlength-for-form-helpers","text":"The input form helper will now infer the max length of char fields from the max length of the database field, and render relevant Angular directives.","title":"MaxLength for form helpers"},{"location":"reference/CHANGELOG/#episodedetail-removed","text":"The EpisodeDetailCtrl and EpisodeDetailMixin controller and service have been removed - these were not used anywhere other than in the Wardround plugin, and redundant after enhancements to Patient Detail and Custom DetailViews in 0.6.","title":"EpisodeDetail removed"},{"location":"reference/CHANGELOG/#additional-utilities","text":"Adds a datetimepicker templatetag that will render widgets for a Datetime field including time. Adds a date_of_birth_field templatetag that renders a date of birth field complete with inteligent validation. (Note this change also includes removing the old _partial/ template) Updates dependency graph: Django - 1.8.13","title":"Additional utilities"},{"location":"reference/CHANGELOG/#060-major-release","text":"Detail views Moves from episode oriented detail to patient oriented detail. (All episodes plus x-episode views are available from a patient detail screen) Tagging As a performance optimisation for the frequent access of historic tags, untagging an episode simply renders the tag inactive rather than deleting it and relying on Django-Reversion for access to historical data. Date Formatting We now expect 'd/m/y' date formatting by default. Patient lists Lists are now declarative, and separate from teams. They are implemented as subclasses of opal.core.patient_lists.PatientList. Forms vs. Modals Introduces a distinction between a form and a modal. By default, we now use forms for subrecords, only overriding the modal if there is something we want to do differently specifically in the modal. Command line tools Adds $opal checkout for switching between applications or application versions.","title":"0.6.0 (Major Release)"},{"location":"reference/CHANGELOG/#models-contextprocessor","text":"The 'opal.context_processors.models' Context Processor will allow you to access your subrecords from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include models.Demographics.get_detail_template %}","title":"Models ContextProcessor"},{"location":"reference/CHANGELOG/#upgrade-instructions","text":"Full upgrade instructions to work through any backwards incompatible changes are provided in the Opal docs.","title":"Upgrade instructions:"},{"location":"reference/CHANGELOG/#055-minor-release","text":"Changes the way old tags are handled. Tags are no longer deleted episodes, rather they're marked as archived.","title":"0.5.5 (Minor Release)"},{"location":"reference/CHANGELOG/#054-minor-release","text":"Include local storage","title":"0.5.4 (Minor Release)"},{"location":"reference/CHANGELOG/#053-minor-release","text":"Speed up loading of the lookup lists Fix pagination issues in search Speed up loading of many to many fields Increase test coverage Add some extra help fields to {% forms %} helpers Fixes bug with $rootScope.open_modal() where keystrokes were being intercepted","title":"0.5.3 (Minor Release)"},{"location":"reference/CHANGELOG/#052-minor-release","text":"Speed improvements on page load allow us to only show record panels if a record of that type exists disable modal buttons while saving","title":"0.5.2 (Minor Release)"},{"location":"reference/CHANGELOG/#051-minor-release","text":"Minor bug fixes","title":"0.5.1 (Minor Release)"},{"location":"reference/CHANGELOG/#05-major-release","text":"Search Complete re-design of Search interface to provide a single search box on every page and pagination for resulta. Puts in place a pluggable interface that could be swapped out for e.g. ElasticSearch. New Service for PatientSummary() Analytics Moves Analytics integration into Opal core with the ability to blacklist pages that should never be reported List view Removed old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row. Updated scrolling and loading behaviour to snap to viewport and not display the page build. Subrecord metadata Added four new utility fields to Patient and Episode subrecords: created_by, updated_by, created, updated Select2 and list fields Added support for select2 as an input widget and Subrecord fields that can be lists of things. Also Numerous small bugfixes. Refactoring of the models package into a models module. Updated Underscore.js - 1.8.3 Updated Angular.js - 1.3.11","title":"0.5 (Major release)"},{"location":"reference/CHANGELOG/#043-minor-release","text":"Refactors opal.models to be a models.py file rather than a package. Adds several improvements to forms helpers - Help argument, other argument to select. Updates dependency graph: Angular-strap - 2.3.1","title":"0.4.3 (Minor release)"},{"location":"reference/CHANGELOG/#042-minor-release","text":"Upgrades dependency graph: Django - 1.8.3 Django-reversion - 1.8.7 jQuery - 1.11.3 D3 - 3.5.6 C4 - 0.4.10 South has been removed, now using django migrations","title":"0.4.2 (Minor release)"},{"location":"reference/CHANGELOG/#041-bugfix-release","text":"Fixes some search results appearing duplicated.","title":"0.4.1 (Bugfix release)"},{"location":"reference/CHANGELOG/#04-major-release","text":"New Design Completely re-designed UI following extensive user research and multiple iterations. Managementcommands and scaffolding Features the opal command line tool for common administrative tasks http://opal.openhealthcare.org.uk/docs/guides/command_line_tool/ Form helpers templatetag library New template library for consistent form controls in line with our new interface guidelines http://opal.openhealthcare.org.uk/docs/reference/form_templatetags/ API Documentation Opal JSON APIs are now fully self-documenting for all updated instances http://opal.openhealthcare.org.uk/docs/guides/json_api/","title":"0.4 (Major release)"},{"location":"reference/CHANGELOG/#03-major-release","text":"Bugfixes, significant flexibility in template customisability. Minor UI updates.","title":"0.3 (Major release)"},{"location":"reference/CHANGELOG/#022-bugfix-release","text":"Numerous small bugfixes. Adds the concept of undischarging patients.","title":"0.2.2 (Bugfix release)"},{"location":"reference/CHANGELOG/#021","text":"Numerous small bugfixes.","title":"0.2.1"},{"location":"reference/CHANGELOG/#020","text":"Search overhaul - introduces advanced searches.","title":"0.2.0"},{"location":"reference/CHANGELOG/#011","text":"Initial public release","title":"0.1.1"},{"location":"reference/detail_views/","text":"opal.core.PatientDetailView PatientDetailViews allow us to define a custom view over either one or many episodes, available from the main Patient Detail view. PatientDetailView inherits from the discoverable features DiscoverableFeature , SortableFeature , RestrictableFeature . Fields PatientDetailView.name The machine readable name for this view. Should be lower case, and have no spaces. PatientDetailView.title The display name for this view. This is what will display in links to it. PatientDetailView.template The template we should use to render the view when it's active. PatientDetailView.order An integer controlling the order of PatientDetailViews in the episode switcher menu on the Patient Detail screen is determined by this property. Lower numbers mean higher up. Classmethods PatientDetailView.visible_to Overriding this method will restrict who the view is available to. For instance, we would implement a superuser only view: @classmethod def to_user(klass, user): return user.is_superuser","title":"Detail Views"},{"location":"reference/detail_views/#opalcorepatientdetailview","text":"PatientDetailViews allow us to define a custom view over either one or many episodes, available from the main Patient Detail view. PatientDetailView inherits from the discoverable features DiscoverableFeature , SortableFeature , RestrictableFeature .","title":"opal.core.PatientDetailView"},{"location":"reference/detail_views/#fields","text":"","title":"Fields"},{"location":"reference/detail_views/#patientdetailviewname","text":"The machine readable name for this view. Should be lower case, and have no spaces.","title":"PatientDetailView.name"},{"location":"reference/detail_views/#patientdetailviewtitle","text":"The display name for this view. This is what will display in links to it.","title":"PatientDetailView.title"},{"location":"reference/detail_views/#patientdetailviewtemplate","text":"The template we should use to render the view when it's active.","title":"PatientDetailView.template"},{"location":"reference/detail_views/#patientdetailvieworder","text":"An integer controlling the order of PatientDetailViews in the episode switcher menu on the Patient Detail screen is determined by this property. Lower numbers mean higher up.","title":"PatientDetailView.order"},{"location":"reference/detail_views/#classmethods","text":"","title":"Classmethods"},{"location":"reference/detail_views/#patientdetailviewvisible_to","text":"Overriding this method will restrict who the view is available to. For instance, we would implement a superuser only view: @classmethod def to_user(klass, user): return user.is_superuser","title":"PatientDetailView.visible_to"},{"location":"reference/episode/","text":"opal.models.Episode The opal.models.Episode class represents an episode of care for a patient. This can be either an inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic, or any other arbitrarially defined period of care. Fields Episode.category The category of this episode - e.g. inpatient, outpatient et cetera. This defaults to whatever is set on your application's subclass of opal.core.application.OpalApplication - which itseflf defaults to 'inpatient'. Episode.patient A foreign key relationship to the patient for whom this episode concerns. Episode.active A boolean to provide a quick lookup for whether this is an active or closed episode. Episode.date_of_admission If this is an inpatient episode, the date of admission. Episode.discharge_date If this is an inpatient episode, the date of discharge. Episode.date_of_episode If this is an episode that occurs on one date (like a clinic visit or telephone liaison), the date of that event. Episode.consistency_token A (automatically generated) hash of the above fields. This is used for detecting concurrent edits. Methods The Episode model has the following methods: Episode.to_dict Return a dictionary of field value pairs for this episode episode.to_dict(user) Arguments: user The User for whom we want to serialise this episode Keywords: shallow Boolean to indicate whether we want just this episode, or also a sorted set of previous and subsequent episodes Episode.get_tag_names Arguments: user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.get_tag_names(user) # ['mine', 'infectioncontrol'] Episode.set_tag_names Arguments: tag_names The list of tags that we want to be active for this Episode. user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.set_tag_names(['mine', 'infectioncontrol'], user) Manager The custom manager for Episodes has the following methods: Episode.objects.serialised() Return a set of serialised episodes. Episode.objects.serialised(User, [episode, ...], historic_tags=False) Arguments: user The User for whom we want to serialise this episode episodes An iterable of Episode instances Keywords: historic_tags A boolean to indicate whether the user desires historic or just current tags to be serialised Episode.objects.search As a useful utility, the episode manager has a search method that will search on first name, last name and/or hospital number, under the hood it uses Patient search opal.core.api.EpisodeViewSet Gives you an api for create/update/list/retrieve apis for episodes. Its recommended that you use opal.core.patient_lists rather than the list api, as this gives you more flexibility. The Create api accepts { demographics: {{ a serialised demographics model }}, location: {{ a serialised location model }}. tagging: {{ a dictionary of tag names to True }} }","title":"The Episode model"},{"location":"reference/episode/#opalmodelsepisode","text":"The opal.models.Episode class represents an episode of care for a patient. This can be either an inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic, or any other arbitrarially defined period of care.","title":"opal.models.Episode"},{"location":"reference/episode/#fields","text":"","title":"Fields"},{"location":"reference/episode/#episodecategory","text":"The category of this episode - e.g. inpatient, outpatient et cetera. This defaults to whatever is set on your application's subclass of opal.core.application.OpalApplication - which itseflf defaults to 'inpatient'.","title":"Episode.category"},{"location":"reference/episode/#episodepatient","text":"A foreign key relationship to the patient for whom this episode concerns.","title":"Episode.patient"},{"location":"reference/episode/#episodeactive","text":"A boolean to provide a quick lookup for whether this is an active or closed episode.","title":"Episode.active"},{"location":"reference/episode/#episodedate_of_admission","text":"If this is an inpatient episode, the date of admission.","title":"Episode.date_of_admission"},{"location":"reference/episode/#episodedischarge_date","text":"If this is an inpatient episode, the date of discharge.","title":"Episode.discharge_date"},{"location":"reference/episode/#episodedate_of_episode","text":"If this is an episode that occurs on one date (like a clinic visit or telephone liaison), the date of that event.","title":"Episode.date_of_episode"},{"location":"reference/episode/#episodeconsistency_token","text":"A (automatically generated) hash of the above fields. This is used for detecting concurrent edits.","title":"Episode.consistency_token"},{"location":"reference/episode/#methods","text":"The Episode model has the following methods:","title":"Methods"},{"location":"reference/episode/#episodeto_dict","text":"Return a dictionary of field value pairs for this episode episode.to_dict(user) Arguments: user The User for whom we want to serialise this episode Keywords: shallow Boolean to indicate whether we want just this episode, or also a sorted set of previous and subsequent episodes","title":"Episode.to_dict"},{"location":"reference/episode/#episodeget_tag_names","text":"Arguments: user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.get_tag_names(user) # ['mine', 'infectioncontrol']","title":"Episode.get_tag_names"},{"location":"reference/episode/#episodeset_tag_names","text":"Arguments: tag_names The list of tags that we want to be active for this Episode. user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.set_tag_names(['mine', 'infectioncontrol'], user)","title":"Episode.set_tag_names"},{"location":"reference/episode/#manager","text":"The custom manager for Episodes has the following methods:","title":"Manager"},{"location":"reference/episode/#episodeobjectsserialised","text":"Return a set of serialised episodes. Episode.objects.serialised(User, [episode, ...], historic_tags=False) Arguments: user The User for whom we want to serialise this episode episodes An iterable of Episode instances Keywords: historic_tags A boolean to indicate whether the user desires historic or just current tags to be serialised","title":"Episode.objects.serialised()"},{"location":"reference/episode/#episodeobjectssearch","text":"As a useful utility, the episode manager has a search method that will search on first name, last name and/or hospital number, under the hood it uses Patient search","title":"Episode.objects.search"},{"location":"reference/episode/#opalcoreapiepisodeviewset","text":"Gives you an api for create/update/list/retrieve apis for episodes. Its recommended that you use opal.core.patient_lists rather than the list api, as this gives you more flexibility. The Create api accepts { demographics: {{ a serialised demographics model }}, location: {{ a serialised location model }}. tagging: {{ a dictionary of tag names to True }} }","title":"opal.core.api.EpisodeViewSet"},{"location":"reference/episode_categories/","text":"opal.core.episodes EpisodeCategory Opal Episodes have an associated category. These categories are implemented as subclasses of opal.core.episodes.EpisodeCategory . This class is an Opal DiscoverableFeature and thus inherits all of the core Discoverable API. The category of any episode can be accessed as the .category property of any Episode instance. Properties EpisodeCategory.detail_template This is the template used within the Patient Detail View to display information about episodes of this category. EpisodeCategory.start Returns the Start date of this episode type. EpisodeCategory.stop Returns the Stop date of this episode type InpatientEpisode This is the defualt EpisodeCategory imlpementation - applications started with Opal's scaffolding scripts will use this as the OpalApplication.default_episode_category . It sets the detail template to detail/inpatient.html","title":"Episode Categories"},{"location":"reference/episode_categories/#opalcoreepisodes","text":"","title":"opal.core.episodes"},{"location":"reference/episode_categories/#episodecategory","text":"Opal Episodes have an associated category. These categories are implemented as subclasses of opal.core.episodes.EpisodeCategory . This class is an Opal DiscoverableFeature and thus inherits all of the core Discoverable API. The category of any episode can be accessed as the .category property of any Episode instance.","title":"EpisodeCategory"},{"location":"reference/episode_categories/#properties","text":"","title":"Properties"},{"location":"reference/episode_categories/#episodecategorydetail_template","text":"This is the template used within the Patient Detail View to display information about episodes of this category.","title":"EpisodeCategory.detail_template"},{"location":"reference/episode_categories/#episodecategorystart","text":"Returns the Start date of this episode type.","title":"EpisodeCategory.start"},{"location":"reference/episode_categories/#episodecategorystop","text":"Returns the Stop date of this episode type","title":"EpisodeCategory.stop"},{"location":"reference/episode_categories/#inpatientepisode","text":"This is the defualt EpisodeCategory imlpementation - applications started with Opal's scaffolding scripts will use this as the OpalApplication.default_episode_category . It sets the detail template to detail/inpatient.html","title":"InpatientEpisode"},{"location":"reference/episode_service/","text":"The Episode service The Episode service in opal.services provides us with core functionality related to interacting with episodes in the client. Constructor The Episode service is instantiated with the Episode data that comes back from the Episode JSON API. var episode = new Episode(json_data); Methods Episode.getTags Return a list of the current tags this episode has as strings. episode.getTags(); // ['mine', 'infectioncontrol'] Episode.hasTag Predicate function that determines whether the episode is tagged with a given tag. Arguments: tag : The tag you are interested in. Episode.newItem Instantiate a new subrecord for this episode of a given type. Arguments: recordName : The name of the type of record you want to instantiate. Example usage: episode.newItem('diagnosis'); // item (an Item() instance. Episode.recordEditor.newItem(name) Takes a string, opens a modal from which the user can create a new subrecord of type name . epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save Episode.recordEditor.deleteItem(name, index) Delete the index-th item of type name . Prompt the user to confirm this with a dialog. episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis Episode.recordEditor.editItem(name, index) Open a modal from which the user may edit the index-th item of type name . episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis","title":"Episode service"},{"location":"reference/episode_service/#the-episode-service","text":"The Episode service in opal.services provides us with core functionality related to interacting with episodes in the client.","title":"The Episode service"},{"location":"reference/episode_service/#constructor","text":"The Episode service is instantiated with the Episode data that comes back from the Episode JSON API. var episode = new Episode(json_data);","title":"Constructor"},{"location":"reference/episode_service/#methods","text":"","title":"Methods"},{"location":"reference/episode_service/#episodegettags","text":"Return a list of the current tags this episode has as strings. episode.getTags(); // ['mine', 'infectioncontrol']","title":"Episode.getTags"},{"location":"reference/episode_service/#episodehastag","text":"Predicate function that determines whether the episode is tagged with a given tag. Arguments: tag : The tag you are interested in.","title":"Episode.hasTag"},{"location":"reference/episode_service/#episodenewitem","text":"Instantiate a new subrecord for this episode of a given type. Arguments: recordName : The name of the type of record you want to instantiate. Example usage: episode.newItem('diagnosis'); // item (an Item() instance.","title":"Episode.newItem"},{"location":"reference/episode_service/#episoderecordeditornewitemname","text":"Takes a string, opens a modal from which the user can create a new subrecord of type name . epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save","title":"Episode.recordEditor.newItem(name)"},{"location":"reference/episode_service/#episoderecordeditordeleteitemname-index","text":"Delete the index-th item of type name . Prompt the user to confirm this with a dialog. episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis","title":"Episode.recordEditor.deleteItem(name, index)"},{"location":"reference/episode_service/#episoderecordeditoredititemname-index","text":"Open a modal from which the user may edit the index-th item of type name . episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis","title":"Episode.recordEditor.editItem(name, index)"},{"location":"reference/form_templatetags/","text":"Form Helpers Opal comes with a selection of templatetags that can help you with the repetitive task of generating Bootstrap and Opal compatible markup for your forms. {% checkbox ... %} Generates a checkbox Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) disabled If this exists, we use this as the expression for the ng-disabled directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element {% datepicker ... %} Generates a datepicker Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive required Label to show when we're required mindate Angular Javascript expression to return the minimum possible date element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element {% datetimepicker ... %} Generates a date time fields, a date field on one line and a time field on another Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields date_label The Label with which to describe the date field (defaults to 'Date') time_label The Label with which to describe the date field (defaults to 'Time') model The model which we are editing (This is a string that references an in-scope Angular variable) change an Angular directive that fires on change element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html datetime picker element {% input ... %} The input template tag generates you a form input that will play nicely with Opal's styling. Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the lookuplist values required Label to show when we're required enter expression to evaluate if the user presses return when in this input maxlength maximum number of characters for this input. Will render the form invalid and display help text if exceeded. element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element Inputs with units We also often want to display the unit of a particular field to help our users - consistent styling for this is available by using the unit argument e.g. {% input label= Weight model= editing.weight unit= kg %} {% radio ... %} Generates an inline radio input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element {% select ... %} Generates an inline select input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values other A boolean parameter that if true, provides a free text option when 'Other' is selected help a template to use as the contents of a help popover static an Angular expression that will swap the display to be a static input if it evaluates to true element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element* {% textarea ... %} Generates an inline textarea input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element Inference from subrecord fields A very common pattern is to render form fields that relate to fields of Subrecords . Template tags will use this to infer useful information. The display name will be set to the verbose_name and the the ng-model will be inferred. If its required, it will set as a required field. If its a CharField with a max length it will set a validation rule accordingly. If the field is a free text or foreign key we will infer the lookup list. Alternatively if the field has choices attatched to it we will infer the choices into the field. {% input field= Allergies.drug %} Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively. All inferences can be overridden by declarations in the template tag. For Example {% input field= Allergies.drug label= Something else %} Will render the input with a different label. {% static ... %} Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles). Takes one positional argument, a string representing the subrecord field path. {% static \"Demographics.name\" %} !-- Renders as -- div class=\"form-group\" label class=\"control-label col-sm-3\" Name /label p class=\"form-control-static col-sm-8\" [[ editing.demographics.name ]] /p /div {% icon \"icon-name\" %} Renders a Bootstrap style Icon tag. If the icon starts with fa or glyphicon then we will insert the preceding fa . {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i {% icon \"cusom-icon\"} i class=\"custom-icon\" /i","title":"Form helpers"},{"location":"reference/form_templatetags/#form-helpers","text":"Opal comes with a selection of templatetags that can help you with the repetitive task of generating Bootstrap and Opal compatible markup for your forms.","title":"Form Helpers"},{"location":"reference/form_templatetags/#checkbox","text":"Generates a checkbox Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) disabled If this exists, we use this as the expression for the ng-disabled directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element","title":"{% checkbox ... %}"},{"location":"reference/form_templatetags/#datepicker","text":"Generates a datepicker Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive required Label to show when we're required mindate Angular Javascript expression to return the minimum possible date element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element","title":"{% datepicker ... %}"},{"location":"reference/form_templatetags/#datetimepicker","text":"Generates a date time fields, a date field on one line and a time field on another Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields date_label The Label with which to describe the date field (defaults to 'Date') time_label The Label with which to describe the date field (defaults to 'Time') model The model which we are editing (This is a string that references an in-scope Angular variable) change an Angular directive that fires on change element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html datetime picker element","title":"{% datetimepicker ... %}"},{"location":"reference/form_templatetags/#input","text":"The input template tag generates you a form input that will play nicely with Opal's styling. Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the lookuplist values required Label to show when we're required enter expression to evaluate if the user presses return when in this input maxlength maximum number of characters for this input. Will render the form invalid and display help text if exceeded. element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element","title":"{% input ... %}"},{"location":"reference/form_templatetags/#inputs-with-units","text":"We also often want to display the unit of a particular field to help our users - consistent styling for this is available by using the unit argument e.g. {% input label= Weight model= editing.weight unit= kg %}","title":"Inputs with units"},{"location":"reference/form_templatetags/#radio","text":"Generates an inline radio input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element","title":"{% radio ... %}"},{"location":"reference/form_templatetags/#select","text":"Generates an inline select input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values other A boolean parameter that if true, provides a free text option when 'Other' is selected help a template to use as the contents of a help popover static an Angular expression that will swap the display to be a static input if it evaluates to true element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element*","title":"{% select ... %}"},{"location":"reference/form_templatetags/#textarea","text":"Generates an inline textarea input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element","title":"{% textarea ... %}"},{"location":"reference/form_templatetags/#inference-from-subrecord-fields","text":"A very common pattern is to render form fields that relate to fields of Subrecords . Template tags will use this to infer useful information. The display name will be set to the verbose_name and the the ng-model will be inferred. If its required, it will set as a required field. If its a CharField with a max length it will set a validation rule accordingly. If the field is a free text or foreign key we will infer the lookup list. Alternatively if the field has choices attatched to it we will infer the choices into the field. {% input field= Allergies.drug %} Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively. All inferences can be overridden by declarations in the template tag. For Example {% input field= Allergies.drug label= Something else %} Will render the input with a different label.","title":"Inference from subrecord fields"},{"location":"reference/form_templatetags/#static","text":"Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles). Takes one positional argument, a string representing the subrecord field path. {% static \"Demographics.name\" %} !-- Renders as -- div class=\"form-group\" label class=\"control-label col-sm-3\" Name /label p class=\"form-control-static col-sm-8\" [[ editing.demographics.name ]] /p /div","title":"{% static ... %}"},{"location":"reference/form_templatetags/#icon-icon-name","text":"Renders a Bootstrap style Icon tag. If the icon starts with fa or glyphicon then we will insert the preceding fa . {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i {% icon \"cusom-icon\"} i class=\"custom-icon\" /i","title":"{% icon \"icon-name\" %}"},{"location":"reference/item_service/","text":"The Item service The Item service in opal.services provides us with core functionality related to interacting with subrecord in the client. Methods Item.makeCopy Returns a clone of the editable fields + consistency token so that we can then update them in isolation elsewhere. Item.save Saves attributes to the server. item.save(data_to_save); Item.formController The Angular controller used by the modal that is opened when you edit this item to allow custom logic. Defaults to 'EditItemCtrl';","title":"Item service"},{"location":"reference/item_service/#the-item-service","text":"The Item service in opal.services provides us with core functionality related to interacting with subrecord in the client.","title":"The Item service"},{"location":"reference/item_service/#methods","text":"","title":"Methods"},{"location":"reference/item_service/#itemmakecopy","text":"Returns a clone of the editable fields + consistency token so that we can then update them in isolation elsewhere.","title":"Item.makeCopy"},{"location":"reference/item_service/#itemsave","text":"Saves attributes to the server. item.save(data_to_save);","title":"Item.save"},{"location":"reference/item_service/#itemformcontroller","text":"The Angular controller used by the modal that is opened when you edit this item to allow custom logic. Defaults to 'EditItemCtrl';","title":"Item.formController"},{"location":"reference/javascript_dependencies/","text":"Opal Javscript Dependencies Opal makes use of a number of upstream dependencies which are available for devleopers to use in building applications. | -|- Modernizr | Opal has a custom modernizr build that detects touch events Jquery | 1.11.3 Angular | 1.5.8 Angular-ui-select | 0.19.4 Underscore.js | 1.8.3 D3 | 3.5.6 C3 | 0.4.10","title":"Javascript dependencies"},{"location":"reference/javascript_dependencies/#opal-javscript-dependencies","text":"Opal makes use of a number of upstream dependencies which are available for devleopers to use in building applications. | -|- Modernizr | Opal has a custom modernizr build that detects touch events Jquery | 1.11.3 Angular | 1.5.8 Angular-ui-select | 0.19.4 Underscore.js | 1.8.3 D3 | 3.5.6 C3 | 0.4.10","title":"Opal Javscript Dependencies"},{"location":"reference/javascript_helpers/","text":"Opal Javascript Helpers $rootScope methods Opal provides some methods on the Angular $rootScope object. open_modal $rootScope.open_modal(controller, template, {episode: episode}) Open an arbitrary controller in a modal, passing in the name of the controller, the url for the template. You may also pass through a dictionary of items to resolve. Angular Directives Opal provides some built-in Angular directives for your project to use. date-of-birth Creates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old. tag-select Creates a multi select box where users can remove or add tags. Only tags set as direct_add tags can be set here. This property is set on individual PatientList subclasses, and passed to the front end with the Metadata service. We set the Angular model to be a copy of an episode's tagging. $scope.editing.tagging = episode.tagging[0].makeCopy(); We can instantiate the tag-select widget in our markup as follows. div tag-select ng-model= editing.tagging metadata= metadata class= col-sm-8 /div Note: this directive will load the Metadata service over HTTP if it has not been loaded already. one-click-only A directive that if set with no arguments, or set to true, will only allow a button to be clicked on once and then it'll be disabled. Useful for example to make sure that multiple save requests aren't accidentally triggered. check-form Similar to one click only but it takes the form in use as an argument e.g. button check-form= form ng-click= sendDataToTheServer click me /button This checks the form for valid on click. If the form is then not valid. It will not call the second function, but mark the form as submitted and disable the button. It will watch for the form to become valid and undisable the button when that happens. If the form is valid, it will allow the ng-click function to be called. This means that if you only want to show error messages after the user has clicked the save button you can do so with the form.$submitted variable. scroll-top Adds a click handler to the element that when click will animate the body of the element to scroll to the top go-to-top Similar to scroll-top, this moves the scroll bar to the top of the page but doesn't animate the transition. copy to clipboard e.g. button clipboard data-clipboard-target=\"#content-to-copy\" Copy to Clipboard /button This is a wrapper around clipboard.js, it lets the user copy text from an element that matches the selector you pass it. It will present a growl message saying that the text has been copied. Angular Filters Opal provides some built-in Angular filters for your project to use. short-date Displays a date as DD/MM if it's this year, else DD/MM/YYYY hhmm Displays the hours minutes portion of a javascript Date object as HH:MM short-date-time Displays a date time, short date as above and time as in hhmm above moment-date-filter Allows a us to use moment.js formatters in the template exactly like you would use moment.format title Converts a string to title case upper Converts a string to upper case plural takes a word, a count, and an optional plural term. if count != 1 and there is a plural term it will return the plural term otherwise it will just suffix an 's' if count == 1 then it will return the word age calculates a persons current age from their date of birth boxed Displays Boolean fields as a checkbox (e.g. either [ ] or [X]) [[ item.boolean_field | boxed]] Angular HTTP Interceptors opal uses opal.services.LogoutInterceptor to intercept all failed responses from the server. If they're a 401 or a 403 we redirect the user to the login page, otherwise it passes them through.","title":"Javascript helpers"},{"location":"reference/javascript_helpers/#opal-javascript-helpers","text":"","title":"Opal Javascript Helpers"},{"location":"reference/javascript_helpers/#rootscope-methods","text":"Opal provides some methods on the Angular $rootScope object.","title":"$rootScope methods"},{"location":"reference/javascript_helpers/#open_modal","text":"$rootScope.open_modal(controller, template, {episode: episode}) Open an arbitrary controller in a modal, passing in the name of the controller, the url for the template. You may also pass through a dictionary of items to resolve.","title":"open_modal"},{"location":"reference/javascript_helpers/#angular-directives","text":"Opal provides some built-in Angular directives for your project to use.","title":"Angular Directives"},{"location":"reference/javascript_helpers/#date-of-birth","text":"Creates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old.","title":"date-of-birth"},{"location":"reference/javascript_helpers/#tag-select","text":"Creates a multi select box where users can remove or add tags. Only tags set as direct_add tags can be set here. This property is set on individual PatientList subclasses, and passed to the front end with the Metadata service. We set the Angular model to be a copy of an episode's tagging. $scope.editing.tagging = episode.tagging[0].makeCopy(); We can instantiate the tag-select widget in our markup as follows. div tag-select ng-model= editing.tagging metadata= metadata class= col-sm-8 /div Note: this directive will load the Metadata service over HTTP if it has not been loaded already.","title":"tag-select"},{"location":"reference/javascript_helpers/#one-click-only","text":"A directive that if set with no arguments, or set to true, will only allow a button to be clicked on once and then it'll be disabled. Useful for example to make sure that multiple save requests aren't accidentally triggered.","title":"one-click-only"},{"location":"reference/javascript_helpers/#check-form","text":"Similar to one click only but it takes the form in use as an argument e.g. button check-form= form ng-click= sendDataToTheServer click me /button This checks the form for valid on click. If the form is then not valid. It will not call the second function, but mark the form as submitted and disable the button. It will watch for the form to become valid and undisable the button when that happens. If the form is valid, it will allow the ng-click function to be called. This means that if you only want to show error messages after the user has clicked the save button you can do so with the form.$submitted variable.","title":"check-form"},{"location":"reference/javascript_helpers/#scroll-top","text":"Adds a click handler to the element that when click will animate the body of the element to scroll to the top","title":"scroll-top"},{"location":"reference/javascript_helpers/#go-to-top","text":"Similar to scroll-top, this moves the scroll bar to the top of the page but doesn't animate the transition.","title":"go-to-top"},{"location":"reference/javascript_helpers/#copy-to-clipboard","text":"","title":"copy to clipboard"},{"location":"reference/javascript_helpers/#eg","text":"button clipboard data-clipboard-target=\"#content-to-copy\" Copy to Clipboard /button This is a wrapper around clipboard.js, it lets the user copy text from an element that matches the selector you pass it. It will present a growl message saying that the text has been copied.","title":"e.g."},{"location":"reference/javascript_helpers/#angular-filters","text":"Opal provides some built-in Angular filters for your project to use.","title":"Angular Filters"},{"location":"reference/javascript_helpers/#short-date","text":"Displays a date as DD/MM if it's this year, else DD/MM/YYYY","title":"short-date"},{"location":"reference/javascript_helpers/#hhmm","text":"Displays the hours minutes portion of a javascript Date object as HH:MM","title":"hhmm"},{"location":"reference/javascript_helpers/#short-date-time","text":"Displays a date time, short date as above and time as in hhmm above","title":"short-date-time"},{"location":"reference/javascript_helpers/#moment-date-filter","text":"Allows a us to use moment.js formatters in the template exactly like you would use moment.format","title":"moment-date-filter"},{"location":"reference/javascript_helpers/#title","text":"Converts a string to title case","title":"title"},{"location":"reference/javascript_helpers/#upper","text":"Converts a string to upper case","title":"upper"},{"location":"reference/javascript_helpers/#plural","text":"takes a word, a count, and an optional plural term. if count != 1 and there is a plural term it will return the plural term otherwise it will just suffix an 's' if count == 1 then it will return the word","title":"plural"},{"location":"reference/javascript_helpers/#age","text":"calculates a persons current age from their date of birth","title":"age"},{"location":"reference/javascript_helpers/#boxed","text":"Displays Boolean fields as a checkbox (e.g. either [ ] or [X]) [[ item.boolean_field | boxed]]","title":"boxed"},{"location":"reference/javascript_helpers/#angular-http-interceptors","text":"opal uses opal.services.LogoutInterceptor to intercept all failed responses from the server. If they're a 401 or a 403 we redirect the user to the login page, otherwise it passes them through.","title":"Angular HTTP Interceptors"},{"location":"reference/mixins/","text":"Opal mixins SerialisableFields provides the fields that are on the model for example if we have an allergy model with a field drug it might serialise like below Allergy._get_fieldnames_to_serialize() - [\"id\", \"drug\"] ToDictMixin provides a method that serialises a model to a dictionary for example if we have an allergy model with a field drug it might serialise like below allergy.to_dict() - {\"id\": 1, \"drug\": \"penicillin\"} ToDictMixin._bulk_serialise Used by episode and patient. This flag is used to determine whether the item is serialised as part of Episode/Patient.to_dict. UpdateFromDict provides a method that updates a model based on a dictionary of fields, for example For example on a new allergy allergy.update_from_dict({\"drug\": \"penicillin\"}) will update the allergy to have the drug penicillin","title":"Mixins"},{"location":"reference/mixins/#opal-mixins","text":"","title":"Opal mixins"},{"location":"reference/mixins/#serialisablefields","text":"provides the fields that are on the model for example if we have an allergy model with a field drug it might serialise like below Allergy._get_fieldnames_to_serialize() - [\"id\", \"drug\"]","title":"SerialisableFields"},{"location":"reference/mixins/#todictmixin","text":"provides a method that serialises a model to a dictionary for example if we have an allergy model with a field drug it might serialise like below allergy.to_dict() - {\"id\": 1, \"drug\": \"penicillin\"}","title":"ToDictMixin"},{"location":"reference/mixins/#todictmixin_bulk_serialise","text":"Used by episode and patient. This flag is used to determine whether the item is serialised as part of Episode/Patient.to_dict.","title":"ToDictMixin._bulk_serialise"},{"location":"reference/mixins/#updatefromdict","text":"provides a method that updates a model based on a dictionary of fields, for example For example on a new allergy allergy.update_from_dict({\"drug\": \"penicillin\"}) will update the allergy to have the drug penicillin","title":"UpdateFromDict"},{"location":"reference/opal_application/","text":"opal.core.application Utility functions get_app Returns the application class for the currently active application. get_all_components Returns an iterator of all the of the plugins and the current application OpalApplication The base class for your main application entrypoints is opal.core.application.OpalApplication. You must subclass this in order for Opal to discover your application. If you started your Opal project via $ opal startproject yourproject then this will have been generated for you, and located in yourproject/yourproject/__init__.py Properties Properties available on an OpalApplication: OpalApplication.actions OpalApplication.default_episode_category The default category is 'Inpatient', but can be overridden in the OpalApplication subclass for your implementation. OpalApplication.javascripts A list of javascripts that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . class MyApplication(OpalApplication): javascripts = ['js/one.js'] OpalApplication.menuitems A list of items to add to the top level menu OpalApplication.styles A list of stylesheets that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . These styles are included after the default Opal styles. class MyApplication(OpalApplication): styles = ['css/app.css'] Classmethods Classmethod API for OpalApplication instances: OpalApplication.get_core_javascripts(namespace) Return a list of the core javascript files specified within a given namespace. These wil be relative paths ready for staticfiles. application.get_core_javascripts('opal.utils') # - ['js/opal/utils.js', ...] OpalApplication.get_javascripts() Return a list of the application's javasctipts as paths to them ready for staticfiles. Defaults to returning the OpalApplication.javascripts property. application.get_javascripts() # - ['js/one.js', 'js/two.js', ...] OpalApplication.directory Returns the file system location of the module. OpalApplication.get_menu_items() OpalApplication.get_styles() Return a list of the application's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalApplication.styles . application.get_styles() # - ['css/app.css', ...]","title":"OpalApplication"},{"location":"reference/opal_application/#opalcoreapplication","text":"","title":"opal.core.application"},{"location":"reference/opal_application/#utility-functions","text":"","title":"Utility functions"},{"location":"reference/opal_application/#get_app","text":"Returns the application class for the currently active application.","title":"get_app"},{"location":"reference/opal_application/#get_all_components","text":"Returns an iterator of all the of the plugins and the current application","title":"get_all_components"},{"location":"reference/opal_application/#opalapplication","text":"The base class for your main application entrypoints is opal.core.application.OpalApplication. You must subclass this in order for Opal to discover your application. If you started your Opal project via $ opal startproject yourproject then this will have been generated for you, and located in yourproject/yourproject/__init__.py","title":"OpalApplication"},{"location":"reference/opal_application/#properties","text":"Properties available on an OpalApplication:","title":"Properties"},{"location":"reference/opal_application/#opalapplicationactions","text":"","title":"OpalApplication.actions"},{"location":"reference/opal_application/#opalapplicationdefault_episode_category","text":"The default category is 'Inpatient', but can be overridden in the OpalApplication subclass for your implementation.","title":"OpalApplication.default_episode_category"},{"location":"reference/opal_application/#opalapplicationjavascripts","text":"A list of javascripts that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . class MyApplication(OpalApplication): javascripts = ['js/one.js']","title":"OpalApplication.javascripts"},{"location":"reference/opal_application/#opalapplicationmenuitems","text":"A list of items to add to the top level menu","title":"OpalApplication.menuitems"},{"location":"reference/opal_application/#opalapplicationstyles","text":"A list of stylesheets that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . These styles are included after the default Opal styles. class MyApplication(OpalApplication): styles = ['css/app.css']","title":"OpalApplication.styles"},{"location":"reference/opal_application/#classmethods","text":"Classmethod API for OpalApplication instances:","title":"Classmethods"},{"location":"reference/opal_application/#opalapplicationget_core_javascriptsnamespace","text":"Return a list of the core javascript files specified within a given namespace. These wil be relative paths ready for staticfiles. application.get_core_javascripts('opal.utils') # - ['js/opal/utils.js', ...]","title":"OpalApplication.get_core_javascripts(namespace)"},{"location":"reference/opal_application/#opalapplicationget_javascripts","text":"Return a list of the application's javasctipts as paths to them ready for staticfiles. Defaults to returning the OpalApplication.javascripts property. application.get_javascripts() # - ['js/one.js', 'js/two.js', ...]","title":"OpalApplication.get_javascripts()"},{"location":"reference/opal_application/#opalapplicationdirectory","text":"Returns the file system location of the module.","title":"OpalApplication.directory"},{"location":"reference/opal_application/#opalapplicationget_menu_items","text":"","title":"OpalApplication.get_menu_items()"},{"location":"reference/opal_application/#opalapplicationget_styles","text":"Return a list of the application's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalApplication.styles . application.get_styles() # - ['css/app.css', ...]","title":"OpalApplication.get_styles()"},{"location":"reference/panels_templatetags/","text":"Panel helpers Opal comes with a selection of templatetags for rendering Opal panels for a given subrecord. These panels also allow the user to see instances of the model against the current value of episode in Angular $scope . The user can also create new instances of the given model, as well as editing any existing ones. {% record_panel ... %} Render a panel for a given record that will allow the user to view, create, update and delete instances. The record panel template expects the relevant Angular $scope to have newNamedItem(name, index) , editNamedItem(name, index) and deleteItem(name, index) methods implemented. Default implementations of these are available from the EpisodeDetailMixin . {% load panels %} {% record_panel Diagnosis %} Keywords: model : The model we want to render our panel for title : The display title for this panel detail_template : The display template to use. Defaults to Subrecord.get_detail_template() editable : Whether this panel should allow editing. Defaults to True. angular_filter : An Angular expression that will be evaluated to decide whether to show each item noentries : A string to render if there are no instances of model for the current episode only_display_if_exists : Boolean defaulting to False. If true, the panel will simply not render if there are no instances of model {% record_timeline ... %} Similar to record_panel , record_timeline renders a penel for a given record as a timeline - particularly useful for subrecord types where the date is a key field. {% load panels %} {% record_panel Diagnosis 'when' %} Arguments: model : The model we want to render our panel for whenfield : String of the field that we're using to sort by. {% aligned_pair ... %} Render a key value pair in their own Bootstrap row using columns of width md-4 each. Particularly useful for occasions when we have multiple entries that need to be presented one after another but the data is not naturally tabular. {% load panels %} {% aligned_pair model= episode.start_date | shortDate label= Start Date %} {% aligned_pair model= 22 label= Next Data Point %} Arguments: label : The left hand item, to be rendered bold. model : The right hand item, to be rendered as an angular expression","title":"Panel Template tags"},{"location":"reference/panels_templatetags/#panel-helpers","text":"Opal comes with a selection of templatetags for rendering Opal panels for a given subrecord. These panels also allow the user to see instances of the model against the current value of episode in Angular $scope . The user can also create new instances of the given model, as well as editing any existing ones.","title":"Panel helpers"},{"location":"reference/panels_templatetags/#record_panel","text":"Render a panel for a given record that will allow the user to view, create, update and delete instances. The record panel template expects the relevant Angular $scope to have newNamedItem(name, index) , editNamedItem(name, index) and deleteItem(name, index) methods implemented. Default implementations of these are available from the EpisodeDetailMixin . {% load panels %} {% record_panel Diagnosis %} Keywords: model : The model we want to render our panel for title : The display title for this panel detail_template : The display template to use. Defaults to Subrecord.get_detail_template() editable : Whether this panel should allow editing. Defaults to True. angular_filter : An Angular expression that will be evaluated to decide whether to show each item noentries : A string to render if there are no instances of model for the current episode only_display_if_exists : Boolean defaulting to False. If true, the panel will simply not render if there are no instances of model","title":"{% record_panel ... %}"},{"location":"reference/panels_templatetags/#record_timeline","text":"Similar to record_panel , record_timeline renders a penel for a given record as a timeline - particularly useful for subrecord types where the date is a key field. {% load panels %} {% record_panel Diagnosis 'when' %} Arguments: model : The model we want to render our panel for whenfield : String of the field that we're using to sort by.","title":"{% record_timeline ... %}"},{"location":"reference/panels_templatetags/#aligned_pair","text":"Render a key value pair in their own Bootstrap row using columns of width md-4 each. Particularly useful for occasions when we have multiple entries that need to be presented one after another but the data is not naturally tabular. {% load panels %} {% aligned_pair model= episode.start_date | shortDate label= Start Date %} {% aligned_pair model= 22 label= Next Data Point %} Arguments: label : The left hand item, to be rendered bold. model : The right hand item, to be rendered as an angular expression","title":"{% aligned_pair ... %}"},{"location":"reference/patient/","text":"opal.models.Patient methods create_episode Returns a new Episode for this patient. to_dict Return the dictionary representation of this patient - suitable for serialization. patient.to_dict(user) bulk_update Create or update many subrecords in one go, from a serialised dictionary of data. Pass in a dictionary of subrecords you want to update, as well as an episode if one exists. This method will create all the subrecords and implicitly create a new episode if required. This API will execute all create/update operations as an atomic transaction. For example the following will create a patient: patient = Patient() patient.bulk_update( { \"demographics\": \"hospital_number\": \"1231212\", \"allergies\": [ {\"drug\": \"penicillin\"}, {\"drug\": \"aspirin\"}, ] }, user ) Manager The custom manager for Patient has the following methods: Patient.objects.search A useful utility the patient manager has a search method that will search on first name last name hospital number. Its splits the string input on space, so if you do \"12 Jane\", you will get all Patients who's name, surname or hospital number contains either 12 or Jane, in this example most probably people who's hospital number contains 12 and who's first name is Jane.","title":"Patient"},{"location":"reference/patient/#opalmodelspatient","text":"","title":"opal.models.Patient"},{"location":"reference/patient/#methods","text":"","title":"methods"},{"location":"reference/patient/#create_episode","text":"Returns a new Episode for this patient.","title":"create_episode"},{"location":"reference/patient/#to_dict","text":"Return the dictionary representation of this patient - suitable for serialization. patient.to_dict(user)","title":"to_dict"},{"location":"reference/patient/#bulk_update","text":"Create or update many subrecords in one go, from a serialised dictionary of data. Pass in a dictionary of subrecords you want to update, as well as an episode if one exists. This method will create all the subrecords and implicitly create a new episode if required. This API will execute all create/update operations as an atomic transaction. For example the following will create a patient: patient = Patient() patient.bulk_update( { \"demographics\": \"hospital_number\": \"1231212\", \"allergies\": [ {\"drug\": \"penicillin\"}, {\"drug\": \"aspirin\"}, ] }, user )","title":"bulk_update"},{"location":"reference/patient/#manager","text":"The custom manager for Patient has the following methods:","title":"Manager"},{"location":"reference/patient/#patientobjectssearch","text":"A useful utility the patient manager has a search method that will search on first name last name hospital number. Its splits the string input on space, so if you do \"12 Jane\", you will get all Patients who's name, surname or hospital number contains either 12 or Jane, in this example most probably people who's hospital number contains 12 and who's first name is Jane.","title":"Patient.objects.search"},{"location":"reference/patient_list/","text":"opal.core.patient_lists The patient_lists module defines a number of classes for working with lists of patients. PatientList ... Properties PatientList.display_name How we want to refer to this list on screen to users. PatientList.comparator_service A custom comparator service to set sort order within a list. Defaults to None. TaggedPatientList Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists. Properties TaggedPatientList.tag The main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK. TaggedPatientList.subtag The child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK. TabbedPatientListGroup Groups of Patient Lists to display as tabs at the top of any list in the group. Properties TabbedPatientListGroup.member_lists A list containing the PatientList subclasses in this group. Classmethods TabbedPatientListGroup.for_list Returns the group for a given PatientList. Raises ValueError if not passed a PatientList TabbedPatientListGroup.get_member_lists A hook for dynamically customising the members of this list group. Returns an iterable of PatientLists. Defaults to the .member_lists property TabbedPatientListGroup.get_member_lists_for_user Returns an iterable of the visible member lists for a given USER TabbedPatientListGroup.visible_to Predicate function to determine whether this list is meaningfully visible to this USER","title":"Patient Lists"},{"location":"reference/patient_list/#opalcorepatient_lists","text":"The patient_lists module defines a number of classes for working with lists of patients.","title":"opal.core.patient_lists"},{"location":"reference/patient_list/#patientlist","text":"...","title":"PatientList"},{"location":"reference/patient_list/#properties","text":"","title":"Properties"},{"location":"reference/patient_list/#patientlistdisplay_name","text":"How we want to refer to this list on screen to users.","title":"PatientList.display_name"},{"location":"reference/patient_list/#patientlistcomparator_service","text":"A custom comparator service to set sort order within a list. Defaults to None.","title":"PatientList.comparator_service"},{"location":"reference/patient_list/#taggedpatientlist","text":"Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists.","title":"TaggedPatientList"},{"location":"reference/patient_list/#properties_1","text":"","title":"Properties"},{"location":"reference/patient_list/#taggedpatientlisttag","text":"The main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.","title":"TaggedPatientList.tag"},{"location":"reference/patient_list/#taggedpatientlistsubtag","text":"The child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.","title":"TaggedPatientList.subtag"},{"location":"reference/patient_list/#tabbedpatientlistgroup","text":"Groups of Patient Lists to display as tabs at the top of any list in the group.","title":"TabbedPatientListGroup"},{"location":"reference/patient_list/#properties_2","text":"","title":"Properties"},{"location":"reference/patient_list/#tabbedpatientlistgroupmember_lists","text":"A list containing the PatientList subclasses in this group.","title":"TabbedPatientListGroup.member_lists"},{"location":"reference/patient_list/#classmethods","text":"","title":"Classmethods"},{"location":"reference/patient_list/#tabbedpatientlistgroupfor_list","text":"Returns the group for a given PatientList. Raises ValueError if not passed a PatientList","title":"TabbedPatientListGroup.for_list"},{"location":"reference/patient_list/#tabbedpatientlistgroupget_member_lists","text":"A hook for dynamically customising the members of this list group. Returns an iterable of PatientLists. Defaults to the .member_lists property","title":"TabbedPatientListGroup.get_member_lists"},{"location":"reference/patient_list/#tabbedpatientlistgroupget_member_lists_for_user","text":"Returns an iterable of the visible member lists for a given USER","title":"TabbedPatientListGroup.get_member_lists_for_user"},{"location":"reference/patient_list/#tabbedpatientlistgroupvisible_to","text":"Predicate function to determine whether this list is meaningfully visible to this USER","title":"TabbedPatientListGroup.visible_to"},{"location":"reference/patient_summary_service/","text":"The PatientSummary service The PatientSummary service in opal.services provides us with core functionality related to interacting with patient search results in the client. Constructor The PatientSummary service is instantiated with the Patient search result data that comes back from the Patient search JSON API. var patient_summary = new PatientSummary(json_data);","title":"Patient summary service"},{"location":"reference/patient_summary_service/#the-patientsummary-service","text":"The PatientSummary service in opal.services provides us with core functionality related to interacting with patient search results in the client.","title":"The PatientSummary service"},{"location":"reference/patient_summary_service/#constructor","text":"The PatientSummary service is instantiated with the Patient search result data that comes back from the Patient search JSON API. var patient_summary = new PatientSummary(json_data);","title":"Constructor"},{"location":"reference/reference_guides/","text":"Opal Reference material The following reference guides are available: Models | -|- opal.models.Episode | The central Episode model opal.models.Patient | The Patient model opal.models.Subrecord | for subrecords of Episodes or Patients opal.models.* | Mixin helpers for useful functionality Opal Core | -|- opal.core.application | Opal Application objects| opal.core.detail |Detail Views - Custom views over one or many episodes.| opal.core.episodes |Episode Categories - Controlling the behaviour of different types of episode| opal.core.schemas |Schemas - Dynamic columns for the table views| opal.core.patient_lists |Patient Lists - defining different types of list| Angular Services | -|- Episode | Episode objects Item | Subrecord objects PatientSummary | Patient search result summaries Search Services | Services from the Search module| Helper libraries | -|- The forms Templatetag library | The building blocks for Opal forms The panels Templatetag library | Rendering record panels Javascript Helpers | Angular filters and $rootScope methods Opal Search module | -|- Making Search Queries | Search query backends and helper functions Miscellaneous documentation | -|- Changelog | Opal Changelog Upgrading | Upgrading between Opal versions Javascript dependencies | External javascript libraries available | Testing | Testing","title":"Reference"},{"location":"reference/reference_guides/#opal-reference-material","text":"The following reference guides are available:","title":"Opal Reference material"},{"location":"reference/reference_guides/#models","text":"| -|- opal.models.Episode | The central Episode model opal.models.Patient | The Patient model opal.models.Subrecord | for subrecords of Episodes or Patients opal.models.* | Mixin helpers for useful functionality","title":"Models"},{"location":"reference/reference_guides/#opal-core","text":"| -|- opal.core.application | Opal Application objects| opal.core.detail |Detail Views - Custom views over one or many episodes.| opal.core.episodes |Episode Categories - Controlling the behaviour of different types of episode| opal.core.schemas |Schemas - Dynamic columns for the table views| opal.core.patient_lists |Patient Lists - defining different types of list|","title":"Opal Core"},{"location":"reference/reference_guides/#angular-services","text":"| -|- Episode | Episode objects Item | Subrecord objects PatientSummary | Patient search result summaries Search Services | Services from the Search module|","title":"Angular Services"},{"location":"reference/reference_guides/#helper-libraries","text":"| -|- The forms Templatetag library | The building blocks for Opal forms The panels Templatetag library | Rendering record panels Javascript Helpers | Angular filters and $rootScope methods","title":"Helper libraries"},{"location":"reference/reference_guides/#opal-search-module","text":"| -|- Making Search Queries | Search query backends and helper functions","title":"Opal Search module"},{"location":"reference/reference_guides/#miscellaneous-documentation","text":"| -|- Changelog | Opal Changelog Upgrading | Upgrading between Opal versions Javascript dependencies | External javascript libraries available | Testing | Testing","title":"Miscellaneous documentation"},{"location":"reference/schemas/","text":"Opal Schemas Opal schemas provide a JSON representation of the structure of subrecords. Opal uses these schemas internally to construct the Item classes in AngularJS on the client side. The Schema for an Opal application is available at the url /api/v0.1/schema/ and contains the serialized representation of all subrecords and their fields. Subrecord information Individual subrecords are serialized to the schema using the function opal.core.schemas.serialize_model . Schema Subrecord fields name: the result of Subrecord.get_api_name() display_name: the result of Subrecord.get_display_name() single: Whether the Subrecord is a singleton advanced_searchable: if the Subrecord should appear in the advanced search view fields: a represention of each field Optional fields: sort: an Angular string that describes how subrecord of this type should be ordered readOnly: if this Subrecord is read only form_url: the url of the form of this Subrecord icon: the icon class of this Subrecord if it exists angular_service: an Angular service used to initialize the Item in the Opal client side application. class Colour(models.EpisodeSubrecord): _advanced_searchable = False _exclude_from_extract = True _angular_service = 'Colour' _icon = fa fa-comments name = dmodels.CharField(max_length=200) # becomes:... { 'advanced_searchable': False, 'angular_service': 'Colour', 'display_name': 'Colour', 'fields': [ # field information as noted below ], 'form_url': u'/templates/forms/colour.html', 'icon': 'fa fa-comments', 'name': 'colour', 'single': False } Subrecord Field information Opal makes the most out of the rich Django model interface by delivering much of the derivable metadata about the structure of fields straight from the model. default: the default value for the field to appear in the form. At present this will accept a callable but won't serialise date/datetime fields. model: The name of the model this field relates to. lookup_list: For ForeignKeyOrFreeText fields this returns name of the lookup list that relates to this field. title: The verbose_name of this field, type: The type of field. Allows us to correctly cast fields into moments on the front end. name: the api name for the field class Birthday(models.PatientSubrecord): party = dmodels.DateTimeField(verbose_name= Party Time! blank=True) name = dmodels.CharField(default='Dave', blank=True, null=True) # becomes... [ { 'default': Dave , 'lookup_list': None, 'model': 'Birthday', 'name': 'name', 'title': u'Name', 'type': 'string' }, { 'default': None, 'lookup_list': None, 'model': 'Birthday', 'name': 'party', 'title': u'Party Time!', 'type': 'date_time' } ]","title":"Schemas"},{"location":"reference/schemas/#opal-schemas","text":"Opal schemas provide a JSON representation of the structure of subrecords. Opal uses these schemas internally to construct the Item classes in AngularJS on the client side. The Schema for an Opal application is available at the url /api/v0.1/schema/ and contains the serialized representation of all subrecords and their fields.","title":"Opal Schemas"},{"location":"reference/schemas/#subrecord-information","text":"Individual subrecords are serialized to the schema using the function opal.core.schemas.serialize_model .","title":"Subrecord information"},{"location":"reference/schemas/#schema-subrecord-fields","text":"name: the result of Subrecord.get_api_name() display_name: the result of Subrecord.get_display_name() single: Whether the Subrecord is a singleton advanced_searchable: if the Subrecord should appear in the advanced search view fields: a represention of each field Optional fields: sort: an Angular string that describes how subrecord of this type should be ordered readOnly: if this Subrecord is read only form_url: the url of the form of this Subrecord icon: the icon class of this Subrecord if it exists angular_service: an Angular service used to initialize the Item in the Opal client side application. class Colour(models.EpisodeSubrecord): _advanced_searchable = False _exclude_from_extract = True _angular_service = 'Colour' _icon = fa fa-comments name = dmodels.CharField(max_length=200) # becomes:... { 'advanced_searchable': False, 'angular_service': 'Colour', 'display_name': 'Colour', 'fields': [ # field information as noted below ], 'form_url': u'/templates/forms/colour.html', 'icon': 'fa fa-comments', 'name': 'colour', 'single': False }","title":"Schema Subrecord fields"},{"location":"reference/schemas/#subrecord-field-information","text":"Opal makes the most out of the rich Django model interface by delivering much of the derivable metadata about the structure of fields straight from the model. default: the default value for the field to appear in the form. At present this will accept a callable but won't serialise date/datetime fields. model: The name of the model this field relates to. lookup_list: For ForeignKeyOrFreeText fields this returns name of the lookup list that relates to this field. title: The verbose_name of this field, type: The type of field. Allows us to correctly cast fields into moments on the front end. name: the api name for the field class Birthday(models.PatientSubrecord): party = dmodels.DateTimeField(verbose_name= Party Time! blank=True) name = dmodels.CharField(default='Dave', blank=True, null=True) # becomes... [ { 'default': Dave , 'lookup_list': None, 'model': 'Birthday', 'name': 'name', 'title': u'Name', 'type': 'string' }, { 'default': None, 'lookup_list': None, 'model': 'Birthday', 'name': 'party', 'title': u'Party Time!', 'type': 'date_time' } ]","title":"Subrecord Field information"},{"location":"reference/search_js_services/","text":"Opal Core Search Javascript Services Filter The Angular Service for saved filters. Maps to the model opal.models.Filter . save(attrs) Save this filter with the attributes passed in. If there is no ID, this is taken to be a create. destroy() Destroy this filter. filtersLoader Loader service that will resolve with instantiated Filter objects for each of the current user's filters. FilterResource Angular $resource for Filter objects.","title":"Search JS Services"},{"location":"reference/search_js_services/#opal-core-search-javascript-services","text":"","title":"Opal Core Search Javascript Services"},{"location":"reference/search_js_services/#filter","text":"The Angular Service for saved filters. Maps to the model opal.models.Filter .","title":"Filter"},{"location":"reference/search_js_services/#saveattrs","text":"Save this filter with the attributes passed in. If there is no ID, this is taken to be a create.","title":"save(attrs)"},{"location":"reference/search_js_services/#destroy","text":"Destroy this filter.","title":"destroy()"},{"location":"reference/search_js_services/#filtersloader","text":"Loader service that will resolve with instantiated Filter objects for each of the current user's filters.","title":"filtersLoader"},{"location":"reference/search_js_services/#filterresource","text":"Angular $resource for Filter objects.","title":"FilterResource"},{"location":"reference/search_queries/","text":"opal.core.search.queries This module provides our base classes for query backends as well as helper functions. episodes_for_user Given an iterable of EPISODES and a USER, return a filtered list of episodes that this user has the permissions to know about. filtered_episodes = episodes_for_user(episodes, user)","title":"Search Queries"},{"location":"reference/search_queries/#opalcoresearchqueries","text":"This module provides our base classes for query backends as well as helper functions.","title":"opal.core.search.queries"},{"location":"reference/search_queries/#episodes_for_user","text":"Given an iterable of EPISODES and a USER, return a filtered list of episodes that this user has the permissions to know about. filtered_episodes = episodes_for_user(episodes, user)","title":"episodes_for_user"},{"location":"reference/subrecords/","text":"Opal Subrecords Opal Subrecords are models that relate to either Patients or Episodes, and inherit from base classes opal.models.PatientSubrecord or opal.models.EpisodeSubrecord They themselves inherit from the mixins opal.models.ToDictMixin , opal.models.UpdateFromDict Properties Subrecord._angular_service Name of the Angular service you would like to use to customise the initialization of this subrecord in the javascript layer. class Demographics(PatientSubrecord): _angular_service = 'Demographics' Subrecord._icon String that provides the name of the icon to use for forms, column headings etc. class Demographics(PatientSubrecord): _icon = 'fa fa-user' Subrecord._is_singleton Boolean that determines whether this subrecord is a singleton. There may only be one of each singleton Subrecord, which is created whth the parent. class Demographics(PatientSubrecord): _is_singleton = True For this case, when a Patient is created, an empty Demographics instance will automatically be created. Subrecord._list_limit Integer to indicate the maximum number of entries to display in list view for this model. Useful for record types where many entries will accrue, or where display is particularly verbose. class BloodPressureReading(EpisodeSubrecord): _list_limit = 3 Subrecord._sort Name of the field by which we want to sort these records when displaying. class Antimicrobial(EpisodeSubrecord): _sort = 'start_date' Subrecord._title String we would like to use for user-facing display of this record type. class Antimicrobial(EpisodeSubrecord): _title = 'Abx' Subrecord._clonable A Boolean that is True by default used by opal.views.EpisodeCopyToCategoryView to determine if instances of this record should be copied across. class Antimicrobial(EpisodeSubrecord): _clonable = 'False' Subrecord._exclude_from_extract Boolean to specify that this subrecord should be excluded from any standard data extract. This implicitly defaults to False. class Antimicrobial(EpisodeSubrecord): _exclude_from_extract = 'Abx' Subrecord.pid_fields An iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID). This is used when creating data extracts to exclude PID from e.g. CSV downloads. Methods Subrecord.get_display_template() Classmethod to locate the active display template for our record. Returns the name of the template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations Subrecord.get_form_template() Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations Subrecord.get_modal_template() Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for modal customisations patient_list Optional patient list slug string to check for modal customisations Subrecord.get_modal_footer_template Classmethod to add a custom footer to a modal, used for example to denote if the data from a model has been sourced from an external source Subrecord.bulk_update_from_dicts() A Classmethod to allow the creation of multiple objects. Takes in the parent model - an episode for EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates over all the subrecords, adds in the parent relationship and calls update_from_dict Subrecord Mixins TrackedModel A Tracked Model automatically has created, created_by, updated, updated_by and these are only updated when used via the api ExternallySourcedModel Often we want data to be sourced from external systems, this mixin adds in the fields external_system and external_identifier to allow us to track where they come from and how they are referenced by that system. These fields are then often used in forms to make the data read only","title":"Subrecords"},{"location":"reference/subrecords/#opal-subrecords","text":"Opal Subrecords are models that relate to either Patients or Episodes, and inherit from base classes opal.models.PatientSubrecord or opal.models.EpisodeSubrecord They themselves inherit from the mixins opal.models.ToDictMixin , opal.models.UpdateFromDict","title":"Opal Subrecords"},{"location":"reference/subrecords/#properties","text":"","title":"Properties"},{"location":"reference/subrecords/#subrecord_angular_service","text":"Name of the Angular service you would like to use to customise the initialization of this subrecord in the javascript layer. class Demographics(PatientSubrecord): _angular_service = 'Demographics'","title":"Subrecord._angular_service"},{"location":"reference/subrecords/#subrecord_icon","text":"String that provides the name of the icon to use for forms, column headings etc. class Demographics(PatientSubrecord): _icon = 'fa fa-user'","title":"Subrecord._icon"},{"location":"reference/subrecords/#subrecord_is_singleton","text":"Boolean that determines whether this subrecord is a singleton. There may only be one of each singleton Subrecord, which is created whth the parent. class Demographics(PatientSubrecord): _is_singleton = True For this case, when a Patient is created, an empty Demographics instance will automatically be created.","title":"Subrecord._is_singleton"},{"location":"reference/subrecords/#subrecord_list_limit","text":"Integer to indicate the maximum number of entries to display in list view for this model. Useful for record types where many entries will accrue, or where display is particularly verbose. class BloodPressureReading(EpisodeSubrecord): _list_limit = 3","title":"Subrecord._list_limit"},{"location":"reference/subrecords/#subrecord_sort","text":"Name of the field by which we want to sort these records when displaying. class Antimicrobial(EpisodeSubrecord): _sort = 'start_date'","title":"Subrecord._sort"},{"location":"reference/subrecords/#subrecord_title","text":"String we would like to use for user-facing display of this record type. class Antimicrobial(EpisodeSubrecord): _title = 'Abx'","title":"Subrecord._title"},{"location":"reference/subrecords/#subrecord_clonable","text":"A Boolean that is True by default used by opal.views.EpisodeCopyToCategoryView to determine if instances of this record should be copied across. class Antimicrobial(EpisodeSubrecord): _clonable = 'False'","title":"Subrecord._clonable"},{"location":"reference/subrecords/#subrecord_exclude_from_extract","text":"Boolean to specify that this subrecord should be excluded from any standard data extract. This implicitly defaults to False. class Antimicrobial(EpisodeSubrecord): _exclude_from_extract = 'Abx'","title":"Subrecord._exclude_from_extract"},{"location":"reference/subrecords/#subrecordpid_fields","text":"An iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID). This is used when creating data extracts to exclude PID from e.g. CSV downloads.","title":"Subrecord.pid_fields"},{"location":"reference/subrecords/#methods","text":"","title":"Methods"},{"location":"reference/subrecords/#subrecordget_display_template","text":"Classmethod to locate the active display template for our record. Returns the name of the template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations","title":"Subrecord.get_display_template()"},{"location":"reference/subrecords/#subrecordget_form_template","text":"Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations","title":"Subrecord.get_form_template()"},{"location":"reference/subrecords/#subrecordget_modal_template","text":"Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for modal customisations patient_list Optional patient list slug string to check for modal customisations","title":"Subrecord.get_modal_template()"},{"location":"reference/subrecords/#subrecordget_modal_footer_template","text":"Classmethod to add a custom footer to a modal, used for example to denote if the data from a model has been sourced from an external source","title":"Subrecord.get_modal_footer_template"},{"location":"reference/subrecords/#subrecordbulk_update_from_dicts","text":"A Classmethod to allow the creation of multiple objects. Takes in the parent model - an episode for EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates over all the subrecords, adds in the parent relationship and calls update_from_dict","title":"Subrecord.bulk_update_from_dicts()"},{"location":"reference/subrecords/#subrecord-mixins","text":"","title":"Subrecord Mixins"},{"location":"reference/subrecords/#trackedmodel","text":"A Tracked Model automatically has created, created_by, updated, updated_by and these are only updated when used via the api","title":"TrackedModel"},{"location":"reference/subrecords/#externallysourcedmodel","text":"Often we want data to be sourced from external systems, this mixin adds in the fields external_system and external_identifier to allow us to track where they come from and how they are referenced by that system. These fields are then often used in forms to make the data read only","title":"ExternallySourcedModel"},{"location":"reference/testing/","text":"Automated Testing Built on top of Django and Angular, Opal applications have great support for automated testing. Opal provides some utilities to make testing your application even easier. Command Line test runner The opal command line tool has a test command which will run unittests for both the server and client side components of your application. Javascript testing By default, we recommend using Jasmine and Karma to test your javascript code. Of course you can use any test framework you choose, although Opal doesn't currently ship with helpers for any other frameworks. Installing javascript testing tools To installing Karma, Jasmine and Phantomjs in a local directory: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher Setting up the karma environment for your application If you'd like to run karma tests, Opal ships with a function to give you a default karma config. In your karma config just require('[[ path to opal ]]/config/karma_defaults.js') The function takes in the files you want to include and runs karma tests on them. // config/karma.config.js module.exports = function(config){ var opalPath = '../../opal'; var karmaDefaults = require(opalPath + '/config/karma_defaults.js'); var baseDir = __dirname + '/..'; var includedFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir); config.set(defaultConfig); }; Test Coverage The Opal test runner has a -c option which runs coverage reports for both Python and Javascript code: opal test -c Python test coverage uses the coverage tool and you may want to set include/excludes in a .coveragerc . Javascript test files to be reported on should be passed as an extra argument to karmaDefaults : var coverageFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir, coverageFiles); HTML test coverage reports will be output to the directory htmlcov and htmlcov/js at the root of your application.","title":"Testing"},{"location":"reference/testing/#automated-testing","text":"Built on top of Django and Angular, Opal applications have great support for automated testing. Opal provides some utilities to make testing your application even easier.","title":"Automated Testing"},{"location":"reference/testing/#command-line-test-runner","text":"The opal command line tool has a test command which will run unittests for both the server and client side components of your application.","title":"Command Line test runner"},{"location":"reference/testing/#javascript-testing","text":"By default, we recommend using Jasmine and Karma to test your javascript code. Of course you can use any test framework you choose, although Opal doesn't currently ship with helpers for any other frameworks.","title":"Javascript testing"},{"location":"reference/testing/#installing-javascript-testing-tools","text":"To installing Karma, Jasmine and Phantomjs in a local directory: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher","title":"Installing javascript testing tools"},{"location":"reference/testing/#setting-up-the-karma-environment-for-your-application","text":"If you'd like to run karma tests, Opal ships with a function to give you a default karma config. In your karma config just require('[[ path to opal ]]/config/karma_defaults.js') The function takes in the files you want to include and runs karma tests on them. // config/karma.config.js module.exports = function(config){ var opalPath = '../../opal'; var karmaDefaults = require(opalPath + '/config/karma_defaults.js'); var baseDir = __dirname + '/..'; var includedFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir); config.set(defaultConfig); };","title":"Setting up the karma environment for your application"},{"location":"reference/testing/#test-coverage","text":"The Opal test runner has a -c option which runs coverage reports for both Python and Javascript code: opal test -c Python test coverage uses the coverage tool and you may want to set include/excludes in a .coveragerc . Javascript test files to be reported on should be passed as an extra argument to karmaDefaults : var coverageFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir, coverageFiles); HTML test coverage reports will be output to the directory htmlcov and htmlcov/js at the root of your application.","title":"Test Coverage"},{"location":"reference/upgrading/","text":"Upgrading Your Opal Application This document provides instructions for specific steps required to upgrading your Opal application to a later version where there are extra steps required. 0.7.1 - 0.8.0 Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.8.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal Options Options are now an ex-API. Applications should convert to use either Referencedata (canonical terms for common data), or Metadata (App specific data you wish to pass into the front end). UI Components Those applications relying on Angular strap ui components (Typeahead, Popover, Tooltip, Datepicker, Timepicker) should convert their templates to use the Angular UI Boostrap equivalents, or the Opal templatetags. If you are simply using Opal templatetags from forms and not overriding these templates, then the transition should be seamless. Otherwise, searching your codebase for html files containing bs- and looking for angular strap components is a good start. Applications or plugins with javascript tests may need to update their includes to remove references to old library files. Full documentation of the markup and options for these components is found here extending modal_base.html We now have different base templates for modals, forms and two column modal forms (essentially a form with a side bar). The form templates add validation checks around the saving to catch any validation errors a form might through. They assume the existence of a form called 'form'. As part of this modal_base has been moved into a folder in templates called base_templates Rename any templates extending modal_base.html to extend the correct template in base_templates/ - modal_base.html or modal_form_base.html . Add episode modal url The add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash. 0.7.0 - 0.7.1 Downstream dependencies Opal 0.7.1 updates the expected version of Django Axes to 1.7.0 - you will wish to update this in your requirements.txt or similar accordingly. DRF Authentication We highly recommend that applications explicitly set Django Rest Framework authentication classes in their settings.py . By default Opal now uses session and token auth, which will require a migration to install the DRF Token authentication app. INSTALLED_APPS = ( # .... 'rest_framework', 'rest_framework.authtoken', # ... ) REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.TokenAuthentication', 'rest_framework.authentication.SessionAuthentication', ) } 6.x - 7.x Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.7.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.7.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp Breaking changes Opal 0.7 contains a number of breaking changes. Name changes opal.models.Episode.category has been re-named category_name . If your application directly sets category, you will be required to update all instances where this happens. The /episode/:pk/ API has moved to /api/v0.1/episode/:pk/ so any code (typically javascript) code that directly saves to this API endpoint rather than using the Opal JS Episode services should work immediately when re-pointed at the new URL. Moving from options to referencedata and metadata The signature of the EditItemCtrl has been updated - this modal controller no longer takes an options argument, rather it uses the new 0.7.x referencedata and metadata services. Applications that call EditItemCtrl directly should look to update the resolves option they were passing to $modal.open . (Alternatively, developers should consider refactoring to use the new recordEditor API.) The signatures of Flow enter and exit methods has changed to no longer accept options as a positional argument, and enter/exit controllers will no longer be initialized with access to options as a resovled provider. They will have access to either/both of referencedata and metadata so if your application includes custom flow controllers that use options you will need to refactor these to use the new x-data arguments instead. referencedata and metadata between them have all data previously in options, so the refactor here should be relatively painless. Date of birth fields in forms The partial partials/_date_of_birth_field.html has been removed and replaced with the {% date_of_birth_field %} templatetag in the forms library. You should update any forms to use this new tag. 5.x - 6.x Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.6.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal Changes to abstract models If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.6.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp You should note that as of Opal 0.6.x Demographics now splits names into first, surname, middle name and title. The previous name field will be converted to be first_name . Strategies for updating your data to use the appropriate fields will vary from application to application, but one good such strategy is to use a data migration such as the one done here . Update settings Many of the default Opal templates now assume that the 'opal.context_processors.models' Context Processor is available - you should add that to the TEMPLATE_CONTEXT_PROCESSORS setting in your application's settings.py The default date formats in Opal have changed - and so you should update your DATE_X settings to match: DATE_FORMAT = 'd/m/Y' DATE_INPUT_FORMATS = ['%d/%m/%Y'] DATETIME_FORMAT = 'd/m/Y H:i:s' DATETIME_INPUT_FORMATS = ['%d/%m/%Y %H:%M:%S'] Upgrade plugins A number of Opal plugins have new releases to work with the changes in Opal 0.6.x opal-referral - Upgrade to 0.1.4 opal-wardround - Upgrade to 0.6.0 opal-observations - Upgrade to 0.1.2 opal-dischargesummary - Upgrade to 0.2.0 opal-dashboard - Upgrade to 0.1.3 Meanwhile the opal-taskrunner plugin has now been deprecated, this functionality now living natively within Opal core. Update your Teams to be PatientLists Patient Lists are now driven by subclasses of opal.core.PatientList , so we will need to convert your Teams to be PatientLists. You may want to re-enable the Team admin while you do so - this is simple, by updating your application's admin.py : # yourapp/admin.py ... from opal.admin import TeamAdmin from opal.models import Team admin.site.register(Team, TeamAdmin) Patient lists are now declarative. For instance, to replicate the following team: We would convert that to: # yourapp/patient*lists.py from opal.core import patient_lists class RespiratoryList(patient_lists.TaggedPatientList): display_name = 'Respiratory' tag = 'respiratory' order = 4 schema = [models.Demographics, models.Treatment] The schema property will likely be available to you in your application's schema.py file - which is now obsolete. See the full patient list documentation for further details of the options available for Patient Lists. Form and Display templates. We may now be missing some form or display templates, as your application may be relying on templates previously in Opal. To discover which these are, run $ opal scaffold --dry-run You may either create templates by hand, or have Opal generate boilerplate templates for you by running $ opal scaffold . Modal templates already in your application will likely be referencing invalid paths to their Angular variables. You should update these to include the record name - for example: !-- Was -- {% input label= Drug model= editing.drug lookuplist= antimicrobial_list %} !-- Becomes -- {% input label= Drug model= editing.treatment.drug lookuplist= antimicrobial_list %} The Inpatient episode category The default Episode Category - Inpatient episodes has updated it's database identifier from inpatient to Inpatient . To update your episodes run : from opal.models import Episode for e in Episode.objects.filter(category='inpatient'): ... e.category='Inpatient' ... e.save() ... Any references to episode category in templates (for e.g. ng-hide) or controllers for logic will also require updates. Flow is now defined in JS Flow is no longer defined on the server side in python, but rather is a javascript service. See the documentation for information about setting up custom flows. At a minimum applications that use custom flows will have to implement their own flow service and reference it in their settings. 4.X - 5.x Migrations Before upgrading from 4.x to 5.x you should ensure that you have upgraded from South to Djangomigrations. $ rm yourapp/migrations/* $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp --fake-initial Opal Next you will need to upgrade the Opal version itself. How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. This will also update FFS and Django Axes as well as adding Python Dateutil. -e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal Migrations. Opal has fresh migrations in 0.5.x, which we should run. There are also changes to the base abstract model classes (to add created/updated timestamps) so you'll need to create fresh migrations for your own application. $ python manage.py migrate $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp At this stage you'll want to commit your new migrations, as well as any changes to your application's requirements file. Tags As of 0.5.5, old tags in Opal are stored directly on the Tagging model rather than via Djano Reversion. We can import those old tags by doing the following. $ python manage.py shell from opal.models import Tagging Tagging.import_from_reversion() Deployment The first time you deploy your upgraded application you'll need to run the following commands to upgrade your database: $ python manage.py migrate --fake-initial You'll also have to repeat the Tagging step once for each deployment.","title":"Upgrading"},{"location":"reference/upgrading/#upgrading-your-opal-application","text":"This document provides instructions for specific steps required to upgrading your Opal application to a later version where there are extra steps required.","title":"Upgrading Your Opal Application"},{"location":"reference/upgrading/#071-080","text":"","title":"0.7.1 -&gt; 0.8.0"},{"location":"reference/upgrading/#upgrading-opal","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.8.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal","title":"Upgrading Opal"},{"location":"reference/upgrading/#options","text":"Options are now an ex-API. Applications should convert to use either Referencedata (canonical terms for common data), or Metadata (App specific data you wish to pass into the front end).","title":"Options"},{"location":"reference/upgrading/#ui-components","text":"Those applications relying on Angular strap ui components (Typeahead, Popover, Tooltip, Datepicker, Timepicker) should convert their templates to use the Angular UI Boostrap equivalents, or the Opal templatetags. If you are simply using Opal templatetags from forms and not overriding these templates, then the transition should be seamless. Otherwise, searching your codebase for html files containing bs- and looking for angular strap components is a good start. Applications or plugins with javascript tests may need to update their includes to remove references to old library files. Full documentation of the markup and options for these components is found here","title":"UI Components"},{"location":"reference/upgrading/#extending-modal_basehtml","text":"We now have different base templates for modals, forms and two column modal forms (essentially a form with a side bar). The form templates add validation checks around the saving to catch any validation errors a form might through. They assume the existence of a form called 'form'. As part of this modal_base has been moved into a folder in templates called base_templates Rename any templates extending modal_base.html to extend the correct template in base_templates/ - modal_base.html or modal_form_base.html .","title":"extending modal_base.html"},{"location":"reference/upgrading/#add-episode-modal-url","text":"The add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash.","title":"Add episode modal url"},{"location":"reference/upgrading/#070-071","text":"","title":"0.7.0 -&gt; 0.7.1"},{"location":"reference/upgrading/#downstream-dependencies","text":"Opal 0.7.1 updates the expected version of Django Axes to 1.7.0 - you will wish to update this in your requirements.txt or similar accordingly.","title":"Downstream dependencies"},{"location":"reference/upgrading/#drf-authentication","text":"We highly recommend that applications explicitly set Django Rest Framework authentication classes in their settings.py . By default Opal now uses session and token auth, which will require a migration to install the DRF Token authentication app. INSTALLED_APPS = ( # .... 'rest_framework', 'rest_framework.authtoken', # ... ) REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.TokenAuthentication', 'rest_framework.authentication.SessionAuthentication', ) }","title":"DRF Authentication"},{"location":"reference/upgrading/#6x-7x","text":"","title":"6.x -&gt; 7.x"},{"location":"reference/upgrading/#upgrading-opal_1","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.7.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.7.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp","title":"Upgrading Opal"},{"location":"reference/upgrading/#breaking-changes","text":"Opal 0.7 contains a number of breaking changes.","title":"Breaking changes"},{"location":"reference/upgrading/#name-changes","text":"opal.models.Episode.category has been re-named category_name . If your application directly sets category, you will be required to update all instances where this happens. The /episode/:pk/ API has moved to /api/v0.1/episode/:pk/ so any code (typically javascript) code that directly saves to this API endpoint rather than using the Opal JS Episode services should work immediately when re-pointed at the new URL.","title":"Name changes"},{"location":"reference/upgrading/#moving-from-options-to-referencedata-and-metadata","text":"The signature of the EditItemCtrl has been updated - this modal controller no longer takes an options argument, rather it uses the new 0.7.x referencedata and metadata services. Applications that call EditItemCtrl directly should look to update the resolves option they were passing to $modal.open . (Alternatively, developers should consider refactoring to use the new recordEditor API.) The signatures of Flow enter and exit methods has changed to no longer accept options as a positional argument, and enter/exit controllers will no longer be initialized with access to options as a resovled provider. They will have access to either/both of referencedata and metadata so if your application includes custom flow controllers that use options you will need to refactor these to use the new x-data arguments instead. referencedata and metadata between them have all data previously in options, so the refactor here should be relatively painless.","title":"Moving from options to referencedata and metadata"},{"location":"reference/upgrading/#date-of-birth-fields-in-forms","text":"The partial partials/_date_of_birth_field.html has been removed and replaced with the {% date_of_birth_field %} templatetag in the forms library. You should update any forms to use this new tag.","title":"Date of birth fields in forms"},{"location":"reference/upgrading/#5x-6x","text":"","title":"5.x -&gt; 6.x"},{"location":"reference/upgrading/#upgrading-opal_2","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.6.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal","title":"Upgrading Opal"},{"location":"reference/upgrading/#changes-to-abstract-models","text":"If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.6.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp You should note that as of Opal 0.6.x Demographics now splits names into first, surname, middle name and title. The previous name field will be converted to be first_name . Strategies for updating your data to use the appropriate fields will vary from application to application, but one good such strategy is to use a data migration such as the one done here .","title":"Changes to abstract models"},{"location":"reference/upgrading/#update-settings","text":"Many of the default Opal templates now assume that the 'opal.context_processors.models' Context Processor is available - you should add that to the TEMPLATE_CONTEXT_PROCESSORS setting in your application's settings.py The default date formats in Opal have changed - and so you should update your DATE_X settings to match: DATE_FORMAT = 'd/m/Y' DATE_INPUT_FORMATS = ['%d/%m/%Y'] DATETIME_FORMAT = 'd/m/Y H:i:s' DATETIME_INPUT_FORMATS = ['%d/%m/%Y %H:%M:%S']","title":"Update settings"},{"location":"reference/upgrading/#upgrade-plugins","text":"A number of Opal plugins have new releases to work with the changes in Opal 0.6.x opal-referral - Upgrade to 0.1.4 opal-wardround - Upgrade to 0.6.0 opal-observations - Upgrade to 0.1.2 opal-dischargesummary - Upgrade to 0.2.0 opal-dashboard - Upgrade to 0.1.3 Meanwhile the opal-taskrunner plugin has now been deprecated, this functionality now living natively within Opal core.","title":"Upgrade plugins"},{"location":"reference/upgrading/#update-your-teams-to-be-patientlists","text":"Patient Lists are now driven by subclasses of opal.core.PatientList , so we will need to convert your Teams to be PatientLists. You may want to re-enable the Team admin while you do so - this is simple, by updating your application's admin.py : # yourapp/admin.py ... from opal.admin import TeamAdmin from opal.models import Team admin.site.register(Team, TeamAdmin) Patient lists are now declarative. For instance, to replicate the following team: We would convert that to: # yourapp/patient*lists.py from opal.core import patient_lists class RespiratoryList(patient_lists.TaggedPatientList): display_name = 'Respiratory' tag = 'respiratory' order = 4 schema = [models.Demographics, models.Treatment] The schema property will likely be available to you in your application's schema.py file - which is now obsolete. See the full patient list documentation for further details of the options available for Patient Lists.","title":"Update your Teams to be PatientLists"},{"location":"reference/upgrading/#form-and-display-templates","text":"We may now be missing some form or display templates, as your application may be relying on templates previously in Opal. To discover which these are, run $ opal scaffold --dry-run You may either create templates by hand, or have Opal generate boilerplate templates for you by running $ opal scaffold . Modal templates already in your application will likely be referencing invalid paths to their Angular variables. You should update these to include the record name - for example: !-- Was -- {% input label= Drug model= editing.drug lookuplist= antimicrobial_list %} !-- Becomes -- {% input label= Drug model= editing.treatment.drug lookuplist= antimicrobial_list %}","title":"Form and Display templates."},{"location":"reference/upgrading/#the-inpatient-episode-category","text":"The default Episode Category - Inpatient episodes has updated it's database identifier from inpatient to Inpatient . To update your episodes run : from opal.models import Episode for e in Episode.objects.filter(category='inpatient'): ... e.category='Inpatient' ... e.save() ... Any references to episode category in templates (for e.g. ng-hide) or controllers for logic will also require updates.","title":"The Inpatient episode category"},{"location":"reference/upgrading/#flow-is-now-defined-in-js","text":"Flow is no longer defined on the server side in python, but rather is a javascript service. See the documentation for information about setting up custom flows. At a minimum applications that use custom flows will have to implement their own flow service and reference it in their settings.","title":"Flow is now defined in JS"},{"location":"reference/upgrading/#4x-5x","text":"","title":"4.X -&gt; 5.x"},{"location":"reference/upgrading/#migrations","text":"Before upgrading from 4.x to 5.x you should ensure that you have upgraded from South to Djangomigrations. $ rm yourapp/migrations/* $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp --fake-initial","title":"Migrations"},{"location":"reference/upgrading/#opal","text":"Next you will need to upgrade the Opal version itself. How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. This will also update FFS and Django Axes as well as adding Python Dateutil. -e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal","title":"Opal"},{"location":"reference/upgrading/#migrations_1","text":"Opal has fresh migrations in 0.5.x, which we should run. There are also changes to the base abstract model classes (to add created/updated timestamps) so you'll need to create fresh migrations for your own application. $ python manage.py migrate $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp At this stage you'll want to commit your new migrations, as well as any changes to your application's requirements file.","title":"Migrations."},{"location":"reference/upgrading/#tags","text":"As of 0.5.5, old tags in Opal are stored directly on the Tagging model rather than via Djano Reversion. We can import those old tags by doing the following. $ python manage.py shell from opal.models import Tagging Tagging.import_from_reversion()","title":"Tags"},{"location":"reference/upgrading/#deployment","text":"The first time you deploy your upgraded application you'll need to run the following commands to upgrade your database: $ python manage.py migrate --fake-initial You'll also have to repeat the Tagging step once for each deployment.","title":"Deployment"}]}