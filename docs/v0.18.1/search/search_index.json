{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Opal Documentation Opal is a full stack framework that makes building digital tools for health care easy. Opal builds deep clinical domain specific functionality on top of Django , Angular and Bootstrap to help developers quickly build easy to maintain, robust clinical applications. This is the developer documentation . Opal is an entirely open source , open governance product, as are the wide library of plugins. First Steps If you're new to Opal, then you'll want to take a look at the Installation instructions , and then maybe take the tutorial . Full documentation While Topic guides are available for many key areas of Opal, the Detailed reference material is a work in progress. If you find any issues or missing areas of this documentation, please do raise it with the team on the Github issue tracker .","title":"Home"},{"location":"#opal-documentation","text":"Opal is a full stack framework that makes building digital tools for health care easy. Opal builds deep clinical domain specific functionality on top of Django , Angular and Bootstrap to help developers quickly build easy to maintain, robust clinical applications. This is the developer documentation . Opal is an entirely open source , open governance product, as are the wide library of plugins.","title":"Opal Documentation"},{"location":"#first-steps","text":"If you're new to Opal, then you'll want to take a look at the Installation instructions , and then maybe take the tutorial .","title":"First Steps"},{"location":"#full-documentation","text":"While Topic guides are available for many key areas of Opal, the Detailed reference material is a work in progress. If you find any issues or missing areas of this documentation, please do raise it with the team on the Github issue tracker .","title":"Full documentation"},{"location":"installation/","text":"Installing Opal Installation should be simple. Step 1: The Prerequisites Before you install Opal, you'll need to make sure that you have Python and pip installed on your system. Let's just check that you do: $ python --version Python 3.7.2 $ pip --version pip 19.0.3 Step 2: Use Pip Now we can install Opal using pip: $ pip install opal You should now have the opal commandline tools installed. Let's just check that you do: $ opal --version Opal {{ config.extra.version }} Step 3: There is no step 3. Maybe make yourself some tea then try the Tutorial instead ?","title":"Installation"},{"location":"installation/#installing-opal","text":"Installation should be simple.","title":"Installing Opal"},{"location":"installation/#step-1-the-prerequisites","text":"Before you install Opal, you'll need to make sure that you have Python and pip installed on your system. Let's just check that you do: $ python --version Python 3.7.2 $ pip --version pip 19.0.3","title":"Step 1: The Prerequisites"},{"location":"installation/#step-2-use-pip","text":"Now we can install Opal using pip: $ pip install opal You should now have the opal commandline tools installed. Let's just check that you do: $ opal --version Opal {{ config.extra.version }}","title":"Step 2: Use Pip"},{"location":"installation/#step-3-there-is-no-step-3","text":"Maybe make yourself some tea then try the Tutorial instead ?","title":"Step 3: There is no step 3."},{"location":"overview/","text":"","title":"Overview"},{"location":"tutorial/","text":"Writing a clinical service with Opal This tutorial will walk you through the creation of a new Opal service. The application we're going to be building will help clinical users to manage the patients on a ward in a hospital. As a Doctor I want to know what's going on with the patients under my care So that I can treat them effectively and safely. Bootstrapping a new project We assume that you've already Installed Opal . You can tell which version of opal is installed by running this command $ opal --version At the start a new project, Opal will bootstrap the initial project structure, including a Django project, some core datamodels (complete with JSON APIs) and a general application structure. From the commandline: $ opal startproject mynewapp This will create a mynewapp directory where your new project lives. Let's have a look at what that created for you: mynewapp/ # Your project directory LICENSE # A dummy LICENSE file Procfile # A procfile ready for deployment to e.g. Heroku README.md manage.py # Django's manage.py script requirements.txt # Requirements file ready for your project data/ # A dummy directory for fixtures lookuplists/ # A dummy directory for reference data mynewapp/ # The actual python package for your application __init__.py models.py # Data models for your application settings.py # Helpfully tweaked Django settings tests.py # Dummy unittests urls.py # Django Urlconf wsgi.py patient_lists.py # these create the [lists](guides/list_views.md) for you application assets/ # Your static files directory templates/ # Your template directory migrations/ # Your Database migrations directory opal.sqlite # The Sqlite development database Test it out The scaffolding step has generated you a working project - so let's check that out cd mynewapp python manage.py runserver If you now visit http://localhost:8000 in your browser, you should see the standard login screen: The scaffolding step created you a superuser, so try logging in with the credentials: Username: super Password: super1 When you log in you should be presented with a welcome screen that shows you the three areas that are enabled by default - team lists, search and the admin area. Opal applications are a collection of single page Angular apps that talk to the Django server-side layer via JSON APIs. The team lists and search options here are two examples of front-end Angular single page apps. Team lists Most clinical services will need at some stage to generate a list of patients - so Opal provides this functionality enabled by default. The list view is a spreadsheet-style list of patients - try navigating to the list view and adding a patient with the add patient button. episode Each column contains a different type of information about a patient, while each row represents one patient. Strictly speaking each row is an episode of care for a patient - but we'll come to that in a second. The columns you see initially are just a few of the standard clinical models that come with Opal - for instance the Diagnosis model in your new application inherits from a model that looks a lot like this: class Diagnosis(EpisodeSubrecord): condition = ForeignKeyOrFreeText(Condition) provisional = models.BooleanField(default=False) details = models.CharField(max_length=255, blank=True) date_of_diagnosis = models.DateField(blank=True, null=True) class Meta: abstract = True Reference data You will notice that the condition field has a custom field type - ForeignKeyOrFreeText . This is a custom field type that we use with Opal when we want to use a Lookup List . Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. That means that we can ensure that we record high quality coded data, while allowing users an easy way to enter unusual edge cases. Opal has a referencedata package which is installed by default for new applications. To see them in action, try adding a new diagnosis to your patient. As you start to type in the condition field, you'll see that the conditions we just imported appear as suggestions: You can add your own Lookup Lists to your application. For more details consult the Reference Data guide . Add your own data models So far we've begun to get a sense of the batteries-included parts of Opal, but before long, you're going to need to create models for your own needs. Most Opal models are Subrecords - they relate to either a patient, or an episode (an episode is for example, an admission to hospital). Let's see how that works by creating a TODO list model that is assigned to episodes of care. In your mynewapp/models.py : class TODOItem(models.EpisodeSubrecord): job = fields.CharField(max_length=200) due_date = fields.DateField(blank=True, null=True) details = fields.TextField(blank=True, null=True) completed = fields.BooleanField(default=False) This is simply a Django model, apart from the parent class models.EpisodeSubrecord which provides us with some extra functionality: A relationship to an episode, linked to a patient JSON APIs for creating, retrieving and updating it Ensuring that the Opal Angular layer knows it exists Some metadata fields, like created, updated, created_by, updated_by Next, we're going to let Opal take care of the boilerplate that we'll need to use this model in our application. From the commandline: python manage.py scaffold mynewapp Let's take a look at what that did: It created a Django migration It ran that migration for you It created a detail template mynewapp/templates/records/todo_item.html It created a form template mynewapp/templates/forms/todo_item_forml.html Detail template The default detail template simply displays each field on a new line: span ng-show=\"item.job\" [[ item.job ]] br / /span span ng-show=\"item.due_date\" [[ item.due_date | displayDate ]] br / /span span ng-show=\"item.details\" [[ item.details ]] br / /span span ng-show=\"item.completed\" [[ item.completed ]] br / /span Form template The default form template will display each field on a new line, with some basic appropriate form field types set. It uses the Opal form helpers templatetag library. {% load forms %} {% input field= TODOItem.job %} {% datepicker field= TODOItem.due_date %} {% textarea field= TODOItem.details %} {% checkbox field= TODOItem.completed %} Adding TODOs to our Team Lists Now let's add our TODO list model as a column in the Spreadsheet-like list view. Patient Lists in Opal are subclasses of opal.core.patient_lists.PatientList , and they live in patient_lists.py files of our Django apps. Technically these can live anywhere you like - although if you put them in other places you're responsible for making sure that they're imported at startup. Opal guarantees to autodiscover lists in `app.patient_list` modules. You can see the basic list that the Opal application scaffold created for you in yournewapp/patient_lists.py . class AllPatientsList(core.patient_lists.PatientList): display_name = 'All Patients' schema = [ models.Demographics, models.Diagnosis, models.Treatment ] def get_queryset(self): return Episode.objects.all() The columns for lists are set in the schema property of the PatientList class. To add our TODO model to the list, just add the model to the schema: schema = [ models.Demographics, models.Diagnosis, models.Treatment, models.TODOItem ] Refresh the lists page in your browser, and you'll see your new column on the end - add a TODO item, noting how we automatically get appropriate form types like datepickers and checkboxes. You can edit any entry in the list view by double clicking on it. Tweaking the default scaffolding The scaffolding templates are only really supposed to get you started - you'll often need to tweak the templates they generate with whatever logic makes sense for your application. Set an Icon for your model You'll notice that your new column is the only one without an icon - we set the icon by adding the following property to your TODOItem class: _icon = 'fa fa-th-list' Some other batteries included Let's take a look at some of the other core functionality that we now have out of the box: Search By default, we also enable the search module, which allows you to search by patient name or unique identifier: Detail views We also have a detail view for our patients, which you can access via search results. This view will typically allow for a more detailed display and editing of all the events comprising a patient's care than is available on the list page. JSON APIs Opal automatically creates self-documenting JSON APIs for your interacting with the data in your application. You can inspect these APIs interactively at the url: http://localhost:8000/api/v0.1/ What next? This is just a glimpse at the full range of functionality that comes with Opal - there is much more to discover in the Topic Guides .","title":"Tutorial"},{"location":"tutorial/#writing-a-clinical-service-with-opal","text":"This tutorial will walk you through the creation of a new Opal service. The application we're going to be building will help clinical users to manage the patients on a ward in a hospital. As a Doctor I want to know what's going on with the patients under my care So that I can treat them effectively and safely.","title":"Writing a clinical service with Opal"},{"location":"tutorial/#bootstrapping-a-new-project","text":"We assume that you've already Installed Opal . You can tell which version of opal is installed by running this command $ opal --version At the start a new project, Opal will bootstrap the initial project structure, including a Django project, some core datamodels (complete with JSON APIs) and a general application structure. From the commandline: $ opal startproject mynewapp This will create a mynewapp directory where your new project lives. Let's have a look at what that created for you: mynewapp/ # Your project directory LICENSE # A dummy LICENSE file Procfile # A procfile ready for deployment to e.g. Heroku README.md manage.py # Django's manage.py script requirements.txt # Requirements file ready for your project data/ # A dummy directory for fixtures lookuplists/ # A dummy directory for reference data mynewapp/ # The actual python package for your application __init__.py models.py # Data models for your application settings.py # Helpfully tweaked Django settings tests.py # Dummy unittests urls.py # Django Urlconf wsgi.py patient_lists.py # these create the [lists](guides/list_views.md) for you application assets/ # Your static files directory templates/ # Your template directory migrations/ # Your Database migrations directory opal.sqlite # The Sqlite development database","title":"Bootstrapping a new project"},{"location":"tutorial/#test-it-out","text":"The scaffolding step has generated you a working project - so let's check that out cd mynewapp python manage.py runserver If you now visit http://localhost:8000 in your browser, you should see the standard login screen: The scaffolding step created you a superuser, so try logging in with the credentials: Username: super Password: super1 When you log in you should be presented with a welcome screen that shows you the three areas that are enabled by default - team lists, search and the admin area. Opal applications are a collection of single page Angular apps that talk to the Django server-side layer via JSON APIs. The team lists and search options here are two examples of front-end Angular single page apps.","title":"Test it out"},{"location":"tutorial/#team-lists","text":"Most clinical services will need at some stage to generate a list of patients - so Opal provides this functionality enabled by default. The list view is a spreadsheet-style list of patients - try navigating to the list view and adding a patient with the add patient button. episode Each column contains a different type of information about a patient, while each row represents one patient. Strictly speaking each row is an episode of care for a patient - but we'll come to that in a second. The columns you see initially are just a few of the standard clinical models that come with Opal - for instance the Diagnosis model in your new application inherits from a model that looks a lot like this: class Diagnosis(EpisodeSubrecord): condition = ForeignKeyOrFreeText(Condition) provisional = models.BooleanField(default=False) details = models.CharField(max_length=255, blank=True) date_of_diagnosis = models.DateField(blank=True, null=True) class Meta: abstract = True","title":"Team lists"},{"location":"tutorial/#reference-data","text":"You will notice that the condition field has a custom field type - ForeignKeyOrFreeText . This is a custom field type that we use with Opal when we want to use a Lookup List . Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. That means that we can ensure that we record high quality coded data, while allowing users an easy way to enter unusual edge cases. Opal has a referencedata package which is installed by default for new applications. To see them in action, try adding a new diagnosis to your patient. As you start to type in the condition field, you'll see that the conditions we just imported appear as suggestions: You can add your own Lookup Lists to your application. For more details consult the Reference Data guide .","title":"Reference data"},{"location":"tutorial/#add-your-own-data-models","text":"So far we've begun to get a sense of the batteries-included parts of Opal, but before long, you're going to need to create models for your own needs. Most Opal models are Subrecords - they relate to either a patient, or an episode (an episode is for example, an admission to hospital). Let's see how that works by creating a TODO list model that is assigned to episodes of care. In your mynewapp/models.py : class TODOItem(models.EpisodeSubrecord): job = fields.CharField(max_length=200) due_date = fields.DateField(blank=True, null=True) details = fields.TextField(blank=True, null=True) completed = fields.BooleanField(default=False) This is simply a Django model, apart from the parent class models.EpisodeSubrecord which provides us with some extra functionality: A relationship to an episode, linked to a patient JSON APIs for creating, retrieving and updating it Ensuring that the Opal Angular layer knows it exists Some metadata fields, like created, updated, created_by, updated_by Next, we're going to let Opal take care of the boilerplate that we'll need to use this model in our application. From the commandline: python manage.py scaffold mynewapp Let's take a look at what that did: It created a Django migration It ran that migration for you It created a detail template mynewapp/templates/records/todo_item.html It created a form template mynewapp/templates/forms/todo_item_forml.html","title":"Add your own data models"},{"location":"tutorial/#detail-template","text":"The default detail template simply displays each field on a new line: span ng-show=\"item.job\" [[ item.job ]] br / /span span ng-show=\"item.due_date\" [[ item.due_date | displayDate ]] br / /span span ng-show=\"item.details\" [[ item.details ]] br / /span span ng-show=\"item.completed\" [[ item.completed ]] br / /span","title":"Detail template"},{"location":"tutorial/#form-template","text":"The default form template will display each field on a new line, with some basic appropriate form field types set. It uses the Opal form helpers templatetag library. {% load forms %} {% input field= TODOItem.job %} {% datepicker field= TODOItem.due_date %} {% textarea field= TODOItem.details %} {% checkbox field= TODOItem.completed %}","title":"Form template"},{"location":"tutorial/#adding-todos-to-our-team-lists","text":"Now let's add our TODO list model as a column in the Spreadsheet-like list view. Patient Lists in Opal are subclasses of opal.core.patient_lists.PatientList , and they live in patient_lists.py files of our Django apps. Technically these can live anywhere you like - although if you put them in other places you're responsible for making sure that they're imported at startup. Opal guarantees to autodiscover lists in `app.patient_list` modules. You can see the basic list that the Opal application scaffold created for you in yournewapp/patient_lists.py . class AllPatientsList(core.patient_lists.PatientList): display_name = 'All Patients' schema = [ models.Demographics, models.Diagnosis, models.Treatment ] def get_queryset(self): return Episode.objects.all() The columns for lists are set in the schema property of the PatientList class. To add our TODO model to the list, just add the model to the schema: schema = [ models.Demographics, models.Diagnosis, models.Treatment, models.TODOItem ] Refresh the lists page in your browser, and you'll see your new column on the end - add a TODO item, noting how we automatically get appropriate form types like datepickers and checkboxes. You can edit any entry in the list view by double clicking on it.","title":"Adding TODOs to our Team Lists"},{"location":"tutorial/#tweaking-the-default-scaffolding","text":"The scaffolding templates are only really supposed to get you started - you'll often need to tweak the templates they generate with whatever logic makes sense for your application.","title":"Tweaking the default scaffolding"},{"location":"tutorial/#set-an-icon-for-your-model","text":"You'll notice that your new column is the only one without an icon - we set the icon by adding the following property to your TODOItem class: _icon = 'fa fa-th-list'","title":"Set an Icon for your model"},{"location":"tutorial/#some-other-batteries-included","text":"Let's take a look at some of the other core functionality that we now have out of the box:","title":"Some other batteries included"},{"location":"tutorial/#search","text":"By default, we also enable the search module, which allows you to search by patient name or unique identifier:","title":"Search"},{"location":"tutorial/#detail-views","text":"We also have a detail view for our patients, which you can access via search results. This view will typically allow for a more detailed display and editing of all the events comprising a patient's care than is available on the list page.","title":"Detail views"},{"location":"tutorial/#json-apis","text":"Opal automatically creates self-documenting JSON APIs for your interacting with the data in your application. You can inspect these APIs interactively at the url: http://localhost:8000/api/v0.1/","title":"JSON APIs"},{"location":"tutorial/#what-next","text":"This is just a glimpse at the full range of functionality that comes with Opal - there is much more to discover in the Topic Guides .","title":"What next?"},{"location":"guides/archetypes/","text":"Core Clinical Archetypes Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Common Metadata fields All subrecords will contain the following fields, which are not repeated individually Field Type Length created_by FK User ID created Date updated_by FK User ID update Date The details of each individual archetype are set out below: Patient Subrecords Demographics Field Type Length hospital_number Char 255 nhs_number Char 255 date_of_birth Date place_of_birth FKorFT(Destination) ethnicity FKorFT(Ethnicity) surname Char 255 first_name Char 255 middle_name Char 255 sex FKorFT(Gender) Allergies Field Type Length drug FKorFT(Drug) provisional Boolean details Char 255 Episode Subrecords Location Field Type Length category Char 255 hospital Char 255 ward Char 255 bed Char 255 Treatment Field Type Length drug FKorFT(Drug) dose Char 255 route FKorFT(Drugroute) start_date Date end_date Date frequency FKorFT(Drugfreq) Diagnosis Field Type condition FKorFT(Condition) provisional Boolean details Text date_of_diagnosis Date PastMedicalHistory Field Type Length condition FKorFT(Condition) year Char 4 details Char 255 SymptomComplex Field Type Length symptoms ManyToMany(Symptom) duration Char 255 details Text ReferralRoute Field Type Length internal NullBoolean referral_organisation FKorFT(ReferralOrganisation) referral_name Char 255 date_of_referral Date referral_team FKorFT(Speciality) referral_type FKorFT(ReferralType) PatientConsultation Field Type Length when Datetime initials Char 255 reason_for_interaction FKorFT(Patient_consultation_reason_for_interaction) discussion Text","title":"Archetypes"},{"location":"guides/archetypes/#core-clinical-archetypes","text":"Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application.","title":"Core Clinical Archetypes"},{"location":"guides/archetypes/#common-metadata-fields","text":"All subrecords will contain the following fields, which are not repeated individually Field Type Length created_by FK User ID created Date updated_by FK User ID update Date The details of each individual archetype are set out below:","title":"Common Metadata fields"},{"location":"guides/archetypes/#patient-subrecords","text":"","title":"Patient Subrecords"},{"location":"guides/archetypes/#demographics","text":"Field Type Length hospital_number Char 255 nhs_number Char 255 date_of_birth Date place_of_birth FKorFT(Destination) ethnicity FKorFT(Ethnicity) surname Char 255 first_name Char 255 middle_name Char 255 sex FKorFT(Gender)","title":"Demographics"},{"location":"guides/archetypes/#allergies","text":"Field Type Length drug FKorFT(Drug) provisional Boolean details Char 255","title":"Allergies"},{"location":"guides/archetypes/#episode-subrecords","text":"","title":"Episode Subrecords"},{"location":"guides/archetypes/#location","text":"Field Type Length category Char 255 hospital Char 255 ward Char 255 bed Char 255","title":"Location"},{"location":"guides/archetypes/#treatment","text":"Field Type Length drug FKorFT(Drug) dose Char 255 route FKorFT(Drugroute) start_date Date end_date Date frequency FKorFT(Drugfreq)","title":"Treatment"},{"location":"guides/archetypes/#diagnosis","text":"Field Type condition FKorFT(Condition) provisional Boolean details Text date_of_diagnosis Date","title":"Diagnosis"},{"location":"guides/archetypes/#pastmedicalhistory","text":"Field Type Length condition FKorFT(Condition) year Char 4 details Char 255","title":"PastMedicalHistory"},{"location":"guides/archetypes/#symptomcomplex","text":"Field Type Length symptoms ManyToMany(Symptom) duration Char 255 details Text","title":"SymptomComplex"},{"location":"guides/archetypes/#referralroute","text":"Field Type Length internal NullBoolean referral_organisation FKorFT(ReferralOrganisation) referral_name Char 255 date_of_referral Date referral_team FKorFT(Speciality) referral_type FKorFT(ReferralType)","title":"ReferralRoute"},{"location":"guides/archetypes/#patientconsultation","text":"Field Type Length when Datetime initials Char 255 reason_for_interaction FKorFT(Patient_consultation_reason_for_interaction) discussion Text","title":"PatientConsultation"},{"location":"guides/command_line_tool/","text":"The Opal Command line tool Opal ships with a helpful command line tool that helps with administrative tasks. The opal script should be on your system path if you installed Opal via setup.py or pip. You can check whether it is available by running this command: $ opal -v startproject name Creates a new Opal project. This creates boilerplate and a default configuration for your new project, including creating a new underlying Django project, updating default settings to be compatible with Opal, creating directories and code boilerplate, and running initial migrations. startplugin name Creates boilerplate code, and directory structures for a new Opal plugin. test what Run our tests suites. Defaults to running both Python and Javascript tests. If specified, will only run one specific kind of test. $ opal test py $ opal test js When running Python tests, the -t or --test option allows the user to specify a single test module, case or method to run. $ opal test py -t opal.tests.test_models The --failfast option will end the test run on the first failing test rather than continuing with the entire run. checkout Ensure that all of our application plugins and packages are on the correct branch. This is particularly useful when working on Opal itself, or when you have multiple projects that use different versions of Opal or plugins. It will assume that github based requirements will be installed in development via python setup.py develop . This command will parse your project's requirements.txt , and then ensure that any Github sources are checked out locally to the branch specified therein.","title":"Command Line tool"},{"location":"guides/command_line_tool/#the-opal-command-line-tool","text":"Opal ships with a helpful command line tool that helps with administrative tasks. The opal script should be on your system path if you installed Opal via setup.py or pip. You can check whether it is available by running this command: $ opal -v","title":"The Opal Command line tool"},{"location":"guides/command_line_tool/#startproject-name","text":"Creates a new Opal project. This creates boilerplate and a default configuration for your new project, including creating a new underlying Django project, updating default settings to be compatible with Opal, creating directories and code boilerplate, and running initial migrations.","title":"startproject &lt;name&gt;"},{"location":"guides/command_line_tool/#startplugin-name","text":"Creates boilerplate code, and directory structures for a new Opal plugin.","title":"startplugin &lt;name&gt;"},{"location":"guides/command_line_tool/#test-what","text":"Run our tests suites. Defaults to running both Python and Javascript tests. If specified, will only run one specific kind of test. $ opal test py $ opal test js When running Python tests, the -t or --test option allows the user to specify a single test module, case or method to run. $ opal test py -t opal.tests.test_models The --failfast option will end the test run on the first failing test rather than continuing with the entire run.","title":"test &lt;what&gt;"},{"location":"guides/command_line_tool/#checkout","text":"Ensure that all of our application plugins and packages are on the correct branch. This is particularly useful when working on Opal itself, or when you have multiple projects that use different versions of Opal or plugins. It will assume that github based requirements will be installed in development via python setup.py develop . This command will parse your project's requirements.txt , and then ensure that any Github sources are checked out locally to the branch specified therein.","title":"checkout"},{"location":"guides/components_overview/","text":"Components of an Opal application Opal applications will typically be made up of several types of components. Opal The core Opal framework provides you with a range of commonly required elements of clinical applications. It contains a core data model for persisting clinical information, as well core clinical archetypes out of the box that build on many years of collaboratively modelling clinical concepts by medical domain experts. Opal also makes it easy to integrate standard clinical reference data into your application - things like medical diagnoses, tests, drugs et cetera. Some common functional components end up in to most clinical applications, and many of these come with Opal as \"batteries included\" - immediately available modular features that can be simply re-used without having to reinvent the wheel. For example: Patient lists Search Authentication and Permissions Forms for data entry JSON based REST APIs for all of your models ... and many more ... Plugins Opal plugins are intended to provide high quality generic, composable, re-usable chunks of functionality that can be \"dropped in\" to an application. For example, installing the Dashboards plugin allows you to easily create clinical dashboards within your application. The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. Plugins have a rich plugin API they can hook into to, and many examples can be found by inspecting the source of existing plugins . Applications An application is the collection of configuration and bespoke functionality that would be provided to an individual institution - it's the thing that you would look to deploy. Example applications include elCID - a for managing infection patients, or Opal-Renal - an MDT handover tool for Renal wards. A hospital might have multiple clinical services running on one application, or multiple applications that integrate with one another. Opinionated but Pluggable Opal is an opinionated framework. It expects the developer to structure code in a certain way. Opal expects features to be implemented as single page Angular.js applications, with the server mostly figuring as an API endpoint for reading and writing data. That said, the technology stack of Django, Angular Bootstrap allows the confident user a huge degree of flexibility when writing their own applications and plugins. For instance, there is nothing to stop a developer from implementing a part of the functionality in some other Javascript framework, and simply calling the JSON API . However, by doing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera. While possible, this approach is not likely to be officially supported in the medium term.","title":"Component Overview"},{"location":"guides/components_overview/#components-of-an-opal-application","text":"Opal applications will typically be made up of several types of components.","title":"Components of an Opal application"},{"location":"guides/components_overview/#opal","text":"The core Opal framework provides you with a range of commonly required elements of clinical applications. It contains a core data model for persisting clinical information, as well core clinical archetypes out of the box that build on many years of collaboratively modelling clinical concepts by medical domain experts. Opal also makes it easy to integrate standard clinical reference data into your application - things like medical diagnoses, tests, drugs et cetera. Some common functional components end up in to most clinical applications, and many of these come with Opal as \"batteries included\" - immediately available modular features that can be simply re-used without having to reinvent the wheel. For example: Patient lists Search Authentication and Permissions Forms for data entry JSON based REST APIs for all of your models ... and many more ...","title":"Opal"},{"location":"guides/components_overview/#plugins","text":"Opal plugins are intended to provide high quality generic, composable, re-usable chunks of functionality that can be \"dropped in\" to an application. For example, installing the Dashboards plugin allows you to easily create clinical dashboards within your application. The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. Plugins have a rich plugin API they can hook into to, and many examples can be found by inspecting the source of existing plugins .","title":"Plugins"},{"location":"guides/components_overview/#applications","text":"An application is the collection of configuration and bespoke functionality that would be provided to an individual institution - it's the thing that you would look to deploy. Example applications include elCID - a for managing infection patients, or Opal-Renal - an MDT handover tool for Renal wards. A hospital might have multiple clinical services running on one application, or multiple applications that integrate with one another.","title":"Applications"},{"location":"guides/components_overview/#opinionated-but-pluggable","text":"Opal is an opinionated framework. It expects the developer to structure code in a certain way. Opal expects features to be implemented as single page Angular.js applications, with the server mostly figuring as an API endpoint for reading and writing data. That said, the technology stack of Django, Angular Bootstrap allows the confident user a huge degree of flexibility when writing their own applications and plugins. For instance, there is nothing to stop a developer from implementing a part of the functionality in some other Javascript framework, and simply calling the JSON API . However, by doing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera. While possible, this approach is not likely to be officially supported in the medium term.","title":"Opinionated but Pluggable"},{"location":"guides/context_processors/","text":"Default context processors Context processors are part of the Django template language. In Opal we use this to give all templates access to some generic information about the internals of Opal applications. Settings All Opal settings are copied into the context of the template. Models All subrecords (the underlying clinical models of Opal) are copied into the context of the template context and can be accessed from the variable models , e.g. the Allergies subrecord can be referred to by {{ models.Allergy }} Pathways Pathways are copied in to the context of the template and can be accessed from the variable pathways . For an example Pathway you would be able to access attributes of a Pathway thus: {{ pathways.MyPathway.get_display_name }} It is important to note that since the context processor is applied after the request context, this can lead to the context processor over-writing elements of context data. For further information on this see the Django documentation.","title":"Context Processors"},{"location":"guides/context_processors/#default-context-processors","text":"Context processors are part of the Django template language. In Opal we use this to give all templates access to some generic information about the internals of Opal applications.","title":"Default context processors"},{"location":"guides/context_processors/#settings","text":"All Opal settings are copied into the context of the template.","title":"Settings"},{"location":"guides/context_processors/#models","text":"All subrecords (the underlying clinical models of Opal) are copied into the context of the template context and can be accessed from the variable models , e.g. the Allergies subrecord can be referred to by {{ models.Allergy }}","title":"Models"},{"location":"guides/context_processors/#pathways","text":"Pathways are copied in to the context of the template and can be accessed from the variable pathways . For an example Pathway you would be able to access attributes of a Pathway thus: {{ pathways.MyPathway.get_display_name }} It is important to note that since the context processor is applied after the request context, this can lead to the context processor over-writing elements of context data. For further information on this see the Django documentation.","title":"Pathways"},{"location":"guides/contributing/","text":"Contributing to Opal Opal is developed as an open source project, and as such we welcome contributions in the form of bug reports, documentation, and code. Reporting bugs If you find what looks like a bug, add an issue to the Github Issue tracker . Unclear documentation, unexpected error messages definitely count as bugs - feel free to raise issues about them. Please try to include steps to reproduce your bug in the issue - it helps us enormously to find and fix it. Contributing enhancements or fixes If you want to contribute an enhancement or fix to Opal: Fork the project on Github Make a feature branch from the latest default branch (this will be named vX.Y.Z and set as the default branch on Github) Make your changes Make sure that our test suite still runs, and that your changes are covered by tests (running opal test -c in the root directory of the repository will run both python and javascript tests, as well as generate HTML code coverage reports.) Update the Opal documentation to be Commit the changes and push to your fork Submit a pull request to Opal At this stage, we will assign someone to review your changes before merging. We might ask you to make some changes to your pull request before merging, but in general, we are biased towards accepting contributions from the community. That said, we won't merge your pull request if: It doesn't come with tests It doesn't update the relevant documentation Don't worry though - we're happy to guide new contributors through this process. If you want to discuss ideas you have for changes before making them, you can always propose enhancements on the Github Issue tracker or post questions and open discussions on the mailing list . Issues suitable for new contributors Issues in the github issue tracker labelled 'easy' have been identified as particularly appropriate for new contributors.","title":"Contributing"},{"location":"guides/contributing/#contributing-to-opal","text":"Opal is developed as an open source project, and as such we welcome contributions in the form of bug reports, documentation, and code.","title":"Contributing to Opal"},{"location":"guides/contributing/#reporting-bugs","text":"If you find what looks like a bug, add an issue to the Github Issue tracker . Unclear documentation, unexpected error messages definitely count as bugs - feel free to raise issues about them. Please try to include steps to reproduce your bug in the issue - it helps us enormously to find and fix it.","title":"Reporting bugs"},{"location":"guides/contributing/#contributing-enhancements-or-fixes","text":"If you want to contribute an enhancement or fix to Opal: Fork the project on Github Make a feature branch from the latest default branch (this will be named vX.Y.Z and set as the default branch on Github) Make your changes Make sure that our test suite still runs, and that your changes are covered by tests (running opal test -c in the root directory of the repository will run both python and javascript tests, as well as generate HTML code coverage reports.) Update the Opal documentation to be Commit the changes and push to your fork Submit a pull request to Opal At this stage, we will assign someone to review your changes before merging. We might ask you to make some changes to your pull request before merging, but in general, we are biased towards accepting contributions from the community. That said, we won't merge your pull request if: It doesn't come with tests It doesn't update the relevant documentation Don't worry though - we're happy to guide new contributors through this process. If you want to discuss ideas you have for changes before making them, you can always propose enhancements on the Github Issue tracker or post questions and open discussions on the mailing list .","title":"Contributing enhancements or fixes"},{"location":"guides/contributing/#issues-suitable-for-new-contributors","text":"Issues in the github issue tracker labelled 'easy' have been identified as particularly appropriate for new contributors.","title":"Issues suitable for new contributors"},{"location":"guides/datamodel/","text":"The Opal Data model The Opal data model allows for patients to have multiple sequential or concurrent Episodes of care . Some information is linked to an Episode , some is linked to a Patient . Patients A Patient may have many Episodes . An Episode is something like an Inpatient admission, a telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic. Applications or plugins may define their own Episode categories, and a common pattern is to alter the display or available functionality by episode type. (e.g. You may associate templates for discharge summaries with particular episode types) A Patient will have Subrecords (such as e.g. Demographics) which follow them across multiple episodes. These are information linked to a particular person, and should be implemented as Django models that inherit from the opal.models.PatientSubrecord base class. Episodes An Episode is linked to a Patient , and will contain some metadata about the type and date of the episode. The field Episode.category_name stores a string representing the relevant EpisodeCategory e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned from the episode.category field. The start and end dates of an Episode may be retrieved from the start and end properties. An Episode will have Subrecords (such as e.g. Diagnosis) which are linked to this episode of care. These should be implemented as Django models that inherit from the opal.models.EpisodeSubRecord base class. Records A Subrecord consists of a collection of fields that constitute a record. For example, one could implement a Demographics Subrecord as follows: class Demographics(PatientSubrecord): name = models.CharField(max_length=255, blank=True) hospital_number = models.CharField(max_length=255, blank=True) date_of_birth = models.DateField(null=True, blank=True) ethnicity = models.CharField(max_length=255, blank=True, null=True) gender = models.CharField(max_length=255, blank=True, null=True) Subrecords also define various properties that will provide metadata about their display or structure, which are documented in the Subrecord reference material Core Clinical Data Model Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Full documentation of these models is available in the Archetypes documentation. Reference Data Opal comes with a set of clinical terminology data models out of the box. - we often want to link our records to one of these - for example to record a type of condition a patient might have, or a drug they are taking. Full documentation of these is available in the Reference Data documentation.","title":"Data Model"},{"location":"guides/datamodel/#the-opal-data-model","text":"The Opal data model allows for patients to have multiple sequential or concurrent Episodes of care . Some information is linked to an Episode , some is linked to a Patient .","title":"The Opal Data model"},{"location":"guides/datamodel/#patients","text":"A Patient may have many Episodes . An Episode is something like an Inpatient admission, a telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic. Applications or plugins may define their own Episode categories, and a common pattern is to alter the display or available functionality by episode type. (e.g. You may associate templates for discharge summaries with particular episode types) A Patient will have Subrecords (such as e.g. Demographics) which follow them across multiple episodes. These are information linked to a particular person, and should be implemented as Django models that inherit from the opal.models.PatientSubrecord base class.","title":"Patients"},{"location":"guides/datamodel/#episodes","text":"An Episode is linked to a Patient , and will contain some metadata about the type and date of the episode. The field Episode.category_name stores a string representing the relevant EpisodeCategory e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned from the episode.category field. The start and end dates of an Episode may be retrieved from the start and end properties. An Episode will have Subrecords (such as e.g. Diagnosis) which are linked to this episode of care. These should be implemented as Django models that inherit from the opal.models.EpisodeSubRecord base class.","title":"Episodes"},{"location":"guides/datamodel/#records","text":"A Subrecord consists of a collection of fields that constitute a record. For example, one could implement a Demographics Subrecord as follows: class Demographics(PatientSubrecord): name = models.CharField(max_length=255, blank=True) hospital_number = models.CharField(max_length=255, blank=True) date_of_birth = models.DateField(null=True, blank=True) ethnicity = models.CharField(max_length=255, blank=True, null=True) gender = models.CharField(max_length=255, blank=True, null=True) Subrecords also define various properties that will provide metadata about their display or structure, which are documented in the Subrecord reference material","title":"Records"},{"location":"guides/datamodel/#core-clinical-data-model","text":"Opal ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Full documentation of these models is available in the Archetypes documentation.","title":"Core Clinical Data Model"},{"location":"guides/datamodel/#reference-data","text":"Opal comes with a set of clinical terminology data models out of the box. - we often want to link our records to one of these - for example to record a type of condition a patient might have, or a drug they are taking. Full documentation of these is available in the Reference Data documentation.","title":"Reference Data"},{"location":"guides/deployment/","text":"Deploying Opal It's no use building a great application if you can't easily deploy it. Because Opal is built on top of Django, we can take advantage of all the hard work that the open source community has put into making it easy to deploy Django applications. Opal can be deployed on any modern web server, if you're new to deploying Django applications we'd recommend you try Apache and mod_wsgi first. In most cases it'll be the easiest deployment choice. Heroku The Opal scaffold application comes with a Procfile ready for Heroku deployment, and the default requirements.txt includes some dependencies that allow us to easily deploy to Heroku. (Other PaaS and cloud technologies are available, and Opal should deploy fairly easily to any of them!) Deploying to Heroku Firstly, sign up for Heroku , and install their command line tool . We then need to create a new heroku application, and set up our database: heroku create heroku addons:create heroku-postgresql Next, we need to push our application code to the Heroku server with git: git push heroku master Then we can run our migrations, load our lookuplists and create a user: heroku run python manage.py migrate heroku run python manage.py load_lookup_lists heroku run python manage.py createsuperuser We should now be able to log in to our deployed app - to open it in a browser: heroku open","title":"Deployment"},{"location":"guides/deployment/#deploying-opal","text":"It's no use building a great application if you can't easily deploy it. Because Opal is built on top of Django, we can take advantage of all the hard work that the open source community has put into making it easy to deploy Django applications. Opal can be deployed on any modern web server, if you're new to deploying Django applications we'd recommend you try Apache and mod_wsgi first. In most cases it'll be the easiest deployment choice.","title":"Deploying Opal"},{"location":"guides/deployment/#heroku","text":"The Opal scaffold application comes with a Procfile ready for Heroku deployment, and the default requirements.txt includes some dependencies that allow us to easily deploy to Heroku. (Other PaaS and cloud technologies are available, and Opal should deploy fairly easily to any of them!)","title":"Heroku"},{"location":"guides/deployment/#deploying-to-heroku","text":"Firstly, sign up for Heroku , and install their command line tool . We then need to create a new heroku application, and set up our database: heroku create heroku addons:create heroku-postgresql Next, we need to push our application code to the Heroku server with git: git push heroku master Then we can run our migrations, load our lookuplists and create a user: heroku run python manage.py migrate heroku run python manage.py load_lookup_lists heroku run python manage.py createsuperuser We should now be able to log in to our deployed app - to open it in a browser: heroku open","title":"Deploying to Heroku"},{"location":"guides/development_environment/","text":"The Opal development environment Getting the code If you're planning on working on Opal we recommend installing in a Virtualenv - to make that easy, we would suggest installing Virtualenvwrapper. To obtain the code, set up a virtualenv and install Opal and the dependencies you'll need, run the following: git clone git@github.com:openhealthcare/opal cd opal mkvirtualenv -a $PWD opal python setup.py develop pip install -r test-requirements.txt Running the tests In order to run the Opal test suite you'll also need to install the Javascript test runner: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher To run the test suite: opal test You can also run just one suite (Javascript or Python) individually: opal test py opal test js","title":"Development environment"},{"location":"guides/development_environment/#the-opal-development-environment","text":"","title":"The Opal development environment"},{"location":"guides/development_environment/#getting-the-code","text":"If you're planning on working on Opal we recommend installing in a Virtualenv - to make that easy, we would suggest installing Virtualenvwrapper. To obtain the code, set up a virtualenv and install Opal and the dependencies you'll need, run the following: git clone git@github.com:openhealthcare/opal cd opal mkvirtualenv -a $PWD opal python setup.py develop pip install -r test-requirements.txt","title":"Getting the code"},{"location":"guides/development_environment/#running-the-tests","text":"In order to run the Opal test suite you'll also need to install the Javascript test runner: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher To run the test suite: opal test You can also run just one suite (Javascript or Python) individually: opal test py opal test js","title":"Running the tests"},{"location":"guides/discoverable/","text":"Opal Discoverable Features Opal makes extensive use of the case of discoverable features. These are pieces of composable functionality that can be implemented by any plugin or application, simply by declaring a class with the appropriate fields and methods implemented. (Details of exactly which fields and methods vary by feature.) Defining Discoverable Features The only thing required for a discoverable feature, is that it defines the name of the module in which it should expect to find instances. from opal.core import discoverable class MyFeature(discoverable.DiscoverableFeature): module_name = 'myfeature' This now gives us access to various interfaces which come with the library. We can access all subclasses of MyFeature by calling MyFeature.list() - which will look through all Django apps in our application, and look for a module named myfeature.py . The list() method then returns any subclasses of MyFeature . Slugs and Display Names We often want to define human and machine readable strings to name our features. Display names are intended for people - feel free to include spaces, numbers and punctuation. Slugs are intended for machines - so no spaces, numbers, hyphens, periods or other punctuation. By default, if there is a display name and no explicit slug, we will 'slugify' the display name. class MyNameFeature(MyFeature): display_name = 'Hello World' print MyNameFeature.get_slug() # 'hello_world' class MySlugFeature(MyFeature): slug = 'this_is_a_slug' print MySlugFeature.get_slug() # 'this_is_a_slug' Retrieving Subclasses Once we define a display_name or slug for subclasses of our feature, we can then fetch them via the get() api. class RedFeature(MyFeature): slug = 'red_feature' MyFeature.get('red_feature') # - RedFeature Sortable Features We can make our feature sortable via an order property by including discoverable.SortableFeature as a parent class. This will ensure that MyFeature.list() respects the .order number of any subclass. class MyFeature(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name = 'myfeature' class ThirdFeature(MyFeature): order = 3 class FirstFeature(MyFeature): order = 1 class SecondFeature(MyFeature): order = 2 for f in MyFeature.list(): print f, f.order # class '*.*.FirstFeature' , 1 # class '*.*.SecondFeature' , 2 # class '*.*.ThirdFeature' , 3 Restrictable Features We can ensure that only particular users can access a feature by including discoverable.RestrictableFeature as a parent class, and implementing the visible_to classmethod on any restricted subclasses. class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name = 'myfeature' For instance, a feature that was only visible to superusers could be implemented like this: class SuperuserFeature(MyFeature): @classmethod def visible_to(klass, user): return user.is_superuser Validating Features Sometimes we wish to validate features so that we don't cause unintended consequences when we implement subclasses of them. This is available via the is_valid classmethod. For instance, if we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was true, we could to this as follows: class BombFeature(discoverable.DiscoverableFeature): module_name = 'bombs' blow_up = False @classmethod def is_valid(klass): if klass.blow_up == True: from opal.core.exceptions import InvalidDiscoverableFeatureError raise InvalidDiscoverableFeatureError('BLOWING UP') class Threat(BombFeature): pass # That's fine. class Detonate(BombFeature): blow_up = True # InvalidDiscoverableFeatureError: BLOWING UP Abstract Features Sometimes we want to declare an abstract feature - something with reusable functionality that isn't itself a new feature. We would rather not have our abstract feature show up when we list() our base feature - because it's simply a programming convenience. This is made simple by using opal.utils.AbstractBase . class A(discoverable.DiscoverableFeature): module_name = 'a' class AA(A, AbstractBase): pass class B(A): pass class C(AA): pass class D(AA): pass A.list() # [B, C, D]","title":"Discoverable Features"},{"location":"guides/discoverable/#opal-discoverable-features","text":"Opal makes extensive use of the case of discoverable features. These are pieces of composable functionality that can be implemented by any plugin or application, simply by declaring a class with the appropriate fields and methods implemented. (Details of exactly which fields and methods vary by feature.)","title":"Opal Discoverable Features"},{"location":"guides/discoverable/#defining-discoverable-features","text":"The only thing required for a discoverable feature, is that it defines the name of the module in which it should expect to find instances. from opal.core import discoverable class MyFeature(discoverable.DiscoverableFeature): module_name = 'myfeature' This now gives us access to various interfaces which come with the library. We can access all subclasses of MyFeature by calling MyFeature.list() - which will look through all Django apps in our application, and look for a module named myfeature.py . The list() method then returns any subclasses of MyFeature .","title":"Defining Discoverable Features"},{"location":"guides/discoverable/#slugs-and-display-names","text":"We often want to define human and machine readable strings to name our features. Display names are intended for people - feel free to include spaces, numbers and punctuation. Slugs are intended for machines - so no spaces, numbers, hyphens, periods or other punctuation. By default, if there is a display name and no explicit slug, we will 'slugify' the display name. class MyNameFeature(MyFeature): display_name = 'Hello World' print MyNameFeature.get_slug() # 'hello_world' class MySlugFeature(MyFeature): slug = 'this_is_a_slug' print MySlugFeature.get_slug() # 'this_is_a_slug'","title":"Slugs and Display Names"},{"location":"guides/discoverable/#retrieving-subclasses","text":"Once we define a display_name or slug for subclasses of our feature, we can then fetch them via the get() api. class RedFeature(MyFeature): slug = 'red_feature' MyFeature.get('red_feature') # - RedFeature","title":"Retrieving Subclasses"},{"location":"guides/discoverable/#sortable-features","text":"We can make our feature sortable via an order property by including discoverable.SortableFeature as a parent class. This will ensure that MyFeature.list() respects the .order number of any subclass. class MyFeature(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name = 'myfeature' class ThirdFeature(MyFeature): order = 3 class FirstFeature(MyFeature): order = 1 class SecondFeature(MyFeature): order = 2 for f in MyFeature.list(): print f, f.order # class '*.*.FirstFeature' , 1 # class '*.*.SecondFeature' , 2 # class '*.*.ThirdFeature' , 3","title":"Sortable Features"},{"location":"guides/discoverable/#restrictable-features","text":"We can ensure that only particular users can access a feature by including discoverable.RestrictableFeature as a parent class, and implementing the visible_to classmethod on any restricted subclasses. class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name = 'myfeature' For instance, a feature that was only visible to superusers could be implemented like this: class SuperuserFeature(MyFeature): @classmethod def visible_to(klass, user): return user.is_superuser","title":"Restrictable Features"},{"location":"guides/discoverable/#validating-features","text":"Sometimes we wish to validate features so that we don't cause unintended consequences when we implement subclasses of them. This is available via the is_valid classmethod. For instance, if we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was true, we could to this as follows: class BombFeature(discoverable.DiscoverableFeature): module_name = 'bombs' blow_up = False @classmethod def is_valid(klass): if klass.blow_up == True: from opal.core.exceptions import InvalidDiscoverableFeatureError raise InvalidDiscoverableFeatureError('BLOWING UP') class Threat(BombFeature): pass # That's fine. class Detonate(BombFeature): blow_up = True # InvalidDiscoverableFeatureError: BLOWING UP","title":"Validating Features"},{"location":"guides/discoverable/#abstract-features","text":"Sometimes we want to declare an abstract feature - something with reusable functionality that isn't itself a new feature. We would rather not have our abstract feature show up when we list() our base feature - because it's simply a programming convenience. This is made simple by using opal.utils.AbstractBase . class A(discoverable.DiscoverableFeature): module_name = 'a' class AA(A, AbstractBase): pass class B(A): pass class C(AA): pass class D(AA): pass A.list() # [B, C, D]","title":"Abstract Features"},{"location":"guides/django_admin/","text":"Working with the Django Admin One of the great features of Django is the Admin application it provides for developers and administrators. By default, you can access the Django admin by visiting the /admin/ url of your application. Opal will automatically register Patients, Episodes, Lookup lists, and all Subrecords with the Django Admin for you. Customising the Admin If you need to customise the admin for a particular subrecord you will need to 'unregister' the admin class that Opal has registered it with. # myapp/admin.py from django.contrib import admin from opal.admin import EpisodeSubrecordAdmin from myapp import models admin.site.unregister(models.Diagnosis) class DiagnosisAdmin(EpisodeSubrecordAdmin): list_display = ['__unicode__', 'condition'] admin.site.register(models.Diagnosis, DiagnosisAdmin) It is strongly suggested that any custom Admin implementation inherits from the Django Reversion ReversionAdmin base class. It is through this registering step that our automatic audit trail is enabled for a particular model. The base subrecord admin classes opal.admin.EpisodeSubrecordAdmin and opal.admin.PatientSubrecordAdmin allow searching by basic patient demographics (name, identifier), and also inherits from ReversionAdmin .","title":"Django Admin"},{"location":"guides/django_admin/#working-with-the-django-admin","text":"One of the great features of Django is the Admin application it provides for developers and administrators. By default, you can access the Django admin by visiting the /admin/ url of your application. Opal will automatically register Patients, Episodes, Lookup lists, and all Subrecords with the Django Admin for you.","title":"Working with the Django Admin"},{"location":"guides/django_admin/#customising-the-admin","text":"If you need to customise the admin for a particular subrecord you will need to 'unregister' the admin class that Opal has registered it with. # myapp/admin.py from django.contrib import admin from opal.admin import EpisodeSubrecordAdmin from myapp import models admin.site.unregister(models.Diagnosis) class DiagnosisAdmin(EpisodeSubrecordAdmin): list_display = ['__unicode__', 'condition'] admin.site.register(models.Diagnosis, DiagnosisAdmin) It is strongly suggested that any custom Admin implementation inherits from the Django Reversion ReversionAdmin base class. It is through this registering step that our automatic audit trail is enabled for a particular model. The base subrecord admin classes opal.admin.EpisodeSubrecordAdmin and opal.admin.PatientSubrecordAdmin allow searching by basic patient demographics (name, identifier), and also inherits from ReversionAdmin .","title":"Customising the Admin"},{"location":"guides/dump/","text":"Your implementation Your implementation is a Django project with some extras. Opal settings OPAL_LOG_OUT_DURATION = The number of milliseconds after which to log out our user OPAL_BRAND_NAME = The branding to be displayed as the masthead OPAL_EXTRA_APPLICATION = A template to include in the HEAD OPAL_EXTRA_HEADER = A template to include above the main nav Defining Models Models should be defined in your project. They should subclass opal.models.EpisodeSubrecord or opal.models.PatientSubrecord as appropriate. Subrecords have some extra entrypoints that are used by Opal. _is_singleton _is_singleton is a boolean property that ensures that there is only one of this subrecord per patient/episode. Effectively this defaults to False. _sort _sort names a field by which we would like to sort the display of subrecords. _read_only Marks a field as read only if True _batch_template Allow the list/detail template access to the complete row, not just an item. Template is then responsible for registering click handlers. Will get cix as a variable representing the column index, column_name as the column name. Adding a controller Create the controller file in static/js/opal/controllers. Use the angular module opal.controllers Include this file in templates/opal.html Create a template url in the django layer Creating a Heroku test server $ heroku create $YOUR_APP_NAME (Edit .git/config to give the remote a meaningful name) $ heroku addons:create heroku-postgresql --app $YOUR_APP_NAME $ git push $YOUR_REMOTE_NAME $YOUR_BRANCH:master $ heroku run python manage.py syncdb --migrate --app $YOUR_APP_NAME $ heroku run python manage.py load_lookup_lists $ heroku run python manage.py createinitialrevisions --app $YOUR_APP_NAME","title":"Your implementation"},{"location":"guides/dump/#your-implementation","text":"Your implementation is a Django project with some extras.","title":"Your implementation"},{"location":"guides/dump/#opal-settings","text":"OPAL_LOG_OUT_DURATION = The number of milliseconds after which to log out our user OPAL_BRAND_NAME = The branding to be displayed as the masthead OPAL_EXTRA_APPLICATION = A template to include in the HEAD OPAL_EXTRA_HEADER = A template to include above the main nav","title":"Opal settings"},{"location":"guides/dump/#defining-models","text":"Models should be defined in your project. They should subclass opal.models.EpisodeSubrecord or opal.models.PatientSubrecord as appropriate. Subrecords have some extra entrypoints that are used by Opal.","title":"Defining Models"},{"location":"guides/dump/#_is_singleton","text":"_is_singleton is a boolean property that ensures that there is only one of this subrecord per patient/episode. Effectively this defaults to False.","title":"_is_singleton"},{"location":"guides/dump/#_sort","text":"_sort names a field by which we would like to sort the display of subrecords.","title":"_sort"},{"location":"guides/dump/#_read_only","text":"Marks a field as read only if True","title":"_read_only"},{"location":"guides/dump/#_batch_template","text":"Allow the list/detail template access to the complete row, not just an item. Template is then responsible for registering click handlers. Will get cix as a variable representing the column index, column_name as the column name.","title":"_batch_template"},{"location":"guides/dump/#adding-a-controller","text":"Create the controller file in static/js/opal/controllers. Use the angular module opal.controllers Include this file in templates/opal.html Create a template url in the django layer","title":"Adding a controller"},{"location":"guides/dump/#creating-a-heroku-test-server","text":"$ heroku create $YOUR_APP_NAME (Edit .git/config to give the remote a meaningful name) $ heroku addons:create heroku-postgresql --app $YOUR_APP_NAME $ git push $YOUR_REMOTE_NAME $YOUR_BRANCH:master $ heroku run python manage.py syncdb --migrate --app $YOUR_APP_NAME $ heroku run python manage.py load_lookup_lists $ heroku run python manage.py createinitialrevisions --app $YOUR_APP_NAME","title":"Creating a Heroku test server"},{"location":"guides/episodes/","text":"Opal Episodes In Opal a Patient may have one or many Episodes. An Episode contains some metadata such as a start and end date, and the type of episode. This may be an inpatient stay, an outpatient treatment, a telephone consultation - or any other arbitrarily defined period of care. Episode Categories An episode must have a related category. An Opal EpisodeCategory is a discoverable subclass of opal.core.episodes.EpisodeCategory - such as InpatientEpisode , OutpatientEpisode or LiaisonEpisode . You can access the current category of an episode via the category property, while it is represented in the database in the field category_name which will contain the display_name attribute of the relevant category. episode = patient.episode_set.first() print episode.category # opal.core.episode.InpatientEpisode object print episode.category.display_name # Inpatient print episode.category_name # Inpatient Detail templates The category of an episode determines which template will be used to display it on the detail page for the patient. This template is determined by looking up the detail_template attribute of the EpisodeCategory . episode.category print episode.category # opal.core.episode.InpatientEpisode object print episode.category.detail_template # detail/inpatient.html The Episode Category template does not comprise the entire Patient detail view . This is made of multiple episodes and by default will display some basic demographic details as well as other episodes. More detail on customising the rest of the detail tempalte is found in the detail view Template selection docs . Default Category The default category of episodes in an Opal application is set by the OpalApplication object's default_episode_category property. class Application(application.OpalApplication): default_episode_category = MyCategory.display_name Defining your own EpisodeCategory As EpisodeCategory is a discoverable we can define our own to meet custom requirements. Episode categories should be defined in a file named episode_categories of your application or plugin. # yourapp/episode_categories.py from opal.core import episodes class DropInClinicEpisode(episodes.EpisodeCategory): display_name = Drop-in clinic detail_template = detail/drop_in.html Episode.active The field .active is used to distinguish Episodes which are ongoing. This field is set implicitly by the Episode.save() method, and there will generally be no need to set this field directly as part of application code. Whether an Episode is considered active is determined by the .is_active() method of the relevant EpisodeCategory. The default implementation considers any Episode without an .end date to be active and any Episode with one to be inactive. Applications may customise this behaviour by overriding the .is_active() method. For instance, to create a category which considered any Episode older than 2 weeks to be inactive, one might override the method as follows: # yourapp/episode_categories.py import datetime from opal.core import episodes class TwoWeeksAndStopCaringEpisode(episodes.EpisodeCategory): def is_active(self): delta = datetime.date.today() - self.episode.start return bool(delta = datetime.timedelta(days=14)) (Note that this would not alter the value in the database immediately after those 2 weeks, but would alter the value the next time the Episode.save() method was called.) Episode stages An Episode will frequently consist of a number of possible stages. For instance, for an inpatient episode, a patient will first be an inpatient, and then an be discharged, with an optional interim follow up stage for inpatients who have been discharged but requrie further follow up. Opal stores the stage of an episode as a string in the stage property of an Episode . The valid possible stages for a category are accessed from the get_stages method of the category. episode.category.get_stages() # ['Inpatient', 'Followup', 'Discharged'] episode.category.has_stage('Followup') # True","title":"Episodes"},{"location":"guides/episodes/#opal-episodes","text":"In Opal a Patient may have one or many Episodes. An Episode contains some metadata such as a start and end date, and the type of episode. This may be an inpatient stay, an outpatient treatment, a telephone consultation - or any other arbitrarily defined period of care.","title":"Opal Episodes"},{"location":"guides/episodes/#episode-categories","text":"An episode must have a related category. An Opal EpisodeCategory is a discoverable subclass of opal.core.episodes.EpisodeCategory - such as InpatientEpisode , OutpatientEpisode or LiaisonEpisode . You can access the current category of an episode via the category property, while it is represented in the database in the field category_name which will contain the display_name attribute of the relevant category. episode = patient.episode_set.first() print episode.category # opal.core.episode.InpatientEpisode object print episode.category.display_name # Inpatient print episode.category_name # Inpatient","title":"Episode Categories"},{"location":"guides/episodes/#detail-templates","text":"The category of an episode determines which template will be used to display it on the detail page for the patient. This template is determined by looking up the detail_template attribute of the EpisodeCategory . episode.category print episode.category # opal.core.episode.InpatientEpisode object print episode.category.detail_template # detail/inpatient.html The Episode Category template does not comprise the entire Patient detail view . This is made of multiple episodes and by default will display some basic demographic details as well as other episodes. More detail on customising the rest of the detail tempalte is found in the detail view Template selection docs .","title":"Detail templates"},{"location":"guides/episodes/#default-category","text":"The default category of episodes in an Opal application is set by the OpalApplication object's default_episode_category property. class Application(application.OpalApplication): default_episode_category = MyCategory.display_name","title":"Default Category"},{"location":"guides/episodes/#defining-your-own-episodecategory","text":"As EpisodeCategory is a discoverable we can define our own to meet custom requirements. Episode categories should be defined in a file named episode_categories of your application or plugin. # yourapp/episode_categories.py from opal.core import episodes class DropInClinicEpisode(episodes.EpisodeCategory): display_name = Drop-in clinic detail_template = detail/drop_in.html","title":"Defining your own EpisodeCategory"},{"location":"guides/episodes/#episodeactive","text":"The field .active is used to distinguish Episodes which are ongoing. This field is set implicitly by the Episode.save() method, and there will generally be no need to set this field directly as part of application code. Whether an Episode is considered active is determined by the .is_active() method of the relevant EpisodeCategory. The default implementation considers any Episode without an .end date to be active and any Episode with one to be inactive. Applications may customise this behaviour by overriding the .is_active() method. For instance, to create a category which considered any Episode older than 2 weeks to be inactive, one might override the method as follows: # yourapp/episode_categories.py import datetime from opal.core import episodes class TwoWeeksAndStopCaringEpisode(episodes.EpisodeCategory): def is_active(self): delta = datetime.date.today() - self.episode.start return bool(delta = datetime.timedelta(days=14)) (Note that this would not alter the value in the database immediately after those 2 weeks, but would alter the value the next time the Episode.save() method was called.)","title":"Episode.active"},{"location":"guides/episodes/#episode-stages","text":"An Episode will frequently consist of a number of possible stages. For instance, for an inpatient episode, a patient will first be an inpatient, and then an be discharged, with an optional interim follow up stage for inpatients who have been discharged but requrie further follow up. Opal stores the stage of an episode as a string in the stage property of an Episode . The valid possible stages for a category are accessed from the get_stages method of the category. episode.category.get_stages() # ['Inpatient', 'Followup', 'Discharged'] episode.category.has_stage('Followup') # True","title":"Episode stages"},{"location":"guides/forms/","text":"Forms Editing Records The editing of records is a key component of any Opal application. A key pattern is to edit or create an individual record in a modal containing the form for just that record. Opal provides the Angular Controller opal.controllers.EditItemCtrl for doing just this Customising the Angular Controller Opal uses the formController attribute of an Item to determine which Angular Controller to use. This defaults to opal.controllers.EditItemCtrl . Individual Subrecords may customise this by implementing an Angualar record Service and overriding the formController attribute. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ record.formController = 'MyCustomDiagnosisFormController'; return record; } }); Custom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved Form and modal templates Subrecords have get_form_template() and get_modal_template() methods, which are used for figuring out how to render forms for interacting with them. These use the following template paths based on the context in which they are called: # Forms forms/{episode_type}/{list slug}/{record_name}_form.html forms/{list_slug}/{record_name}_form.html forms/{episode_type}/{record_name}_form.html forms/{record_name}_form.html # Modals modals/{episode_type}/{list slug}/{record_name}_modal.html modals/{list_slug}/{record_name}_modal.html modals/{episode_type}/{record_name}_modal.html modals/{record_name}_modal.html Autogenerating forms The opal commandline tool has a scaffold command, which will autogenerate missing form templates for subrecord models. Simply run the following command to generate. $ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE (Note this will also generate and run migrations for any unmigrated models.xb) Client side Validation Client side validation for forms requires a pattern and a help block uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input) Helpers Opal contains a number of helpers for developing forms and input modals. Many of these are located in the forms template tag library, which is a Django templatetag library that understands the context of common patterns with Opal for creating forms and modals. It provides helpers for various input types that will allow you to render consistent forms, with less verbose templates. {% load forms %} form class=\"form-horizontal\" {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %} {% datepicker label=\"Date\" model=\"editing.date\" %} {% checkbox label=\"Alone?\" model=\"editing.alone\" %} /form For full documentation of the options, please see the Form templatetags reference material","title":"Forms"},{"location":"guides/forms/#forms","text":"","title":"Forms"},{"location":"guides/forms/#editing-records","text":"The editing of records is a key component of any Opal application. A key pattern is to edit or create an individual record in a modal containing the form for just that record. Opal provides the Angular Controller opal.controllers.EditItemCtrl for doing just this","title":"Editing Records"},{"location":"guides/forms/#customising-the-angular-controller","text":"Opal uses the formController attribute of an Item to determine which Angular Controller to use. This defaults to opal.controllers.EditItemCtrl . Individual Subrecords may customise this by implementing an Angualar record Service and overriding the formController attribute. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ record.formController = 'MyCustomDiagnosisFormController'; return record; } }); Custom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved","title":"Customising the Angular Controller"},{"location":"guides/forms/#form-and-modal-templates","text":"Subrecords have get_form_template() and get_modal_template() methods, which are used for figuring out how to render forms for interacting with them. These use the following template paths based on the context in which they are called: # Forms forms/{episode_type}/{list slug}/{record_name}_form.html forms/{list_slug}/{record_name}_form.html forms/{episode_type}/{record_name}_form.html forms/{record_name}_form.html # Modals modals/{episode_type}/{list slug}/{record_name}_modal.html modals/{list_slug}/{record_name}_modal.html modals/{episode_type}/{record_name}_modal.html modals/{record_name}_modal.html","title":"Form and modal templates"},{"location":"guides/forms/#autogenerating-forms","text":"The opal commandline tool has a scaffold command, which will autogenerate missing form templates for subrecord models. Simply run the following command to generate. $ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE (Note this will also generate and run migrations for any unmigrated models.xb)","title":"Autogenerating forms"},{"location":"guides/forms/#client-side-validation","text":"Client side validation for forms requires a pattern and a help block uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input)","title":"Client side Validation"},{"location":"guides/forms/#helpers","text":"Opal contains a number of helpers for developing forms and input modals. Many of these are located in the forms template tag library, which is a Django templatetag library that understands the context of common patterns with Opal for creating forms and modals. It provides helpers for various input types that will allow you to render consistent forms, with less verbose templates. {% load forms %} form class=\"form-horizontal\" {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %} {% datepicker label=\"Date\" model=\"editing.date\" %} {% checkbox label=\"Alone?\" model=\"editing.alone\" %} /form For full documentation of the options, please see the Form templatetags reference material","title":"Helpers"},{"location":"guides/json_api/","text":"The Opal JSON API Opal features a rich, self documenting set of open JSON APIs. Opal applications are generally simply a collection of Browser-based clients for these APIs. Opal uses Django Rest Framework to provide it's APIs. You may examine the API of any running Opal application by navigating to the url /api/v0.1/ Adding your own APIs You can add your own APIs to the Opal API namespace from plugins or by registering them directly with the router. from rest_framework.viewsets import ViewSet from rest_framework.response import Response from opal.core.api import router class PingViewSet(ViewSet): def list(self, request): return Response('pong') router.register('ping', PingViewSet) APIs can make use of method decorators item_from_pk , episode_from_pk and patient_from_pk that will replace a pk passed into a method with self.model, Episode or Patient respectively. e.g. class SomeBespokeViewset(viewsets.Viewset): model = ClinicalInformation @item_from_pk def some_api_endpoint(self, request, clinical_information): # Some logic Authentication Opal uses Django Rest Framework (DRF) to provide APIs. DRF ships with multiple authentication mechanisms which are highly configurable. By default, Opal applications (e.g. created with the Opal scaffolding) will enable Session and Token based authentication. More details on DRF authentication are available in their excellent documentation . Permissioning Opal uses the DRF permissions system for JSON APIs. Opal ships with opal.core.api.LoginRequiredViewset which adds the permission class IsAuthenticated by default. Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. More details on DRF permissions are available in the DRF documentation . Session Based Session based authentication enables users logged in via the standard Django auth mechanism to use the API. This is what most Opal applications in the browser will use. Token Based Token based authentication is targeted at other applications consuming the Opal API, and requires the application to pass an API token as a header. These tokens must be associated with a Django user, and can be created in the Django Admin. An example of a client using token based authentication is found in the OpalAPI project.","title":"JSON API"},{"location":"guides/json_api/#the-opal-json-api","text":"Opal features a rich, self documenting set of open JSON APIs. Opal applications are generally simply a collection of Browser-based clients for these APIs. Opal uses Django Rest Framework to provide it's APIs. You may examine the API of any running Opal application by navigating to the url /api/v0.1/","title":"The Opal JSON API"},{"location":"guides/json_api/#adding-your-own-apis","text":"You can add your own APIs to the Opal API namespace from plugins or by registering them directly with the router. from rest_framework.viewsets import ViewSet from rest_framework.response import Response from opal.core.api import router class PingViewSet(ViewSet): def list(self, request): return Response('pong') router.register('ping', PingViewSet) APIs can make use of method decorators item_from_pk , episode_from_pk and patient_from_pk that will replace a pk passed into a method with self.model, Episode or Patient respectively. e.g. class SomeBespokeViewset(viewsets.Viewset): model = ClinicalInformation @item_from_pk def some_api_endpoint(self, request, clinical_information): # Some logic","title":"Adding your own APIs"},{"location":"guides/json_api/#authentication","text":"Opal uses Django Rest Framework (DRF) to provide APIs. DRF ships with multiple authentication mechanisms which are highly configurable. By default, Opal applications (e.g. created with the Opal scaffolding) will enable Session and Token based authentication. More details on DRF authentication are available in their excellent documentation .","title":"Authentication"},{"location":"guides/json_api/#permissioning","text":"Opal uses the DRF permissions system for JSON APIs. Opal ships with opal.core.api.LoginRequiredViewset which adds the permission class IsAuthenticated by default. Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. More details on DRF permissions are available in the DRF documentation .","title":"Permissioning"},{"location":"guides/json_api/#session-based","text":"Session based authentication enables users logged in via the standard Django auth mechanism to use the API. This is what most Opal applications in the browser will use.","title":"Session Based"},{"location":"guides/json_api/#token-based","text":"Token based authentication is targeted at other applications consuming the Opal API, and requires the application to pass an API token as a header. These tokens must be associated with a Django user, and can be created in the Django Admin. An example of a client using token based authentication is found in the OpalAPI project.","title":"Token Based"},{"location":"guides/list_views/","text":"Opal Patient List views Opal provides support for displaying lists of patients, both via a spreadsheet like view, and with a card based view. Defining lists Opal patient lists are subclasses of opal.core.patient_lists.PatientList . Typically these are found in a patient_lists.py module of your application or plugin. (Lists can be defined elsewhere, but may not be auto discovered.) A basic list needs only define its display_name a queryset of episodes to display, and a schema of subrecords to show for each episode. # patient_lists.py from opal.models import Episode from opal.core import patient_lists from myapplication import models class AlphabetListA(patient_lists.PatientList): display_name = 'A Patients' queryset = Episode.objects.filter(demographics__name__istartswith='a') schema = [ models.Demographics, models.Location, models.Diagnosis, models.Treatment ] The display_name property is the human readable name for our list - which is displayed as link text to our list. Schemas The schema attribute declares the columns of a PatientList. The entries in a schema may either be Subrecord instances, or instances of opal.core.patient_lists.Column . Custom Columns Although most schema entries will be subrecords, it can be useful to have non-subrecord columns. For instance because you want to allow a composite column of multiple Subrecords or because we want to simply render arbitrary markup. Columns require the title, and template_path to be set, and are simply included in the schema list. class MyMarkupList(patient_lists.PatientList): schema = [ patient_lists.Column(title='Foo', template_path='foo/bar') ] Template selection The list view is constructed by rendering a column for each record, in the order defined in the schema, and a row for each episode in the list. The template for each cell should live in ./templates/records/* . In order to select the appropriate template for a given episode, Opal looks in the following locations: records/{episode_type}/{list slug}/{record_name}.html records/{list_slug}/{record_name}.html records/{episode_type}/{record_name}.html records/{record_name}.html Querysets The queryset property of your list should contain all of the episodes for this particular list. On occasion we require a more dynamic queryset, in which case we can override the get_queryset method. # patient_lists.py import datetime from opal.models import Episode from opal.core import patient_lists class MyWeeklyList(patient_lists.PatientList): def get_queryset(self): one_week_ago = datetime.date.today() - datetime.timedelta(days=1) return Episode.objects.filter(start__gte=one_week_ago) Ordering Lists As a discoverable.SortableFeature lists may be ordered by setting the order property to an integer. Lists will display in drop-downs, tables et cetera, in this order. Slug As a discoverable feature, the slug for each list is determined by either setting the slug property, or returning a string from the get_slug classmethod. Tagged Patient Lists A common model for working with lists is to use lists based on the tags assigned to an episode. This allows users to add and remove patients from lists as they see fit, rather than attempting to infer it from other properties of the patient (e.g. their current location for instance.) which can be particularly challenging for some clinical services. Opal provides a specific subclass for working with Tagged Patient Lists: # patient_lists.py from opal.core import patient_lists class MyTagList(patient_lists.TaggedPatientList): display_name = 'Tagged blue' tag = 'blue' Tagged lists will automatically fetch the appropriate queryset for patients tagged with the tag you specify. Invalid Tagged Patient Lists Tag names may not have hyphens in them - Opal uses hyphens to distinguish between tags and subtags in the urls for lists, so attempting to define one will raise an exception. class MyList(TaggedPatientList): tag = 'foo-bar' # This will raise InvalidDiscoverableFeatureError ! Direct Add Sometimes, we want to control the flow of patients onto, off, or between lists a little more closely. For instance, we might need to ensure additional data collection at points in a patient journey. In order to accomplish this, we often implement custom patient flows that will programatically tag episodes to tagged lists. In those cases we will want to prevent users from manually adding or removing the tags themselves. This can be easily accomplished via the direct_add property. When set to false, users will not be able to add the tag for this list. class MyLockedDownList(TaggedPatientList): tag = 'liaisonpatients' direct_add = False Customising Sort order of Episodes By default, PatientLists sort according by start , then first_name , then surname using the Angular method Episode.compare . You may override this on a list-by-list basis by setting the comparator_service attribute. class MySortedList(PatientList): comparator_service = 'MyComparatorService' This attribute should be the name of an Angular service that returns a list of comparator functions. For instance, to sort by Episode.category_name then Episode id: angular.module('opal.services') .factory('MyComparatorService', function(){ use strict ; return [ function(e){ return e.category_name }, function(e){ return e.id } ] }) The file containing your comparator service must be included in the javascripts of your application or plugin in order to be available on the client. Access Control As PatientLists are a RestrictableFeature , Access control for lists is set by overriding the visible_to classmethod. Your list will only be visible to those users for whom this method returns True . For instance, we could define a Patient List that was only available to Django Superusers: class SuperuserPatientList(PatientList): @classmethod def visible_to(klass, user): return user.is_superuser Grouping related Patient Lists We commonly require groups of patient lists for a single clinical service. For example a busy outpatients clinic might have one list of people in the waiting room, one list of people being triaged, one list for people waiting to see the medical staff, and another for people who have been seen but need review - for instance because they have outstanding test results. Opal provides the TabbedPatientListGroup class to help with this case. Tabbed Patient List Groups are an ordered collection of related Patient Lists that are displayed as tabs at the top of any list in the group. Defining a Tabbed Patient List Group Defining a group can be as simple as declaring member lists in a property. # yourapp/patient_lists.py from opal.core import patient_lists # ... Define your lists here class MyListGroup(patient_lists.TabbedPatientListGroup): member_lists = [MyFirstPatientList, MySecondPatientList, ...] Tabbed Patient List Groups are a Discoverable feature, we expect them to be in a module named patient_lists.py in one of the Django apps in your application. Customising membership The members of your group can be determined dynamically by overriding the get_member_lists classmethod of your group: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def get_member_lists(klass): # return an iterable of PatientList subclasses Restricting access By default, the UI for a TabbedPatientListGroup is shown at the top of any member PatientList as long as there are more than one members of the group visible to the given user. This behaviour can be customised by overriding the visible_to classmethod: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def visible_to(klass, user): # return True or False appropriately Customising templates Applications may customise the UI for Tabbed Patient List Groups by customising the template patient_lists/tabbed_list_group.html . The default template simply extends patient_lists/tabbed_list_group_base.html .","title":"Patient List Views"},{"location":"guides/list_views/#opal-patient-list-views","text":"Opal provides support for displaying lists of patients, both via a spreadsheet like view, and with a card based view.","title":"Opal Patient List views"},{"location":"guides/list_views/#defining-lists","text":"Opal patient lists are subclasses of opal.core.patient_lists.PatientList . Typically these are found in a patient_lists.py module of your application or plugin. (Lists can be defined elsewhere, but may not be auto discovered.) A basic list needs only define its display_name a queryset of episodes to display, and a schema of subrecords to show for each episode. # patient_lists.py from opal.models import Episode from opal.core import patient_lists from myapplication import models class AlphabetListA(patient_lists.PatientList): display_name = 'A Patients' queryset = Episode.objects.filter(demographics__name__istartswith='a') schema = [ models.Demographics, models.Location, models.Diagnosis, models.Treatment ] The display_name property is the human readable name for our list - which is displayed as link text to our list.","title":"Defining lists"},{"location":"guides/list_views/#schemas","text":"The schema attribute declares the columns of a PatientList. The entries in a schema may either be Subrecord instances, or instances of opal.core.patient_lists.Column .","title":"Schemas"},{"location":"guides/list_views/#custom-columns","text":"Although most schema entries will be subrecords, it can be useful to have non-subrecord columns. For instance because you want to allow a composite column of multiple Subrecords or because we want to simply render arbitrary markup. Columns require the title, and template_path to be set, and are simply included in the schema list. class MyMarkupList(patient_lists.PatientList): schema = [ patient_lists.Column(title='Foo', template_path='foo/bar') ]","title":"Custom Columns"},{"location":"guides/list_views/#template-selection","text":"The list view is constructed by rendering a column for each record, in the order defined in the schema, and a row for each episode in the list. The template for each cell should live in ./templates/records/* . In order to select the appropriate template for a given episode, Opal looks in the following locations: records/{episode_type}/{list slug}/{record_name}.html records/{list_slug}/{record_name}.html records/{episode_type}/{record_name}.html records/{record_name}.html","title":"Template selection"},{"location":"guides/list_views/#querysets","text":"The queryset property of your list should contain all of the episodes for this particular list. On occasion we require a more dynamic queryset, in which case we can override the get_queryset method. # patient_lists.py import datetime from opal.models import Episode from opal.core import patient_lists class MyWeeklyList(patient_lists.PatientList): def get_queryset(self): one_week_ago = datetime.date.today() - datetime.timedelta(days=1) return Episode.objects.filter(start__gte=one_week_ago)","title":"Querysets"},{"location":"guides/list_views/#ordering-lists","text":"As a discoverable.SortableFeature lists may be ordered by setting the order property to an integer. Lists will display in drop-downs, tables et cetera, in this order.","title":"Ordering Lists"},{"location":"guides/list_views/#slug","text":"As a discoverable feature, the slug for each list is determined by either setting the slug property, or returning a string from the get_slug classmethod.","title":"Slug"},{"location":"guides/list_views/#tagged-patient-lists","text":"A common model for working with lists is to use lists based on the tags assigned to an episode. This allows users to add and remove patients from lists as they see fit, rather than attempting to infer it from other properties of the patient (e.g. their current location for instance.) which can be particularly challenging for some clinical services. Opal provides a specific subclass for working with Tagged Patient Lists: # patient_lists.py from opal.core import patient_lists class MyTagList(patient_lists.TaggedPatientList): display_name = 'Tagged blue' tag = 'blue' Tagged lists will automatically fetch the appropriate queryset for patients tagged with the tag you specify.","title":"Tagged Patient Lists"},{"location":"guides/list_views/#invalid-tagged-patient-lists","text":"Tag names may not have hyphens in them - Opal uses hyphens to distinguish between tags and subtags in the urls for lists, so attempting to define one will raise an exception. class MyList(TaggedPatientList): tag = 'foo-bar' # This will raise InvalidDiscoverableFeatureError !","title":"Invalid Tagged Patient Lists"},{"location":"guides/list_views/#direct-add","text":"Sometimes, we want to control the flow of patients onto, off, or between lists a little more closely. For instance, we might need to ensure additional data collection at points in a patient journey. In order to accomplish this, we often implement custom patient flows that will programatically tag episodes to tagged lists. In those cases we will want to prevent users from manually adding or removing the tags themselves. This can be easily accomplished via the direct_add property. When set to false, users will not be able to add the tag for this list. class MyLockedDownList(TaggedPatientList): tag = 'liaisonpatients' direct_add = False","title":"Direct Add"},{"location":"guides/list_views/#customising-sort-order-of-episodes","text":"By default, PatientLists sort according by start , then first_name , then surname using the Angular method Episode.compare . You may override this on a list-by-list basis by setting the comparator_service attribute. class MySortedList(PatientList): comparator_service = 'MyComparatorService' This attribute should be the name of an Angular service that returns a list of comparator functions. For instance, to sort by Episode.category_name then Episode id: angular.module('opal.services') .factory('MyComparatorService', function(){ use strict ; return [ function(e){ return e.category_name }, function(e){ return e.id } ] }) The file containing your comparator service must be included in the javascripts of your application or plugin in order to be available on the client.","title":"Customising Sort order of Episodes"},{"location":"guides/list_views/#access-control","text":"As PatientLists are a RestrictableFeature , Access control for lists is set by overriding the visible_to classmethod. Your list will only be visible to those users for whom this method returns True . For instance, we could define a Patient List that was only available to Django Superusers: class SuperuserPatientList(PatientList): @classmethod def visible_to(klass, user): return user.is_superuser","title":"Access Control"},{"location":"guides/list_views/#grouping-related-patient-lists","text":"We commonly require groups of patient lists for a single clinical service. For example a busy outpatients clinic might have one list of people in the waiting room, one list of people being triaged, one list for people waiting to see the medical staff, and another for people who have been seen but need review - for instance because they have outstanding test results. Opal provides the TabbedPatientListGroup class to help with this case. Tabbed Patient List Groups are an ordered collection of related Patient Lists that are displayed as tabs at the top of any list in the group.","title":"Grouping related Patient Lists"},{"location":"guides/list_views/#defining-a-tabbed-patient-list-group","text":"Defining a group can be as simple as declaring member lists in a property. # yourapp/patient_lists.py from opal.core import patient_lists # ... Define your lists here class MyListGroup(patient_lists.TabbedPatientListGroup): member_lists = [MyFirstPatientList, MySecondPatientList, ...] Tabbed Patient List Groups are a Discoverable feature, we expect them to be in a module named patient_lists.py in one of the Django apps in your application.","title":"Defining a Tabbed Patient List Group"},{"location":"guides/list_views/#customising-membership","text":"The members of your group can be determined dynamically by overriding the get_member_lists classmethod of your group: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def get_member_lists(klass): # return an iterable of PatientList subclasses","title":"Customising membership"},{"location":"guides/list_views/#restricting-access","text":"By default, the UI for a TabbedPatientListGroup is shown at the top of any member PatientList as long as there are more than one members of the group visible to the given user. This behaviour can be customised by overriding the visible_to classmethod: class MyListGroup(patient_lists.TabbedPatientListGroup): @classmethod def visible_to(klass, user): # return True or False appropriately","title":"Restricting access"},{"location":"guides/list_views/#customising-templates","text":"Applications may customise the UI for Tabbed Patient List Groups by customising the template patient_lists/tabbed_list_group.html . The default template simply extends patient_lists/tabbed_list_group_base.html .","title":"Customising templates"},{"location":"guides/lookup_lists/","text":"","title":"Lookup lists"},{"location":"guides/metadata/","text":"Application Metadata Applications commonly need to pass data to the front end which is not either clinical data about a patient or episode of care, or coded reference data . Opal provides a simple API for working with such data via the opal.core.metadata.Metadata discoverable . metadata is made available on the scopes for patient lists and patient details Defining Metadata Defining metadata uses the same pattern as all discoverable features, we define a subclass: from django.conf import settings from opal.core import metadata class FavouriteColours(metadata.Metadata): slug = 'favourite-colour' @classmethod def to_dict(klass, **kwargs): return {'favourite_colour': settings.FAVOURITE_COLOUR} The to_dict method will be passed the current user as a keyword argument. Accessing Metadata on the front end We can access our metadata with the Angular Metadata service. // yourapp/routes.js when('/my/route', { controller: 'MyCtrl', resolve: { metadata: function(Metadata){ return Metadata; } } } // yourapp/yourctrl.js angular.module('yourapp.controllers').controller( 'MyCtrl', function($scope, metadata){ $scope.favourite_colour = metadata.favourite_colour; console.log($scope.favourite_colour); // - Whatever settings.FAVOURITE_COLOUR is set to });","title":"Metadata"},{"location":"guides/metadata/#application-metadata","text":"Applications commonly need to pass data to the front end which is not either clinical data about a patient or episode of care, or coded reference data . Opal provides a simple API for working with such data via the opal.core.metadata.Metadata discoverable . metadata is made available on the scopes for patient lists and patient details","title":"Application Metadata"},{"location":"guides/metadata/#defining-metadata","text":"Defining metadata uses the same pattern as all discoverable features, we define a subclass: from django.conf import settings from opal.core import metadata class FavouriteColours(metadata.Metadata): slug = 'favourite-colour' @classmethod def to_dict(klass, **kwargs): return {'favourite_colour': settings.FAVOURITE_COLOUR} The to_dict method will be passed the current user as a keyword argument.","title":"Defining Metadata"},{"location":"guides/metadata/#accessing-metadata-on-the-front-end","text":"We can access our metadata with the Angular Metadata service. // yourapp/routes.js when('/my/route', { controller: 'MyCtrl', resolve: { metadata: function(Metadata){ return Metadata; } } } // yourapp/yourctrl.js angular.module('yourapp.controllers').controller( 'MyCtrl', function($scope, metadata){ $scope.favourite_colour = metadata.favourite_colour; console.log($scope.favourite_colour); // - Whatever settings.FAVOURITE_COLOUR is set to });","title":"Accessing Metadata on the front end"},{"location":"guides/pathways/","text":"Guide: The pathway module The pathway module provides developers with a highly extensible method of working with complex forms. Typically pathways are forms that allow the user to enter information that spans multiple Subrecords - which can be challenging with the Subrecord forms . The pathway provides Wizards, long multi-model forms, custom validation and much more, all usable either in full page or modal contexts. If you're new to using pathways, you might like to go through the Pathway tutorial . See the Pathway reference documentation for detailed class and method level information on the pathway module. Pathway steps A pathway is comprised of a sequence of Step s. These are sections within a form. They can be defined as HTML forms with custom attributes and Angular controllers, or inferred by passing models to the steps attribute of your pathway. In the simplest case a pathway re-uses the forms for a sequence of subrecords, and we would create one by subclassing opal.core.pathway.PagePathway in a file called {{ your app }}/pathways.py like so: from opal.core import pathway from myapp import models class SimplePathway(pathway.PagePathway): display_name = 'A simple pathway' slug = simples steps = ( models.Demographics, models.PastMedicalHistory ) This will give you form at http://localhost:8000/pathway/#/simples that lets the user create a patient with their demographics and past medical history Customising Steps When passed a model, a step will infer the details of form templates, display names et cetera from the subrecord. However a model is not required - you can also pass arbitrary chunks of html with the two required fields: Step( template= pathway/steps/my_step.html display_name= My Display Only Step ) Alternatively, you can override any fields that it would usually take from the model. The below example, will override the template and not just use the Demographics form template. Step( template= pathway/steps/my_step.html model=Demographics ) The Step.base_template wraps the form template for each step. By default this is a bootstrap panel, with the step display name and step icon in the header and the form template in the panel body. You can override this by overriding the base_template . Step( base_template= pathway/steps/addicted_to_base.html model=Demographics ) If you want to add any custom save logic for your step, you can put in a pre_save method. This is passed the full data dictionary that has been received from the client and the patient and episode that the pathways been saved for, if they exist (If you're saving a pathway for a new patient/episode, they won't have been created at this time). Loading Data From Existing Episodes A URL without a patient id or episode id will create a new patent/episode when you save it. To update a particular patient with a new episode, the URL should be: http://localhost:8000/pathway/#/simples/{{ patient_id }} To update a particular episode the URL should be: http://localhost:8000/pathway/#/simples/{{ patient_id }}/{{ episode_id }} When you visit these urls with the ids for existing patients and episodes, the form will be prepulated with the existing data for that patient/episode. Multiple Instances Of Records If the model is not a singleton, by default it will be show in the form as a multiple section that allows the user to add one or more models. If you don't wish this to happen, pass multiple=False to the Step This displays a delete button for existing subrecords. By default, any subrecords that are deleted, or are not included in the data sent back to the server are deleted. If you don't wish this to happen, pass delete_others=False to the Step. from opal.core import pathway from myapp import models class SimplePathway(pathway.Pathway): display_name = 'A simple pathway' slug = 'simples' steps = ( pathway.Step(model=models.Allergies, delete_others=True), models.Treatment, models.PastMedicalHistory ) In this case, the pathway will delete any existing instances of the given Subrecord Model that are not sent back to the API in the JSON data. Complex Steps If we want to save multiple types of subrecords at the same step, we can do that by including the relevant form templates in a custom step template. from opal.core import pathway from myapp import models class SimplePathway(pathway.Pathway): display_name = 'A simple pathway' slug = 'simples' steps = ( pathways.Step( display_name='Demographics and Diagnosis', icon='fa fa-clock', template='pathways/demographics_and_diagnosis_step.html' ), ) The display name and icon are rendered in the header for this step in your pathway, which exist outside the scope of the step template itself. Then all we would need is the template itself: !-- pathways/demographics_and_diagnosis_step.html -- {% include models.Demographics.get_form_template %} {% include models.Diagnosis.get_form_template %} Pathways created in this way will not add in the model defaults. Complex step logic Pathway steps can be rendered with a custom controller. You can do this by declaring an angular step in your controller. steps = ( Step( model=MyModel, step_controller= FindPatientCtrl , ), ) Your javascript controller should then look something like... angular.module('opal.controllers').controller('FindPatientCtrl', function(scope, step, episode) { use strict ; // your custom logic }); oWe can pass in custom controllers to individual steps. Custom controllers are sandboxed, they share scope.editing with other scopes but nothing else. The scope passed in comes with reference data and meta data set as attributes. It also comes with the scope.editing. This is the dictionary that will appear in the form and will be saved back at the end. The step is the step definition from the server - the output of step.to_dict . The episode is an instance of the javascript Episode class - not the output of Episode.makeCopy() . Before a copy of the form data is sent back to the server, it is passed to the preSave method of each step controller. Step controllers may alter this data here if required to e.g. add implicit data points not contained in the form. Complex Steps With Multiple Instances Per Subrecord If we need to also save multiple types of the same subrecord e.g. Treatment in this step, we simply use the multisave template tag. {% load pathways %} {% include models.Demographics.get_form_template %} {% include models.Diagnosis.get_form_template %} {% multisave models.Treatment %} Alternatively you may want to create your own multisave step forms, you can use the directive multi-save-wrapper for this. div save-multiple-wrapper= editing.treatment div ng-repeat= editing in model.subrecords {% input field= Treatment.drug %} button ng-click= remove($index) /button /div button ng-click= addAnother() /button /div Validation If you want to add custom validation, the method StepController.valid(form) is called on each step controller. This means you can set validation rules on the form. An invalid form will have the save button disabled, until the form is valid. Wizards Wizard pathways look for a hideFooter variable that defaults to false. If set to true, this will hide the default next/save button. If you don't want the wizard pathway to be a linear progression. This is useful when you want the user to go to different steps based on options they chose. If you want to handle complex order, this is best done in a custom controller for you step class. You can set this with. Success Redirects Often, after successfully saving a pathway, we want to redirect the user to a different URL - we do this by overriding the redirect_url method on the pathway. For example - to create a pathway that always logged the user out after a successful save: class LogoutPathway(pathway.Pathway): display_name = 'Logout-O-Matic' steps = (...) def redirect_url(self, patient): return '/accounts/logout/' Redirect Mixins By default any full page pathway (ie not a modal) will redirect to the episode detail view of that episode. If you do not wish this to be the case you can override the redirect_url. Pathways comes with the RedirectsToPatientMixin , which redirects to the Patient detail view and can be used as follows. from opal.core.pathway import RedirectsToPatientMixin class PatientRedirectPathway(pathway.RedirectsToPatientMixin, pathway.PagePathway): display_name = 'Redirector example Pathway' steps = (...) Modal Pathways Pathways detect when you're opening a pathway from a modal. You can use a different template for your modal pathway by adding a modal_template attribute to your pathway Pathways ships with a no footer modal template, the same as the normal modal template but it doesn't display the section at the bottom with the save/cancel button. To open a modal pathway in a template you can use the open-pathway directive: a open-pathway= test_results open test results pathway /a The open-pathway directive also includes an optional callback, that is called with the context of the result of the modal.save method, ie episode_id, patient_id and redirect_url. By default the pathway is opened with whichever episode is on $scope.episode, you can use pathway-episode to define a different episode. a open-pathway= test_results pathway-episode= someOtherEpisode pathway-callback= refreshEpisode(episode_id) open test results pathway /a","title":"Pathway Overview"},{"location":"guides/pathways/#guide-the-pathway-module","text":"The pathway module provides developers with a highly extensible method of working with complex forms. Typically pathways are forms that allow the user to enter information that spans multiple Subrecords - which can be challenging with the Subrecord forms . The pathway provides Wizards, long multi-model forms, custom validation and much more, all usable either in full page or modal contexts. If you're new to using pathways, you might like to go through the Pathway tutorial . See the Pathway reference documentation for detailed class and method level information on the pathway module.","title":"Guide: The pathway module"},{"location":"guides/pathways/#pathway-steps","text":"A pathway is comprised of a sequence of Step s. These are sections within a form. They can be defined as HTML forms with custom attributes and Angular controllers, or inferred by passing models to the steps attribute of your pathway. In the simplest case a pathway re-uses the forms for a sequence of subrecords, and we would create one by subclassing opal.core.pathway.PagePathway in a file called {{ your app }}/pathways.py like so: from opal.core import pathway from myapp import models class SimplePathway(pathway.PagePathway): display_name = 'A simple pathway' slug = simples steps = ( models.Demographics, models.PastMedicalHistory ) This will give you form at http://localhost:8000/pathway/#/simples that lets the user create a patient with their demographics and past medical history","title":"Pathway steps"},{"location":"guides/pathways/#customising-steps","text":"When passed a model, a step will infer the details of form templates, display names et cetera from the subrecord. However a model is not required - you can also pass arbitrary chunks of html with the two required fields: Step( template= pathway/steps/my_step.html display_name= My Display Only Step ) Alternatively, you can override any fields that it would usually take from the model. The below example, will override the template and not just use the Demographics form template. Step( template= pathway/steps/my_step.html model=Demographics ) The Step.base_template wraps the form template for each step. By default this is a bootstrap panel, with the step display name and step icon in the header and the form template in the panel body. You can override this by overriding the base_template . Step( base_template= pathway/steps/addicted_to_base.html model=Demographics ) If you want to add any custom save logic for your step, you can put in a pre_save method. This is passed the full data dictionary that has been received from the client and the patient and episode that the pathways been saved for, if they exist (If you're saving a pathway for a new patient/episode, they won't have been created at this time).","title":"Customising Steps"},{"location":"guides/pathways/#loading-data-from-existing-episodes","text":"A URL without a patient id or episode id will create a new patent/episode when you save it. To update a particular patient with a new episode, the URL should be: http://localhost:8000/pathway/#/simples/{{ patient_id }} To update a particular episode the URL should be: http://localhost:8000/pathway/#/simples/{{ patient_id }}/{{ episode_id }} When you visit these urls with the ids for existing patients and episodes, the form will be prepulated with the existing data for that patient/episode.","title":"Loading Data From Existing Episodes"},{"location":"guides/pathways/#multiple-instances-of-records","text":"If the model is not a singleton, by default it will be show in the form as a multiple section that allows the user to add one or more models. If you don't wish this to happen, pass multiple=False to the Step This displays a delete button for existing subrecords. By default, any subrecords that are deleted, or are not included in the data sent back to the server are deleted. If you don't wish this to happen, pass delete_others=False to the Step. from opal.core import pathway from myapp import models class SimplePathway(pathway.Pathway): display_name = 'A simple pathway' slug = 'simples' steps = ( pathway.Step(model=models.Allergies, delete_others=True), models.Treatment, models.PastMedicalHistory ) In this case, the pathway will delete any existing instances of the given Subrecord Model that are not sent back to the API in the JSON data.","title":"Multiple Instances Of Records"},{"location":"guides/pathways/#complex-steps","text":"If we want to save multiple types of subrecords at the same step, we can do that by including the relevant form templates in a custom step template. from opal.core import pathway from myapp import models class SimplePathway(pathway.Pathway): display_name = 'A simple pathway' slug = 'simples' steps = ( pathways.Step( display_name='Demographics and Diagnosis', icon='fa fa-clock', template='pathways/demographics_and_diagnosis_step.html' ), ) The display name and icon are rendered in the header for this step in your pathway, which exist outside the scope of the step template itself. Then all we would need is the template itself: !-- pathways/demographics_and_diagnosis_step.html -- {% include models.Demographics.get_form_template %} {% include models.Diagnosis.get_form_template %} Pathways created in this way will not add in the model defaults.","title":"Complex Steps"},{"location":"guides/pathways/#complex-step-logic","text":"Pathway steps can be rendered with a custom controller. You can do this by declaring an angular step in your controller. steps = ( Step( model=MyModel, step_controller= FindPatientCtrl , ), ) Your javascript controller should then look something like... angular.module('opal.controllers').controller('FindPatientCtrl', function(scope, step, episode) { use strict ; // your custom logic }); oWe can pass in custom controllers to individual steps. Custom controllers are sandboxed, they share scope.editing with other scopes but nothing else. The scope passed in comes with reference data and meta data set as attributes. It also comes with the scope.editing. This is the dictionary that will appear in the form and will be saved back at the end. The step is the step definition from the server - the output of step.to_dict . The episode is an instance of the javascript Episode class - not the output of Episode.makeCopy() . Before a copy of the form data is sent back to the server, it is passed to the preSave method of each step controller. Step controllers may alter this data here if required to e.g. add implicit data points not contained in the form.","title":"Complex step logic"},{"location":"guides/pathways/#complex-steps-with-multiple-instances-per-subrecord","text":"If we need to also save multiple types of the same subrecord e.g. Treatment in this step, we simply use the multisave template tag. {% load pathways %} {% include models.Demographics.get_form_template %} {% include models.Diagnosis.get_form_template %} {% multisave models.Treatment %} Alternatively you may want to create your own multisave step forms, you can use the directive multi-save-wrapper for this. div save-multiple-wrapper= editing.treatment div ng-repeat= editing in model.subrecords {% input field= Treatment.drug %} button ng-click= remove($index) /button /div button ng-click= addAnother() /button /div","title":"Complex Steps With Multiple Instances Per Subrecord"},{"location":"guides/pathways/#validation","text":"If you want to add custom validation, the method StepController.valid(form) is called on each step controller. This means you can set validation rules on the form. An invalid form will have the save button disabled, until the form is valid.","title":"Validation"},{"location":"guides/pathways/#wizards","text":"Wizard pathways look for a hideFooter variable that defaults to false. If set to true, this will hide the default next/save button. If you don't want the wizard pathway to be a linear progression. This is useful when you want the user to go to different steps based on options they chose. If you want to handle complex order, this is best done in a custom controller for you step class. You can set this with.","title":"Wizards"},{"location":"guides/pathways/#success-redirects","text":"Often, after successfully saving a pathway, we want to redirect the user to a different URL - we do this by overriding the redirect_url method on the pathway. For example - to create a pathway that always logged the user out after a successful save: class LogoutPathway(pathway.Pathway): display_name = 'Logout-O-Matic' steps = (...) def redirect_url(self, patient): return '/accounts/logout/'","title":"Success Redirects"},{"location":"guides/pathways/#redirect-mixins","text":"By default any full page pathway (ie not a modal) will redirect to the episode detail view of that episode. If you do not wish this to be the case you can override the redirect_url. Pathways comes with the RedirectsToPatientMixin , which redirects to the Patient detail view and can be used as follows. from opal.core.pathway import RedirectsToPatientMixin class PatientRedirectPathway(pathway.RedirectsToPatientMixin, pathway.PagePathway): display_name = 'Redirector example Pathway' steps = (...)","title":"Redirect Mixins"},{"location":"guides/pathways/#modal-pathways","text":"Pathways detect when you're opening a pathway from a modal. You can use a different template for your modal pathway by adding a modal_template attribute to your pathway Pathways ships with a no footer modal template, the same as the normal modal template but it doesn't display the section at the bottom with the save/cancel button. To open a modal pathway in a template you can use the open-pathway directive: a open-pathway= test_results open test results pathway /a The open-pathway directive also includes an optional callback, that is called with the context of the result of the modal.save method, ie episode_id, patient_id and redirect_url. By default the pathway is opened with whichever episode is on $scope.episode, you can use pathway-episode to define a different episode. a open-pathway= test_results pathway-episode= someOtherEpisode pathway-callback= refreshEpisode(episode_id) open test results pathway /a","title":"Modal Pathways"},{"location":"guides/patient_detail_views/","text":"Opal Patient Detail Views Opal provides all patients with a detail view. The default detail view will allow the user to switch between all of a patient's episodes , as well as editing patient information linked to the patient rather than an episode. (Allergies for example.) Template selection The base template for a patient detail view is ./opal/templates/patient_detail_base.html , although you can override or customise that for your application most easily by implementing a ./templates/patient_detail.html and customising specific blocks, as the Opal implementation simply includes the base template. Each episode will display using the template appropriate for it's EpisodeCategory - for instance an InpatientEpisode will use ./templates/detail/inpatient.html . You may define your own episode types should you require. Record Panels A frequent pattern when constructing detail views is to render a panel for a particular Subrecord type. The panels templatetag library contains some useful helpers for rendering panels based on models. {% load panels %} {% record_panel Diagnosis %} The above code will render a panel for your episode, including the Subrecord detail template for each instance, and allowing editing, deletion and creation of instances of your Subrecord . You may also consult the Detailed reference documentation for Record Panels. Custom Patient Detail Views Sometimes we also need to display information about a patient across multiple episodes, or simply a particular view of one episode. For instance, you might like to have a specific view for showing all of the lab results for a patient, which would be overwhelming were they all displayed in the episode detail view. Opal's PatientDetailView allows you to do just this. To add an additional view to a patient you simply declare a PatientDetailView class: # detail.py from opal.core import detail class MyCustomView(detail.PatientDetailView): name = 'my_custom_view' title = 'Special View' template = 'detail/my_custom_view.html' This will then be available in the Patient Detail view in the episode switcher menu. You can find details of all the various options for PatientDetailViews in the reference documentation .","title":"Patient Detail Views"},{"location":"guides/patient_detail_views/#opal-patient-detail-views","text":"Opal provides all patients with a detail view. The default detail view will allow the user to switch between all of a patient's episodes , as well as editing patient information linked to the patient rather than an episode. (Allergies for example.)","title":"Opal Patient Detail Views"},{"location":"guides/patient_detail_views/#template-selection","text":"The base template for a patient detail view is ./opal/templates/patient_detail_base.html , although you can override or customise that for your application most easily by implementing a ./templates/patient_detail.html and customising specific blocks, as the Opal implementation simply includes the base template. Each episode will display using the template appropriate for it's EpisodeCategory - for instance an InpatientEpisode will use ./templates/detail/inpatient.html . You may define your own episode types should you require.","title":"Template selection"},{"location":"guides/patient_detail_views/#record-panels","text":"A frequent pattern when constructing detail views is to render a panel for a particular Subrecord type. The panels templatetag library contains some useful helpers for rendering panels based on models. {% load panels %} {% record_panel Diagnosis %} The above code will render a panel for your episode, including the Subrecord detail template for each instance, and allowing editing, deletion and creation of instances of your Subrecord . You may also consult the Detailed reference documentation for Record Panels.","title":"Record Panels"},{"location":"guides/patient_detail_views/#custom-patient-detail-views","text":"Sometimes we also need to display information about a patient across multiple episodes, or simply a particular view of one episode. For instance, you might like to have a specific view for showing all of the lab results for a patient, which would be overwhelming were they all displayed in the episode detail view. Opal's PatientDetailView allows you to do just this. To add an additional view to a patient you simply declare a PatientDetailView class: # detail.py from opal.core import detail class MyCustomView(detail.PatientDetailView): name = 'my_custom_view' title = 'Special View' template = 'detail/my_custom_view.html' This will then be available in the Patient Detail view in the episode switcher menu. You can find details of all the various options for PatientDetailViews in the reference documentation .","title":"Custom Patient Detail Views"},{"location":"guides/plugins/","text":"Writing Plugins Opal Plugins are Django apps on the server side, and collections of angular.js models for the client. Getting started with your plugin The Opal commandline tool will bootstrap your plugin for you - just run: $ opal startplugin yourcoolplugin Adding Discoverable Functionality A common pattern for plugins is to add functionality that other plugins or applications can use by inheriting a base class that you define in a file with a magic name. (In much the same way that Django provides models.) For example, if you're creating an appointments plugin that helps people to book and schedule appointments in clinics, you would create a base Clinic class that can be subclassed to create specific clinics. class Clinic(opal.core.discoverable.DiscoverableFeature): module_name = 'clinics' We can then create clinics in any installed app, and they will be available from Clinic.list() class OutpatientsClinic(Clinic): name = 'Outpatients' # Add your custom clinic functionality here e.g. def book_appointment(self, date, patient): pass Clinic.list() # - Generator including OutPatientsClinic Clinic.get('outpatients) # - OutpatientsClinic Getting a plugin directory Each plugin has a directory() method that returns the file system location of the module. Adding URLS Add an urls.py, then add to your plugin class as YourPlugin.urls Naturally, these can point to views in your plugin! Adding Javascript Add to static, then add to your plugin class as YourPlugin.javascripts There are some restricted namespaces for these... Adding APIs Opal uses Django Rest Framework to provide APIs, and you may add to these from your plugin. By convention, APIs live in yourplugin/api.py . You are expected to provide a rest_framework.viewsets.ViewSet subclass, which you then detail as the .apis attribute of your plugin. # yourplugin/api.py from rest_framework.viewsets import ViewSet from rest_framework.response import Response class PingViewSet(ViewSet): def list(self, request): return Response('pong') # yourplugin/plugin.py from opal.core.plugins import OpalPlugin from yourplugin import api class YourPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ] These APIs will then be available and self-documenting from the standard Opal url /api/v0.1/ Permissioning Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. Django Rest Framework ViewSet classes have an extensive permissioning system . Opal ships with the base ViewSet class opal.core.api.LoginRequiredViewset which adds the Django Rest Framework permission class IsAuthenticated to your viewset. class PingViewSet(LoginRequiredViewset): def list(self, request): return Response('pong') Adding Actions to the sidebar Actions can be added to the sidebar by setting the actions attribute of your plugin. Actions is expected to be an iterable of strings which are templates to be included in the sidebar. By convention, actions will live in ./templates/actions/ . # plugin.py: class Plugin(OpalPlugin): actions = ('actions/javascript_alert.html', 'actions/dummy_button.html') And then in the template: p ng-show= episode.category == 'YourEpisodeCategory' button class= btn btn-primary ng-click= alert('Boom!') i href= fa fa-warning /i ALERT ME /button /p Adding dependencies globally to our angular modules Dependencies listed in angular_module_deps will be added to all Angular modules (as long as they use the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we won't for now. Adding Menu items Plugins may add items to the main Opal Menu by setting the menuitems attribute. This attribute should be an iterable of MenuItem objects. from opal.core import menus class YourPlugin(OpalPlugin): menuitems = [ menus.MenuItem(href= /your-url , icon= fa-user ) ] Installing plugins Add the plugin's name to the INSTALLED_APPS list in your settings.py Add the plugin's name to requirements.txt and run pip install -r requirements.txt (if appropriate, eg if you are distributing your plugin via Pypi or GitHub) Adding extra markup to the tag Any templates you define in the property .head_extra will be included in the","title":"Plugins"},{"location":"guides/plugins/#writing-plugins","text":"Opal Plugins are Django apps on the server side, and collections of angular.js models for the client.","title":"Writing Plugins"},{"location":"guides/plugins/#getting-started-with-your-plugin","text":"The Opal commandline tool will bootstrap your plugin for you - just run: $ opal startplugin yourcoolplugin","title":"Getting started with your plugin"},{"location":"guides/plugins/#adding-discoverable-functionality","text":"A common pattern for plugins is to add functionality that other plugins or applications can use by inheriting a base class that you define in a file with a magic name. (In much the same way that Django provides models.) For example, if you're creating an appointments plugin that helps people to book and schedule appointments in clinics, you would create a base Clinic class that can be subclassed to create specific clinics. class Clinic(opal.core.discoverable.DiscoverableFeature): module_name = 'clinics' We can then create clinics in any installed app, and they will be available from Clinic.list() class OutpatientsClinic(Clinic): name = 'Outpatients' # Add your custom clinic functionality here e.g. def book_appointment(self, date, patient): pass Clinic.list() # - Generator including OutPatientsClinic Clinic.get('outpatients) # - OutpatientsClinic","title":"Adding Discoverable Functionality"},{"location":"guides/plugins/#getting-a-plugin-directory","text":"Each plugin has a directory() method that returns the file system location of the module.","title":"Getting a plugin directory"},{"location":"guides/plugins/#adding-urls","text":"Add an urls.py, then add to your plugin class as YourPlugin.urls Naturally, these can point to views in your plugin!","title":"Adding URLS"},{"location":"guides/plugins/#adding-javascript","text":"Add to static, then add to your plugin class as YourPlugin.javascripts There are some restricted namespaces for these...","title":"Adding Javascript"},{"location":"guides/plugins/#adding-apis","text":"Opal uses Django Rest Framework to provide APIs, and you may add to these from your plugin. By convention, APIs live in yourplugin/api.py . You are expected to provide a rest_framework.viewsets.ViewSet subclass, which you then detail as the .apis attribute of your plugin. # yourplugin/api.py from rest_framework.viewsets import ViewSet from rest_framework.response import Response class PingViewSet(ViewSet): def list(self, request): return Response('pong') # yourplugin/plugin.py from opal.core.plugins import OpalPlugin from yourplugin import api class YourPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ] These APIs will then be available and self-documenting from the standard Opal url /api/v0.1/","title":"Adding APIs"},{"location":"guides/plugins/#permissioning","text":"Developers are strongly encouraged to ensure that APIs which serve patient data are restricted to logged in users. Django Rest Framework ViewSet classes have an extensive permissioning system . Opal ships with the base ViewSet class opal.core.api.LoginRequiredViewset which adds the Django Rest Framework permission class IsAuthenticated to your viewset. class PingViewSet(LoginRequiredViewset): def list(self, request): return Response('pong')","title":"Permissioning"},{"location":"guides/plugins/#adding-actions-to-the-sidebar","text":"Actions can be added to the sidebar by setting the actions attribute of your plugin. Actions is expected to be an iterable of strings which are templates to be included in the sidebar. By convention, actions will live in ./templates/actions/ . # plugin.py: class Plugin(OpalPlugin): actions = ('actions/javascript_alert.html', 'actions/dummy_button.html') And then in the template: p ng-show= episode.category == 'YourEpisodeCategory' button class= btn btn-primary ng-click= alert('Boom!') i href= fa fa-warning /i ALERT ME /button /p","title":"Adding Actions to the sidebar"},{"location":"guides/plugins/#adding-dependencies-globally-to-our-angular-modules","text":"Dependencies listed in angular_module_deps will be added to all Angular modules (as long as they use the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we won't for now.","title":"Adding dependencies globally to our angular modules"},{"location":"guides/plugins/#adding-menu-items","text":"Plugins may add items to the main Opal Menu by setting the menuitems attribute. This attribute should be an iterable of MenuItem objects. from opal.core import menus class YourPlugin(OpalPlugin): menuitems = [ menus.MenuItem(href= /your-url , icon= fa-user ) ]","title":"Adding Menu items"},{"location":"guides/plugins/#installing-plugins","text":"Add the plugin's name to the INSTALLED_APPS list in your settings.py Add the plugin's name to requirements.txt and run pip install -r requirements.txt (if appropriate, eg if you are distributing your plugin via Pypi or GitHub)","title":"Installing plugins"},{"location":"guides/plugins/#adding-extra-markup-to-the-tag","text":"Any templates you define in the property .head_extra will be included in the","title":"Adding extra markup to the  tag"},{"location":"guides/plugins_list/","text":"Opal Plugins list The Opal ecosystem has a rich array of re-usable Open Source plugins that can be used as composable units of functionality to build your application. This page lists some of the best available: opal.core.search The Search plugin bundled with Opal core provides a default database based search implementation for your application, and is scheduled to provide hooks for e.g. using Elastic Search as your search backend. opal-wardround The Wardround plugin provides structured virtual ward rounds - sequential subsets of patients matching arbitrary criteria that the user may step through in order. opal-dischargesummary The Discharge Summary plugin allows the user to generate templated letters from the data concerning an episode already held in the Application. opal-referral The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. opal-dashboard The Dashboard plugin allows for realtime clinical dashboards featuring arbitrary metrics, displayed within your application. opal-observations The Observations plugin caters for the recording and display of electronic observations data. opal-guidelines The Guidelines plugin presents contextual links to clinical guidelines in use at your institution when viewing records of patients whose condition matches those guidelines. Can be used with national or local guidelines. opal-pathway The Pathway plugin provides a comprehensive extensible forms library for Opal applications.","title":"Plugin List"},{"location":"guides/plugins_list/#opal-plugins-list","text":"The Opal ecosystem has a rich array of re-usable Open Source plugins that can be used as composable units of functionality to build your application. This page lists some of the best available:","title":"Opal Plugins list"},{"location":"guides/plugins_list/#opalcoresearch","text":"The Search plugin bundled with Opal core provides a default database based search implementation for your application, and is scheduled to provide hooks for e.g. using Elastic Search as your search backend.","title":"opal.core.search"},{"location":"guides/plugins_list/#opal-wardround","text":"The Wardround plugin provides structured virtual ward rounds - sequential subsets of patients matching arbitrary criteria that the user may step through in order.","title":"opal-wardround"},{"location":"guides/plugins_list/#opal-dischargesummary","text":"The Discharge Summary plugin allows the user to generate templated letters from the data concerning an episode already held in the Application.","title":"opal-dischargesummary"},{"location":"guides/plugins_list/#opal-referral","text":"The Referral plugin provides the plumbing for building complex inter-team referrals within an institution.","title":"opal-referral"},{"location":"guides/plugins_list/#opal-dashboard","text":"The Dashboard plugin allows for realtime clinical dashboards featuring arbitrary metrics, displayed within your application.","title":"opal-dashboard"},{"location":"guides/plugins_list/#opal-observations","text":"The Observations plugin caters for the recording and display of electronic observations data.","title":"opal-observations"},{"location":"guides/plugins_list/#opal-guidelines","text":"The Guidelines plugin presents contextual links to clinical guidelines in use at your institution when viewing records of patients whose condition matches those guidelines. Can be used with national or local guidelines.","title":"opal-guidelines"},{"location":"guides/plugins_list/#opal-pathway","text":"The Pathway plugin provides a comprehensive extensible forms library for Opal applications.","title":"opal-pathway"},{"location":"guides/referencedata/","text":"Reference data Lookup Lists allow us to create or reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. Core referencedata By default, Opal will install some lookuplists for common things such as countries, drugs, conditions, and symptoms amongst others. The data for these is found in the opal.core.referencedata package. Adding a lookup list Lookup lists are subclasses of opal.core.lookuplists.LookupList . Typically, a specific named lookup list will not need to do anything other than define a class that inherits from the base class. The custom field type opal.core.fields.ForeignKeyOrFreeText allows you to build interfaces that cater for synonyms, and also allow the user to enter a free text string that is not in the lookup list. # yourapp.models from django.db import models from opal.core import lookuplists from opal.core.fields import ForeignKeyOrFreeText from opal.models import EpisodeSubrecord class TreatmentType(lookuplists.LookupList): pass class Treatment(EpisodeSubrecord): treatment = ForeignKeyOrFreeText(TreatmentType) notes = models.CharField(max_length=200) When you create your lookup list, you are creating a new model, so you will need a new migration to accompany it. $ python manage.py schemamigration --atuo yourapp $ python manage.py migrate yourapp The lookup list will automatically be added to the admin, where you can manually add entries. Reference data JSON API Reference data is available over the Opal JSON API. You may either load all lookuplists at once via the /api/v0.1/referencedata/ endpoint, or individual lookuplists by name - for example all diagnoses from /api/v0.1/referencedata/diagnosis/ . The reference data API also loads all synonyms in a flat list - the conversion of synonyms to their canonical form is handled by the save mechanism of subrecords using ForeignKeyOrFreeText fields. Working with reference data on the front end The Angular service Referencedata can be used to fetch all lookuplists at once - for instance loaded in the Angular routing for a controller in your application when('/my/route', { controller: 'MyCtrl', resolve: { referencedata: function(Referencedata){ return Referencedata; } } } Lookuplists will then be available either as properties of the referencedata object. Using referencedata in forms The Opal form templatetag library allow us to easily incorporate referencedata into the forms we build, either by detecting their use automatically when we have ForeignKeyOrFreeText fields, or explicitly by passing an argument. {% load forms %} {% input field= Diagnosis.condition %} {% select label= List of Conditions lookuplist= referencedata.diagnosis %} Providing data for lookuplists Reference data can be provided at application or plugin level in a file named lookuplists.json found in the {{ app_or_plugin }}/data/lookuplists directory. This data should be in the Opal JSON format. The name value of each lookuplist should be the return value of that lookuplist's get_api_name() method (otherwise they will fail to load), these can be found via Schemas { name_of_lookuplist : [ { name : Value of lookuplist item , synonyms : [ Synonym 1 ,] }, ] } Once this data is stored in the lookuplists file, we can batch load it into our application with the command python manage.py load_lookup_lists Coding lookuplist values Often applications wish to use coded reference data from a pre-existing terminology such as SNOMED. This can be easily accomplished by adding coding values to the lookuplist JSON data. { name_of_lookuplist : [ { name : Value of lookuplist item , synonyms : [ Synonym 1 ,], coding : { system : SNOMED CT , code : 3428473 } }, ] } Management commands Opal ships with some management commands for importing and exporting lookup lists dump_lookup_lists Prints all loockuplists as JSON to stdout. When the --many-files argument is passd, the command will write each installed lookup list to a separate file in the ./data/lookuplists directory of the application. load_lookup_lists Loads lookup lists from all plugins/apps in the Opal JSON format. The lookup lists are expected to be in {{ app }}/data/lookuplists/lookuplists.json Optionally you can pass in an explicit filename with the -f argument. delete_all_lookup_lists Deletes all currently lookuplist values and related synonyms","title":"Referencedata"},{"location":"guides/referencedata/#reference-data","text":"Lookup Lists allow us to create or reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override.","title":"Reference data"},{"location":"guides/referencedata/#core-referencedata","text":"By default, Opal will install some lookuplists for common things such as countries, drugs, conditions, and symptoms amongst others. The data for these is found in the opal.core.referencedata package.","title":"Core referencedata"},{"location":"guides/referencedata/#adding-a-lookup-list","text":"Lookup lists are subclasses of opal.core.lookuplists.LookupList . Typically, a specific named lookup list will not need to do anything other than define a class that inherits from the base class. The custom field type opal.core.fields.ForeignKeyOrFreeText allows you to build interfaces that cater for synonyms, and also allow the user to enter a free text string that is not in the lookup list. # yourapp.models from django.db import models from opal.core import lookuplists from opal.core.fields import ForeignKeyOrFreeText from opal.models import EpisodeSubrecord class TreatmentType(lookuplists.LookupList): pass class Treatment(EpisodeSubrecord): treatment = ForeignKeyOrFreeText(TreatmentType) notes = models.CharField(max_length=200) When you create your lookup list, you are creating a new model, so you will need a new migration to accompany it. $ python manage.py schemamigration --atuo yourapp $ python manage.py migrate yourapp The lookup list will automatically be added to the admin, where you can manually add entries.","title":"Adding a lookup list"},{"location":"guides/referencedata/#reference-data-json-api","text":"Reference data is available over the Opal JSON API. You may either load all lookuplists at once via the /api/v0.1/referencedata/ endpoint, or individual lookuplists by name - for example all diagnoses from /api/v0.1/referencedata/diagnosis/ . The reference data API also loads all synonyms in a flat list - the conversion of synonyms to their canonical form is handled by the save mechanism of subrecords using ForeignKeyOrFreeText fields.","title":"Reference data JSON API"},{"location":"guides/referencedata/#working-with-reference-data-on-the-front-end","text":"The Angular service Referencedata can be used to fetch all lookuplists at once - for instance loaded in the Angular routing for a controller in your application when('/my/route', { controller: 'MyCtrl', resolve: { referencedata: function(Referencedata){ return Referencedata; } } } Lookuplists will then be available either as properties of the referencedata object.","title":"Working with reference data on the front end"},{"location":"guides/referencedata/#using-referencedata-in-forms","text":"The Opal form templatetag library allow us to easily incorporate referencedata into the forms we build, either by detecting their use automatically when we have ForeignKeyOrFreeText fields, or explicitly by passing an argument. {% load forms %} {% input field= Diagnosis.condition %} {% select label= List of Conditions lookuplist= referencedata.diagnosis %}","title":"Using referencedata in forms"},{"location":"guides/referencedata/#providing-data-for-lookuplists","text":"Reference data can be provided at application or plugin level in a file named lookuplists.json found in the {{ app_or_plugin }}/data/lookuplists directory. This data should be in the Opal JSON format. The name value of each lookuplist should be the return value of that lookuplist's get_api_name() method (otherwise they will fail to load), these can be found via Schemas { name_of_lookuplist : [ { name : Value of lookuplist item , synonyms : [ Synonym 1 ,] }, ] } Once this data is stored in the lookuplists file, we can batch load it into our application with the command python manage.py load_lookup_lists","title":"Providing data for lookuplists"},{"location":"guides/referencedata/#coding-lookuplist-values","text":"Often applications wish to use coded reference data from a pre-existing terminology such as SNOMED. This can be easily accomplished by adding coding values to the lookuplist JSON data. { name_of_lookuplist : [ { name : Value of lookuplist item , synonyms : [ Synonym 1 ,], coding : { system : SNOMED CT , code : 3428473 } }, ] }","title":"Coding lookuplist values"},{"location":"guides/referencedata/#management-commands","text":"Opal ships with some management commands for importing and exporting lookup lists","title":"Management commands"},{"location":"guides/referencedata/#dump_lookup_lists","text":"Prints all loockuplists as JSON to stdout. When the --many-files argument is passd, the command will write each installed lookup list to a separate file in the ./data/lookuplists directory of the application.","title":"dump_lookup_lists"},{"location":"guides/referencedata/#load_lookup_lists","text":"Loads lookup lists from all plugins/apps in the Opal JSON format. The lookup lists are expected to be in {{ app }}/data/lookuplists/lookuplists.json Optionally you can pass in an explicit filename with the -f argument.","title":"load_lookup_lists"},{"location":"guides/referencedata/#delete_all_lookup_lists","text":"Deletes all currently lookuplist values and related synonyms","title":"delete_all_lookup_lists"},{"location":"guides/releasing/","text":"Making a Release Make and deploy a version to test it on a windows machines. Tag the HEAD of the release branch and push to github: git tag version git push --tags . Opal branch names are in the format vX.Y.Z the tag for a release should be the X.Y.Z component of the branch name. Check version is correct in _version.py . Make sure you have twine installed and then: make release Merge the branch you are releasing into master Update the Github release page and make sure that it has the relevant Changelog contents. If the branch for the next version does not already exist, create that branch. For instance, if you have released x.y.z then create x.y.(z+1) . If you are creating a new version branch, ensure you have also changed the version number in the documentation, opal._version.__version__ , and the branches that any badges in the project README are pointing at. Change the github default branch to be the new in development version Update the Opal website: Change the current release and development version on the homepage, and run rake docs to regenerate the documentation site with a new latest stable release version. Post to the Opal mailing list to announce the new release.","title":"Releasing"},{"location":"guides/releasing/#making-a-release","text":"Make and deploy a version to test it on a windows machines. Tag the HEAD of the release branch and push to github: git tag version git push --tags . Opal branch names are in the format vX.Y.Z the tag for a release should be the X.Y.Z component of the branch name. Check version is correct in _version.py . Make sure you have twine installed and then: make release Merge the branch you are releasing into master Update the Github release page and make sure that it has the relevant Changelog contents. If the branch for the next version does not already exist, create that branch. For instance, if you have released x.y.z then create x.y.(z+1) . If you are creating a new version branch, ensure you have also changed the version number in the documentation, opal._version.__version__ , and the branches that any badges in the project README are pointing at. Change the github default branch to be the new in development version Update the Opal website: Change the current release and development version on the homepage, and run rake docs to regenerate the documentation site with a new latest stable release version. Post to the Opal mailing list to announce the new release.","title":"Making a Release"},{"location":"guides/roles_and_permissions/","text":"Roles Permissions in Opal Opal provides some global per-user flags, which are set in the UserProfile model, as well as more detailed permissions available via roles. The UserProfile model Some global properties about Users are set in the opal.models.UserProfile model. UserProfile._can_extract Boolean flag to determine whether this user is allowed to download data extracts from the system UserProfile._force_password_change Boolean flag to determine whether we would like to force this user to change their password on their next login. This defaults to True when the User is first created. UserProfile._readonly Boolean flag to determine whether this user has read-only access. UserProfile._restricted_only Boolean flag to determine whether this user should be only shown teams for which they have explicitly been given permission to view or whether they should also see the list of general access teams. UserProfile.get_roles() Return a dictionary of roles in various contexts for our user profile.get_roles() # - { 'default': ['doctor'], 'some_research_study': ['Clinical Lead'] } UserProfile.get_teams() Return a list of Team objects that this user should be allowed to see. Roles A user may be given a particular role. These can be either global - in which case they are returned in the 'default' section of the roles dict from get_roles() , or specific to a team.","title":"Roles & Permissions"},{"location":"guides/roles_and_permissions/#roles-permissions-in-opal","text":"Opal provides some global per-user flags, which are set in the UserProfile model, as well as more detailed permissions available via roles.","title":"Roles &amp; Permissions in Opal"},{"location":"guides/roles_and_permissions/#the-userprofile-model","text":"Some global properties about Users are set in the opal.models.UserProfile model.","title":"The UserProfile model"},{"location":"guides/roles_and_permissions/#userprofile_can_extract","text":"Boolean flag to determine whether this user is allowed to download data extracts from the system","title":"UserProfile._can_extract"},{"location":"guides/roles_and_permissions/#userprofile_force_password_change","text":"Boolean flag to determine whether we would like to force this user to change their password on their next login. This defaults to True when the User is first created.","title":"UserProfile._force_password_change"},{"location":"guides/roles_and_permissions/#userprofile_readonly","text":"Boolean flag to determine whether this user has read-only access.","title":"UserProfile._readonly"},{"location":"guides/roles_and_permissions/#userprofile_restricted_only","text":"Boolean flag to determine whether this user should be only shown teams for which they have explicitly been given permission to view or whether they should also see the list of general access teams.","title":"UserProfile._restricted_only"},{"location":"guides/roles_and_permissions/#userprofileget_roles","text":"Return a dictionary of roles in various contexts for our user profile.get_roles() # - { 'default': ['doctor'], 'some_research_study': ['Clinical Lead'] }","title":"UserProfile.get_roles()"},{"location":"guides/roles_and_permissions/#userprofileget_teams","text":"Return a list of Team objects that this user should be allowed to see.","title":"UserProfile.get_teams()"},{"location":"guides/roles_and_permissions/#roles","text":"A user may be given a particular role. These can be either global - in which case they are returned in the 'default' section of the roles dict from get_roles() , or specific to a team.","title":"Roles"},{"location":"guides/search/","text":"Opal Search overview The Opal Search backend is switchable using the settings value OPAL_SEARCH_BACKEND. By default it will do a database query. The backend takes in a dictionary with the following fields { queryType : either Equals or Contains , field : the label of the column that will be queried, e.g. Hospital Number, query : the value to be queried, e.g. 1111 , 'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries 'column': the model to be queried e.g. 'demographics' } The Advanced search interface The Opal advanced search interface at /#/extract allows users to specify rules by which to query for episodes. By default this allows users to construct simple logical queries based on the values of any subrecord field. The interface respects the types of fields - for instance using before/after for date fields or equals/contains for text fields. This screen also allows users to download episode data for the cohort that matches the specified rules. Custom Search Rules These rules are extensible, allowing custom rules that perform more advanced queries to be inserted. opal.core.search.SearchRule Is a discoverable . It is defined with a group of SearchRuleFields that appear like subrecord model fields in the front end. The SearchRuleField has a query method that returns a list of Episodes. The SearchRuleField must define a field_type, these then provide the following operators to the front end field_type queryType string equals, contains date_time before, after date before, after boolean true, false null_boolean true, false many_to_many a list of the lookup list for this field many_to_many_multi_select a multi select field, defined by the enum field from the rule ie if you state the field is a string, the user will be provided with an equals/contains, which will be passed to the query as given_query[\"queryType\"] For example class SomeField(SearchRuleField): display_name = Some Field # the display name of the field description = A Description for the user to explain what this field means field_type = date_time # what kind of filter that is offered, datetime will off before and after def query(self, given_query): return Episode.objects.all() class MyCustomQuery(SearchRule): display_name = My Custom Query fields = (SomeField,) Autocomplete search Opal contains autocomplete search functionality for the navbar search box. You can enable it with the setting OPAL_AUTOCOMPLETE_SEARCH (defaults to False). # yourapp/settings.py OPAL_AUTOCOMPLETE_SEARCH = True","title":"Search Overview"},{"location":"guides/search/#opal-search-overview","text":"The Opal Search backend is switchable using the settings value OPAL_SEARCH_BACKEND. By default it will do a database query. The backend takes in a dictionary with the following fields { queryType : either Equals or Contains , field : the label of the column that will be queried, e.g. Hospital Number, query : the value to be queried, e.g. 1111 , 'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries 'column': the model to be queried e.g. 'demographics' }","title":"Opal Search overview"},{"location":"guides/search/#the-advanced-search-interface","text":"The Opal advanced search interface at /#/extract allows users to specify rules by which to query for episodes. By default this allows users to construct simple logical queries based on the values of any subrecord field. The interface respects the types of fields - for instance using before/after for date fields or equals/contains for text fields. This screen also allows users to download episode data for the cohort that matches the specified rules.","title":"The Advanced search interface"},{"location":"guides/search/#custom-search-rules","text":"These rules are extensible, allowing custom rules that perform more advanced queries to be inserted.","title":"Custom Search Rules"},{"location":"guides/search/#opalcoresearchsearchrule","text":"Is a discoverable . It is defined with a group of SearchRuleFields that appear like subrecord model fields in the front end. The SearchRuleField has a query method that returns a list of Episodes. The SearchRuleField must define a field_type, these then provide the following operators to the front end field_type queryType string equals, contains date_time before, after date before, after boolean true, false null_boolean true, false many_to_many a list of the lookup list for this field many_to_many_multi_select a multi select field, defined by the enum field from the rule ie if you state the field is a string, the user will be provided with an equals/contains, which will be passed to the query as given_query[\"queryType\"] For example class SomeField(SearchRuleField): display_name = Some Field # the display name of the field description = A Description for the user to explain what this field means field_type = date_time # what kind of filter that is offered, datetime will off before and after def query(self, given_query): return Episode.objects.all() class MyCustomQuery(SearchRule): display_name = My Custom Query fields = (SomeField,)","title":"opal.core.search.SearchRule"},{"location":"guides/search/#autocomplete-search","text":"Opal contains autocomplete search functionality for the navbar search box. You can enable it with the setting OPAL_AUTOCOMPLETE_SEARCH (defaults to False). # yourapp/settings.py OPAL_AUTOCOMPLETE_SEARCH = True","title":"Autocomplete search"},{"location":"guides/static_files/","text":"Static Files in Opal As with any Javascript heavy application, Opal apps can quickly accumulate large numbers of static files. Opal ships with the Django Compressor library out of the box, and uses it to manage the Javascript asset pipeline. Do consult the excellent Django Compressor documentation for more details on exactly how this process works.","title":"Static Files"},{"location":"guides/static_files/#static-files-in-opal","text":"As with any Javascript heavy application, Opal apps can quickly accumulate large numbers of static files. Opal ships with the Django Compressor library out of the box, and uses it to manage the Javascript asset pipeline. Do consult the excellent Django Compressor documentation for more details on exactly how this process works.","title":"Static Files in Opal"},{"location":"guides/tagging/","text":"Tagging Episodes in Opal may be tagged. This is commonly used as a mechanism to record that a particular team is looking after a patient - via TaggedPatientList , but also to group patients. For instance, we might like to 'tag' episodes with a particular string when some particular event occurs so that we can run reports or analyse these groups later. The \"Teams\" modal in list and detail views, is actually an interface over updating the tagging of the episode in question. Metadata concerning tags can be found via the Options API.","title":"Tagging"},{"location":"guides/tagging/#tagging","text":"Episodes in Opal may be tagged. This is commonly used as a mechanism to record that a particular team is looking after a patient - via TaggedPatientList , but also to group patients. For instance, we might like to 'tag' episodes with a particular string when some particular event occurs so that we can run reports or analyse these groups later. The \"Teams\" modal in list and detail views, is actually an interface over updating the tagging of the episode in question. Metadata concerning tags can be found via the Options API.","title":"Tagging"},{"location":"guides/templates/","text":"Templates in Opal Opal uses a mixture of Django and Angular templates. Angular and Django templates, living in harmony Natively, both Angular and Django use the {{ ... }} syntax for interpolation in templates. In order for Opal to be compatible with both Django and Angular interpolation, we use the [[ ... ]] notation for Angular interpolation and the {{ ... }} syntax for Django interpolation, which allows us to include Django template interpolation in templates designed to be rendered by Angular on the client side. !-- app_details_snippet.html -- !-- Django interpolation uses {{ ... }} -- {{ OPAL_BRAND_NAME }} !-- Angular interpolation uses [[ ... ]] -- [[ OPAL_BRAND_NAME ]] Generic Template URL On many occasions we want to fetch a template from the server in our Angular code without any further processing. Opal provides a default catchall HTML template url which will render .html files direct from disk. # opal.urls url(r'templates/(?P template_name [a-z_/]+.html)', views.RawTemplateView.as_view()) So if our template is at ./myapp/templates/foo/bar.html , then the url /templates/foo/bar.html will return it. Overriding Opal templates Opal's built-in templates can help you be productive rapidly, and prototype an application quickly. However, as your application develops you are likely to need to override Opal's templates. How to override a template In general, if you want to override an Opal template, you will need to place a file in your application with the same filename, and at the same relative location as that file in Opal's source code. The Django template loader system will then select the file from your application rather than the file in the Opal templates directory. For example if you want to override the default form for the Demographics model, you create a new template: yourapp/ templates/ forms/ demographic_form.html How do I know which template I need to override? You will need to look at the templates in the Opal source code and work out which one is being used. Templates related to the display or editing of subrecords , are named according to the API name of the subrecord and can be found in ./templates/forms or ./templates/records/ . For instance, the demographics form is located in ./templates/forms/demographics_form.html and the display template for a demographics instance is located in ./templates/records/demographics.html . Templates related to form widgets are found in ./templates/_helpers and named after the type of widget they represent. For instance, the template for the {% input %} templatetag is found at ./templates/_helpers/input.html Once logged in, the main layout of the application is provided by the template at ./templates/opal.html . By default, this simply extends ./templates/app_layouts/layout_base.html . The patient detail page is provided by the template at ./templates/patient_detail.html . By default this uses the page layout from ./templates/patient_detail_base.html . The detail template for an episode of any given episode category is set on the category class .","title":"Templates"},{"location":"guides/templates/#templates-in-opal","text":"Opal uses a mixture of Django and Angular templates.","title":"Templates in Opal"},{"location":"guides/templates/#angular-and-django-templates-living-in-harmony","text":"Natively, both Angular and Django use the {{ ... }} syntax for interpolation in templates. In order for Opal to be compatible with both Django and Angular interpolation, we use the [[ ... ]] notation for Angular interpolation and the {{ ... }} syntax for Django interpolation, which allows us to include Django template interpolation in templates designed to be rendered by Angular on the client side. !-- app_details_snippet.html -- !-- Django interpolation uses {{ ... }} -- {{ OPAL_BRAND_NAME }} !-- Angular interpolation uses [[ ... ]] -- [[ OPAL_BRAND_NAME ]]","title":"Angular and Django templates, living in harmony"},{"location":"guides/templates/#generic-template-url","text":"On many occasions we want to fetch a template from the server in our Angular code without any further processing. Opal provides a default catchall HTML template url which will render .html files direct from disk. # opal.urls url(r'templates/(?P template_name [a-z_/]+.html)', views.RawTemplateView.as_view()) So if our template is at ./myapp/templates/foo/bar.html , then the url /templates/foo/bar.html will return it.","title":"Generic Template URL"},{"location":"guides/templates/#overriding-opal-templates","text":"Opal's built-in templates can help you be productive rapidly, and prototype an application quickly. However, as your application develops you are likely to need to override Opal's templates.","title":"Overriding Opal templates"},{"location":"guides/templates/#how-to-override-a-template","text":"In general, if you want to override an Opal template, you will need to place a file in your application with the same filename, and at the same relative location as that file in Opal's source code. The Django template loader system will then select the file from your application rather than the file in the Opal templates directory. For example if you want to override the default form for the Demographics model, you create a new template: yourapp/ templates/ forms/ demographic_form.html","title":"How to override a template"},{"location":"guides/templates/#how-do-i-know-which-template-i-need-to-override","text":"You will need to look at the templates in the Opal source code and work out which one is being used. Templates related to the display or editing of subrecords , are named according to the API name of the subrecord and can be found in ./templates/forms or ./templates/records/ . For instance, the demographics form is located in ./templates/forms/demographics_form.html and the display template for a demographics instance is located in ./templates/records/demographics.html . Templates related to form widgets are found in ./templates/_helpers and named after the type of widget they represent. For instance, the template for the {% input %} templatetag is found at ./templates/_helpers/input.html Once logged in, the main layout of the application is provided by the template at ./templates/opal.html . By default, this simply extends ./templates/app_layouts/layout_base.html . The patient detail page is provided by the template at ./templates/patient_detail.html . By default this uses the page layout from ./templates/patient_detail_base.html . The detail template for an episode of any given episode category is set on the category class .","title":"How do I know which template I need to override?"},{"location":"guides/theming/","text":"Theming your Opal application Opal applicatoins ship with a basic theme that is good enough to use in production, but we expect that most applications will wish to customise the look and feel. Accordingly, we support a range of different theming options. Basic Options Basic theming comes in the form of settings which can be tweaked. You can give your application a different name, logo, and set the version number. Overriding CSS and templates You can override the CSS to change the core colours et cetera, and there are some key templates that you can tweak. Changing the home page. By default, the home page of an opal application simply renders the welcome.html template. Form styles Opal defaults to using Bootstrap form-horizontal style widgets. That means that the label is rendered on the same line as the form widget. You can change this to the vertical (default Bootstrap style )for an individual form widget by passing the style argument: {% input field= Demographics.first_name style= vertical %} Custom Themes Comprehensive re-skins likely require you to write your own Opal theme. You can do this within an application directly, or if you definitely have a theme you want to use in multiple applications, you can write a theme plugin. Example themes We have created a number of example themes for Opal. These are intended to demonstrate the possibilities rather than for production use. Slack Skin Google Inbox Skin","title":"Theming"},{"location":"guides/theming/#theming-your-opal-application","text":"Opal applicatoins ship with a basic theme that is good enough to use in production, but we expect that most applications will wish to customise the look and feel. Accordingly, we support a range of different theming options.","title":"Theming your Opal application"},{"location":"guides/theming/#basic-options","text":"Basic theming comes in the form of settings which can be tweaked. You can give your application a different name, logo, and set the version number.","title":"Basic Options"},{"location":"guides/theming/#overriding-css-and-templates","text":"You can override the CSS to change the core colours et cetera, and there are some key templates that you can tweak.","title":"Overriding CSS and templates"},{"location":"guides/theming/#changing-the-home-page","text":"By default, the home page of an opal application simply renders the welcome.html template.","title":"Changing the home page."},{"location":"guides/theming/#form-styles","text":"Opal defaults to using Bootstrap form-horizontal style widgets. That means that the label is rendered on the same line as the form widget. You can change this to the vertical (default Bootstrap style )for an individual form widget by passing the style argument: {% input field= Demographics.first_name style= vertical %}","title":"Form styles"},{"location":"guides/theming/#custom-themes","text":"Comprehensive re-skins likely require you to write your own Opal theme. You can do this within an application directly, or if you definitely have a theme you want to use in multiple applications, you can write a theme plugin.","title":"Custom Themes"},{"location":"guides/theming/#example-themes","text":"We have created a number of example themes for Opal. These are intended to demonstrate the possibilities rather than for production use. Slack Skin Google Inbox Skin","title":"Example themes"},{"location":"guides/topic-guides/","text":"Opal Guides A list of all available topic guides. Opal Opal - Applications, Plugins How Opal components hang together Command line tool Running admin tasks from the command line Discoverable Design patterns and library for creating easily reusable features Plugins Available interfaces for Opal plugins List of Plugins A list of available high quality plugins Data and Business Logic Data Model How Opal models clinical reality Episodes Opal Episodes and how to customise them Core Clinical Model The core clinical data model available to Opal applications Reference data Canonical coded terms and reference data App metadata Working with Metadata on the front end Angular models Working with Clinical data in Angular Roles Permissions How we handle authorization in Opal Tagging Tagging episodes in Opal JSON API The Opal JSON API Presentation and templating Theming How to theme your application Templates Server and client side templating Default Context Processors Opal Django context processors Static Files How Opal handles static files Forms Forms for entering or editing data Patient Detail Views Detailed views of a Patient Patient List Views Lists of patients Optional Components Search Default search implementation Pathway Build forms with multiple models, easily Django Admin Working with Opal models in the Django Admin Working on Opal itself Contributing Contributing to Opal Development environment Setting up the Opal development environment Making a Release Releasing a version of Opal Other Guides Deployment Deploying Opal","title":"Guides"},{"location":"guides/topic-guides/#opal-guides","text":"A list of all available topic guides.","title":"Opal Guides"},{"location":"guides/topic-guides/#opal","text":"Opal - Applications, Plugins How Opal components hang together Command line tool Running admin tasks from the command line Discoverable Design patterns and library for creating easily reusable features Plugins Available interfaces for Opal plugins List of Plugins A list of available high quality plugins","title":"Opal"},{"location":"guides/topic-guides/#data-and-business-logic","text":"Data Model How Opal models clinical reality Episodes Opal Episodes and how to customise them Core Clinical Model The core clinical data model available to Opal applications Reference data Canonical coded terms and reference data App metadata Working with Metadata on the front end Angular models Working with Clinical data in Angular Roles Permissions How we handle authorization in Opal Tagging Tagging episodes in Opal JSON API The Opal JSON API","title":"Data and Business Logic"},{"location":"guides/topic-guides/#presentation-and-templating","text":"Theming How to theme your application Templates Server and client side templating Default Context Processors Opal Django context processors Static Files How Opal handles static files Forms Forms for entering or editing data Patient Detail Views Detailed views of a Patient Patient List Views Lists of patients","title":"Presentation and templating"},{"location":"guides/topic-guides/#optional-components","text":"Search Default search implementation Pathway Build forms with multiple models, easily Django Admin Working with Opal models in the Django Admin","title":"Optional Components"},{"location":"guides/topic-guides/#working-on-opal-itself","text":"Contributing Contributing to Opal Development environment Setting up the Opal development environment Making a Release Releasing a version of Opal","title":"Working on Opal itself"},{"location":"guides/topic-guides/#other-guides","text":"Deployment Deploying Opal","title":"Other Guides"},{"location":"guides/working_with_data_in_angular/","text":"Working with Clinical Data in Angular Opal provides a range of Angular services for working with clinical data on the front end. The Episode Service The Episode Service will return an Episode object that represents an individual episode of care, and provides various methods for interacting with both episodes and subrecords. var episode = new Episode(my_episode_data); var editing = episode.makeCopy(); editing.start_date = new Date(); episode.save(editing); The Item Service The Item Service returns Item objects that represent individual instances of subrecords. They must be initialised with an episode and a schema representing the available data fields for this subrecord type. var diagnosis = new Item({}, episode, $rootScope.fields.diagnosis); var editing = diagnosis.makeCopy(); editing.date_of_diagnosis = new Date(); diagnosis.save(editing); Subrecord CRUD modals The Episode service has a convenient API that allows you to open a modal to edit a new or existing subrecord. episode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis Customising Subrecords Sometimes our application will wish to customise a subrecord of a particular type - for instance to set default values. We do this by setting a custom record service. First, we set the name of the service to use as a constructor for this record type as a property on the model. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' Next we must include the file with our new service in our application. # yourapp/__init__.py class YourApp(application.OpalApplication): javascripts = [..., 'js/diagnosis.js', ...] Finally we define an Angular service which expects to be passed the record in order to set defaults. // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()} return record; } });","title":"Angular Models"},{"location":"guides/working_with_data_in_angular/#working-with-clinical-data-in-angular","text":"Opal provides a range of Angular services for working with clinical data on the front end.","title":"Working with Clinical Data in Angular"},{"location":"guides/working_with_data_in_angular/#the-episode-service","text":"The Episode Service will return an Episode object that represents an individual episode of care, and provides various methods for interacting with both episodes and subrecords. var episode = new Episode(my_episode_data); var editing = episode.makeCopy(); editing.start_date = new Date(); episode.save(editing);","title":"The Episode Service"},{"location":"guides/working_with_data_in_angular/#the-item-service","text":"The Item Service returns Item objects that represent individual instances of subrecords. They must be initialised with an episode and a schema representing the available data fields for this subrecord type. var diagnosis = new Item({}, episode, $rootScope.fields.diagnosis); var editing = diagnosis.makeCopy(); editing.date_of_diagnosis = new Date(); diagnosis.save(editing);","title":"The Item Service"},{"location":"guides/working_with_data_in_angular/#subrecord-crud-modals","text":"The Episode service has a convenient API that allows you to open a modal to edit a new or existing subrecord. episode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis","title":"Subrecord CRUD modals"},{"location":"guides/working_with_data_in_angular/#customising-subrecords","text":"Sometimes our application will wish to customise a subrecord of a particular type - for instance to set default values. We do this by setting a custom record service. First, we set the name of the service to use as a constructor for this record type as a property on the model. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' Next we must include the file with our new service in our application. # yourapp/__init__.py class YourApp(application.OpalApplication): javascripts = [..., 'js/diagnosis.js', ...] Finally we define an Angular service which expects to be passed the record in order to set defaults. // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()} return record; } });","title":"Customising Subrecords"},{"location":"reference/changelog/","text":"0.18.0 (Major Release) Load lookuplist data format Fixes a bug (1695) to ensure that the data keys inside a lookuplist data file are taken from the value of .get_api_name() . Allow extract queries for 'falsy' values Fixes a bug in extract. When querying against 0 or false the ui stated that no query had been entered. Also queries on multiple fields that included a filter against a field with 0 or false would have that portion of the query ignored. Ment.io and Macro removal The Macro feature and related Ment.io library have been removed. (No known applications used these features.) Remove additional EpisodeCategories The Outpatient and Liaison episode categories have been removed from opal.core.episodes . Defining these here rather than expecting applications to define them in application land means that overriding templates can only be done via monkeypatching. FindPatientStep removal Removes the FindPatientStep . Every known application with this functionality has required custom logic and re-written this step. (If there is a common case, we don't know what it is yet.) Profile can_see_pid removal The can_see_pid method of profiles on both the front and back end was tied to hard-coded roles which were impossible to override. Micro test removals A large number of microbiology specific models and lookuplists have been removed from this version of Opal along with the Investigation model. This code was rarely used and turned out to be incompatible wiht subsequent LIMS system integration. We would advise anyone using it to incorporate these models into their own applications, but consider moving away. Line Lookuplist removals Removes line removal reason, complication, site and type lookuplists. These are rarely if used and would be better placed at present in an application rather than the core framework. Javascript API removals Removes the undocumented EditItemCtrl.prepopulate method. Custom Pathway controllers are recommended for complex form interactions. Also removes a series of Angular filters which were deemed of limited re-use potential. Applications may add such filters themselves trivially. microresult boxed plural Removes the undocumented UserProfile.can_edit method. This made assumptions about specific named roles which were unconfigurable and was thus unlikely to be useful. Flow based controllers removed Removes the HospitalNumberCtrl and AddEpisodeCtrl along with related tests and templates. Pathways can perform thse operations significantly more flexibly. This has also resulted in removing the undocumented Episode method findByHospitalNumber which was used by the flow controllers. Allergies sidebar Removed an undocumented template modals/_allergies_sidebar.html which was rarely used and more suited to being included in individual applications than the framework itself. Stories The Stories functionality is not clearly more useful than simply having an html template file in an individual application. The pattern of having them as individual feature files which are not executalbe by e.g. Cucumber adds complexity but no value. Explicit acceptance tests are encouraged for applications, but no longer live as part of Opal core. Design Patterns Removes the design patterns library as this is incompatible with the new 'skinability' approach. Such patterns pages are encouraged for large applications or standalone themes. Plugin/Application stylesheet media atribute Style sheets loaded via Opal Applicatin or Plugin objects are now included with the attribute media=\"all\" rather than `media=\"screen\". Minor Bugfixes For some types, e.g. decimal the core serilizer would return None . This is now resolved. Deletes a directory previously left as an artifact of scaffolding at ../../js/app/ (1554) Updates to the Dependency Graph DjangoRESTFramework 3.7.4 - 3.10.2 python-dateutil 2.7.5 - 2.8.0 0.17.1 (Minor Release) Removes a now deleted file from the default application javascripts list 0.17.0 (Major Release) Javascript API removals Removes the function Episode.isDischarged() (This was rarely if ever used, and no longer an accurate represenation of dischargedness.) Removes the Episode.getNumberOfItems method which is rarely used. Removes the methods PatientDetailCtrl.dischargeEpisode() and PatientListCtrl.dischargeEpisode() (However you're discharging episodes as of 0.17 it would be strongly unadvisable to do it this way.) Removes PatientList.removeFromMine() (The special casing of the 'Mine' list is strongly unadvised and set for complete removal.) Removes the front end Flow service Miscelanious changes Bumps Flake8 version to 3.7.8 - new code will now be required to pass flake8 v3.7.8 Updates to the Dependency Graph Jinja2: 2.10 - 2.10.1 Psycopg2: 2.7.6.1 - 2.8.3 Requests: 2.20.1 - 2.22.0 python3 Opal now only supports python 3.5 - python 3.7 0.16.0 (Major Release) Adds serialize_date, serialize_datetime, serialize_time utility functions to serialize date/datetime/time to strings. Diagnosis.details is now a text field. Changes the requirements.txt files that get created when we create an opal application or plugin to use python-dateutil==2.7.5 0.15.0 (Major Release) Adds an optional setting OPAL_DEFAULT_SEARCH_FIELDS that specifies the fields used to search in when a criteria isn't specified. 0.14.2 (Minor Release) Documentation fix, we're on python 3.4 now. 0.14.1 (Minor Release) The search plugin was not excluding search strings from analytics. This change makes it so that it does. 0.14.0 (Major Release) A User's UserProfile is now automatically created when you create a user in a post save signal. RecordEditor.editItem, RecordEditor.editItem and RecordEditor.openEditItemModal to take a url argument. This is the url of the template that should be opened with the edit item controller. RecordEditor.editItem also will now take an item or an index rather than just an index. Taking an index has been deprecated and will be removed in v0.15.0 The PatientListCtrl now does the logic of whether to create a new item or edit an item within the controller before it calls the record editor. 0.13.1 (Minor Release) Upgrades the setup.py Django version from 2.0.9 to 2.0.13. Removes the six library dependency from setup.py. 0.13.0 (Major Release) Removes support for Python 2.x Due to the upgrade to Django 2.x, Opal no longer supports Python 2.x. Opal is now tested against Python 3.5, 3.6 Episode.active The field Episode.active was previously implicitly set when calling .set_tag_names() to something equivalent to the value of bool(len(tag_names) 0) . As of 0.13.0 the value of Episode.active is checked whenever .save() is called, prior to the database call. The correct value is looked up via Episode.category.is_active() . The default calculation of .active has also changed to be roughly equivalent to bool(self.episode.end is None) . Applications are now able to easily change this behaviour by overriding the .is_active method of the relevant EpisodeCategory . Coding systems for lookuplists Lookuplist entries may now have an associated coding system and code value stored against them. This enables applications to explicitly code entries against e.g. SNOMED value sets. Note: This will requires a migration to be created for all applications. New date display format helpers Introduces two new Angular filters: displayDate and displayDateTime . These format a date for display according to the setting DATE_DISPLAY_FORMAT . This defaults to D MMM YYYY . New applications will have this setting in their scaffold, existing applications may wish to add it. All core Opal templates that previously used shortDate or shortDateTime have been updated to use either displayDate or displayDateTime . Removes scope.jumpToEpisode and scope.getEpisodeId from Search and Extract We no longer use these functions, instead we use an HTML link to the patient detail view. Removes Patient.to_dict().active_episode_id We no longer include a value for \"active_episode_id\" as part of the Patient to_dict serialisation. This is effectively meaningless since we moved to an episode model that allows for multiple concurrent episodes. Removes CopyToCategory Removes the entire CopyToCategory flow from Opal Core. If applications continue to rely on it, they are advised to implement at application level. In general application developers are advised to find alternative ways to display subrecords from multiple episodes rather than copying them however, as this is known to cause duplication of data that is hard to trace back later on. This includes the API endpoint at episode/$id/actions/copyto/$category/ , the template copy_to_category.html , the Angular controller CopyToCategoryCtrl and service CopyToCategory and Subrecord property _clonable . Lookuplist data format Lookuplist entries in data files are no longer required to have an empty synonyms list if the entry doesn't have a synonym. This reduces the file size and makes it easier to hand craft data files for new applications. TaggedPatientList Episode serialisation Alters the default serialisation of TaggedPatientList serialisation to no longer filter out 'inactive' episodes. Given that 'active' was always true when an episode had a tag, this was effectivly a no-op anyway unless applications were altering the get_queryset for these patient lists somehow. Removes the deprecated Model._title property Use of Model._title to set a display name of a subrecord has issued a warning for several releases - this has now been removed and will no longer work. Free text or foreign key fields are now, by default case insensitive This can be adjusted with a flag on the field. Existing fk_or_ft fields could therefore still have the field set as free text. This change is not accompanied by a retrospective migration so your existing fk_or_ft may be stored in a case sensitive manner. It is recommended you migrate all of your fk_or_ft fields as this will give you consistent behaviour. For example Prior to this change if I had an allergy for \"paracetomol\" but an entry in the models.Drug table of \"Paracetomol\", it would be stored as free text in the Allergies.drug field, because it was case sensitive. Going forward after this change it will be saved as a foreign key. This change will not be made retrospecively however so you would need to add a migration that resaved the Allergies.drug. Misc Changes The undocumented Reopen Episode flow included in Opal 0.8.0 has now been completely removed, including the reopen_episode_modal.html template and the url/view at templates/modals/reopen_episode.html/ . Removes the method .deleteItem from the RecordEditor service. Adds in a footer updated/created by to the form base template Changes the default value of _ft fields on ForeignKeyOrFreeTextField from b'' to ''. This requires a migration __unicode__ model methods have been renamed __str__ Adds an index argument to PatientList.as_menuitem() and Pathway.as_menuitem() Adds a get_absolute_url() method to Patient and `Episode Adds btn-cancel , btn-save and btn-delete classes to the respective form buttons. Moves the cancel button by default to be left of the save button. Renames the (undocumented, internal) Angular service FieldTranslater to FieldTranslator If an item is deleted from the edit item modal, RecordEditor.openEditItemModal will now resolve after the delete item modal is closed with 'deleted' Updates to the Dependency Graph Django: 1.10.8 - 2.0.9 Django Rest Framework: 3.4.7 - 3.7.4 Django Reversion: 1.10.2 - 3.0.1 Letter: 0.4.1 - 0.5 Requests: 2.18.4 - 2.20.1 Psycopg2: 2.7 - 2.7.6.1 Python Dateutil: 2.4.2 - 2.7.5 0.12.1 (Minor Release) If an item is deleted from the edit item modal, RecordEditor.openEditItemModal will now resolve after the delete item modal is closed with 'deleted' Fixes the default investigation modal 0.12.0 (Major Release) Misc Changes Adds the {% block analytics %} in the base template (opal/templates/base.html) that by default contains the google analytics code. Adds the block {% block javascripts %} in the base template (opal/templates/base.html) that will compress all javascripts. Adds a method .demographics() to opal.models.Patient which returns the relevant demographics instance. Adds a for_user method on to the menu item. This method takes a user and by default returns True. Override this to decide if a menu item should be shown in the nav bar. 0.11.2 (Bugfix Release) Includes referencedata JSON files in Manifest. 0.11.1 (Bugfix Release) Fixes the user_options in the date picker tag to display the options as part of the text input. 0.11.0 (Major Release) Adds options of today and yesterday in the date picker If you pass in user_options=True to the date picker. You will be provided with options to select today or yesterday in the form tag. Adds dateHelper to the rootScope The dateHelper has the functions now and yesterday that return javascript Dates for the current time and the current time - 1 day. Deprecates the _title property In future we will use the standard verbose_name property as the display name. The abstract models have been changed to account for this. Core API registration A refactor in the way that the core APIs are registered by Opal means that importing opal.core.api in a plugin API no longer results in circular imports. Fixes a bug whereby episodes were serialising differently depending on whether the code path went via .to_dict() or .objects.serialised() . HelpTextStep can now use a custom template The opal.core.pathway.steps.HelpTextStep can now have a help_text_template passed in. This is the template for what will be placed in the side bar. Adds in a radio_vertical template tag This displays the label and then the radio buttons as a vertical list. opal.core.serialization A number of helpers related to serialization and deserialization have been brought together in the new module opal.core.serialization . Removes \"episode_history\" from episode serialization Serialised episodes previously contained a \"shallow\" copy of all other episodes in a property named episode_history . This was primarially useful before we switched from episode-oriented to patient-oriented detail views by default. This also includes a change to the signature of the .serialised() method of the Episode manager, which no longer accepts a episode_history kwarg. as_menuitem helpers Applications using Opal Menuitems often wish to add menu items for Patient Lists and Pathways. To aid this, the .as_menuitem() method now creates one from the target class with sensible but overridable defaults. opal serve command We add opal serve to the Opal commandline tool. Currently this simply wraps the Django runserver management command. It is envisaged that in the future this will also initialize e.g. sass precompilers with a single command. Misc Changes Adds the utility function opal.utils.get . Similar to the getattr builtin, get looks for a method named get_$attr and will call that if it exists. Adds the method .get_absolute_url() to opal.core.pathways.Pathway and opal.core.patient_lists.PatientList . Template removals We removed a number of superfluous templates: opal/templates/patient_lists/spreadsheet_list.html opal/templates/layouts/left-panel.html Static asset minification The Django upgrade in Opal 0.10 stopped compressor minifying files when DEBUG is set to False. This fixes that issue by upgrading Django compressor to a version that supports Django 1.10. The return of an old friend: IE Document modes Users report that their system administrators sometimes configure Internet Explorer in such a way that it uses e.g. IE7 Document mode by default. This is problematical for Opal applications which do in fact make use of internet technologies that were in widespread use after say, 2006. We have altered base.html to specify \"X-UA-Compatible\" content=\"IE=Edge\" . If you override base.html in your application we advise that you add this meta tag. Misc Changes Adds the utility function opal.core.subrecords.singletons() which returns a generator function which will yield all subrecord singletons. Fixes a URI encoding bug in the Episode.findByHospitalNumber() method that made hospital numbers including # or / raise an error. Adds the methods .get_absolute_url() , .get_icon() and get_display_name() to opal.core.pathways.Pathway and opal.core.patient_lists.PatientList . Updates to the Dependency Graph Django compressor: 1.5 - 2.2 0.10.1 (Minor Release) Plugin API end points can now override application end points A change to the order that APIs are registered with Django Rest Framework allows plugins to now override the core Opal application APIs. Fonts are now locally sourced Fonts are now served from Opal's static assets rather than from the Google CDN. print/screen stylesheets have been collapsed into opal.css Print/screen differences are now in opal.css with media tags. Google Analytics is now deferred The loading in of Google Analytics is now deferred to the bottom of the body tag to allow the page to load without waiting on analytics scripts to load. Scaffold version control failures The startplugin and startproject commands initialize a git repository by default. If we (The subprocess module) cannot find the git command, we now continue with a message printed to screen rather than raising an exception. Episode.objects.serialised now uses select_related ForeignKeyOrFreeText fields now have their ForeignKey items preselected when we use Episode.objects.serialised . This provides a speed boost for applications with moderately heavy ForeignKeyOrFreeText usage. (Approx 30-40% in our tests.) 0.10.0 (Major Release) This is a major release with breaking changes from upstream dependencies. You are almost certain to require changes to your application. Please see the upgrade guide for further details. Referencedata in new applications Opal now includes core lookuplist data in an opal.core.referencedata plugin which is installed and loaded by default by the startproject scaffolding. Deletion cascade behaviour Opal 0.10 changes several behaviours related to cascading deletions which, despite being Django defaults, were confusing to users and developers in our use case. When we delete and look up list instance, we no longer delete all subrecords that use that instance. Instead we set the look up list instances name in the free text field on the subrecord. When you delete a user, it will no longer delete all related episodes and subrecords Episode Category stages Episode categories now enforce a set of valid Episode.stage values. EpisodeCategory now includes the .get_stages() and .has_stage(stage) methods, while Episode has a set_stage setter which is used by the UpdateFromDictMixin JSON API. lookuplists.lookuplists Adds the utility generator lookuplists.lookuplists() which wil yield every lookuplist currently available. Discoverable.filter() Disoverable features now have a filter method which allows you to filter features with matching attributes. Pathways ContextProcessor The 'opal.core.pathways.context_processors.pathways' Context Processor will allow you to access your pathways from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include pathways.YourPathway.get_display_name %} Missing consistency token errors .update_from_dict() will now raise the new error opal.core.errors.MissingConsistencyTokenError if it is called without a consistency token when one is set on the model. Previously it would raise APIError . The JSON API will now return a more specific message in the response boday, explaining that the problem is a missing consistency token. dump_lookup_lists --many-files Adds the --many-files option to the dump_lookup_lists command which will write each installed lookup list to a separate file in the ./data/lookuplists directory of the application. Template removals We remove a number of stale unused templates: changelog.html contact.html extract_footer.html tagging_detail.html _helpers/inline_form.html responsive/_phone_episode_list.html' responsive/_tablet_episode_list.html Removing LoginRequiredMixin As Django ships with a LoginRequiredMixin of its own we no longer roll our own in `opal.core.views. Testing options Adds a --failfast option to the test harness to stop test runs on the first failure. If you are a plugin developer upgrading an existing plugin you will have to manually add support for --failfast passthrough to your runtests.py . If you are a plugin developer upgrading an existing plugin you will have to manually add support for --failfast passthrough to your runtests.py . Moves scaffold to be a django management command The rest of the api is still the same but now we run python manage.py scaffold {my_app_name} Deprecations completed As previously noted in console warnings, the Angular Episode service no longer supports the discharge_date , date_of_admission , date_of_episode properties. These were replaced by .start and .end . Updates to the Dependency Graph Django: 1.8.13 - 1.10.8 Django Reversion: 1.8.7 - 1.10.2 Django Rest Framework: 3.2.2 - 3.4.7 Psycopg2: 2.5 - 2.7 Jinja2: 2.9.6 - 2.10 Ffs: 0.0.8.1 - 0.0.8.2 Requests: 2.7.0 - 2.18.4 django-celery: 3.1.17 - 3.2.2 celery: 3.1.19 - 3.1.25 Misc Changes Removes the undocumented collapsed_multisave tag from the pathways templatetag library. Adds a setting OPAL_FAVICON_PATH to specify the application Favicon to use. Adds the rows option to the textarea template tag which just fills in the html textarea rows attribute. Text areas are defaulted to 5 rows (the same as before). Configures the setting CSRF_FAILURE_VIEW to use the bundled opal.views.csrf_failure view. Pathway slugs may now include hyphens as well as numbers, lower case letters and underscores. Bugfix: in edit_item.js $scope.episode_category is now set from episode.category_name as opposed to episode.category (which was always null) Fixes some instances of progressbars not being reset if unexpected error states occur. Improves the rendering of patient detail pages where no patient with the ID from route params exits. (Displays a polite message instead of erroring.) Incorrect pluralisation of subrecord names in the Admin view has been fixed. (Migrations will have to be run in all models which extend the changed core Opal models (this is due to a minor upstream Django bug) Minor change to the diagnosis form. 0.9.0 (Major Release) Good bye date_of_episode, discharge_date, date_of_admission And hello episode.start and episode.end . These fields on the Episode model replace the multiple ways of recording Episode duration in Opal. There is a migration that sets start to date_of_episode if it exists, otherwise it uses date of admission. end will be date_of_episode if it exists, otherwise it will use discharge_date. Note that this means we no longer refer to start and end properties on the Episode category. If you override start and end in a custom episode category you should update to use the Episode model fields. This logic should be moved into your flows and you'll need to put in a migration to populate existing episodes. We also remove the episode fields date_of_episode discharge_date , and date_of_admission . Warning: Backwards migrations will not migrate back to date_of_episode but to a admission and discharge. Take backups before running these migrations! The fields start and end are both cast to moments (rather than raw js Dates) on episode.initialisation Pathway Moves the opal-pathway module into the opal core. Pathways is an extensible way of creating forms that involve multiple subrecords. We've got time on our side Adds in the {% timepicker %} template tag, that follows the same convention as the other template tags, ie {% timepicker field=\"Dinner.time\" %} Removes a js global declaration of categories Previously we declared CATEGORIES globally. This has now been removed Order Order Episodes in the patient list are now ordered by start, first_name and surname Theming support Improvements and better documentation and guides for theming applications. Particularly of note are changes to opal.html and base.html , as well as the addition of the static_page.html template. This version also includes extensive improved support for customising the templates that display patient lists, detail views, menus and forms amongst other things. For full documentation, consult the theming guide in the documentation. Makes search fully pluggable Search is now completely pluggable, you need to have some angular controller called SearchCtrl, but apart from that you can plugin your own implementation. Exclude prefixes now work on actual paths Previously they only worked with angular paths, now they work with a combination of actual paths and angular url paths (e.g. /search/#/extract) Misc Changes Add the allow_add_patient and allow_edit_teams options to the patient lists. We added support for a --file or -f option for the load_lookup_lists command which allows the user to specify a particular file outside of the default locations. The default Location record display template will no longer include references to Episode.start . and Episode.stop labelled as admisssion and discharge to support the majority case where an episode relates to something other than an inpatient episode! Applications wishing to retaint this functionality should update their own temaplates to display start/stop details. Removes Deprecated functionality in ReferenceData, Metadata, UserProfile and recordLoader Previously these would make their http request when imported into a file. They now require you to call .load() for them to return the promise that loads in their respective data. 0.8.3 (Minor Release) opal.log.ConfidentialEmailer Adds a custom email logger. This enables Django error emails which remove any confidential patient data. Also adds in the karma config to the MANIFEST.in so that we include the karma configs on pip install. It also moves it to \"opal/tests/js_config/karma_defaults.js\". 0.8.2 (Minor Release) OPAL_LOCATION is added as a system variable when running js tests If you run opal test js, your karma config is now run in an environment that has access to the OPAL_LOCATION variable which points to the opal parent directory. A Data Dictionary In The Extract The Extract zip file has a data dictionary with human readable metadata about each field. Enhanced Application menus The application menu API, previously python dicts stored in attributes on either plugin or application subclasses, now consists of the new opal.core.menus.MenuItem class, enabling enhanced customisation and flexibility. PUT to the episode API returns the episode with all its subrecords Previously it only returned the episode. Now it matches the episode create api end point Episode/Patient links in admin In the admin, episodes and patients lists now have links to the patient detail pages. User data for the client Adds a User Angular service that enables applications to use user data. Also adds some directives to make it easy to render User names and avatars. Episode.getFullName() Adds a utility method to the Episode service that returns a human readable patient name. Plugin.get_javascripts, Plugin.get_styles Enhances the API available for plugins to include javascript and css by adding methods on opal.core.plugins.OpalPlugin 'element_type' argument for the form template tags Numeric database fields are now set as the html5 type=\"number\" when rendering them with the forms templatetag library. This means on mobile devices it will bring up the numeric keypad. The element type can now be set via the template tag API with the 'element_type' argument. OPAL_LOGO_PATH This new setting allows applications to set the path at which the app logo is served. If OPAL_LOGO_PATH is set, the value is passed to the {% static %} templatetag to set the src atribute of an image in the default application header and login screen. Inactive episodes in PatientLists Changes the behaviour of opal.core.PatientList.to_dict to serialise inactive episodes by default rather than filtering by Episode.active == True. opal.core.TaggedPatientList.to_dict continues to filter by Episode.active == True by default. Notice of future removals The context variables brand_name settings and extra_application in opal.views.IndexView are no longer helpful thanks to the settings context processor. These will be removed in 0.9.0 and emit warnings until then. Misc changes Adds a new filter - underscore-to-spaces for removing underscores from strings. The options for SymptomComplex.duration have moved from the default form template to a choices declaration on the model. These are scheduled to move again to a lookuplist. The default value of Subrecord.get_display_name now uses Django Meta.verbose_name . Minor fixes Fixes a bug where the allergies form rendered the provisional field twice Updates to the Dependency Graph Upgrades Font Awesome from 4.3.0 - 4.7.0 Upgrades Jinja2 from 2.8 - 2.9.6 0.8.1 (Minor Release) Cookies for the future We now use the $cookies api as part of moving to angular v1.5.8. The default expiry of cookies is now a year in the future. The cookie name previously stored as opal.lastPatientList is now opal.previousPatientList . Patients as a service Patient becomes a service in angular. This takes in a patient as loaded by the patient loader or another service. It casts the data to Episode or Item instances as appropriate. PatientList.get_queryset arguments PatientList.get_queryset() is now passed an extra keyword argument - user . This is the current User object. Overriding default Menu Items behaviour The get_menu_items method of Opal Application objects is now passed an extra keyword argument - user . This is the current User object. The templatetag application_menuitems now uses this method to render navigation menus, allowing dynamic customisation of menu contents based on user. Removals Opal 0.8.1 removes some minor features which, to our knowledge are not used by any applications in active development. ReopenEpisodeCtrl - applications may implement their own 're-open' episode flow, but Opal no longer handles this out of the box. Subrecord._bulk_serialise - this flag has been removed Pending removals We have re-named opal.core.views._build_json_response to opal.core.views.json_response . This will issue a warning for the remainder of the 0.8.x branch, before being removed entirely in Opal 0.9.0. Subrecord List API We have added a list method to the default Opal JSON API for subrecords - you may now obtain a list of all instances of a given subrecord from the API endpoint /api/v0.1/$api_name/ . Misc Changes Updates the custom UserAdmin so that the email, first and last name fields from the Django User model are in the add user form not just the edit user form. The default test runner generated by plugin scaffolding now uses opal.urls as the default url conf in the test settings. This allows you to test urls generated by Opal - for instance default form or record templates, or simply raw templates from our generic template view. 0.8.0 (Major Release) Plugins Plugins have been refactored and are now DiscoverableFeatures . This should have no impact on existing plugins, however the functions opal.core.plugins.register and opal.core.plugins.plugins are slated for removal in 0.9.0 When creating new plugins we will place the plugin definition class in plugin.py rather than __init__.py opal.core.api.patient_from_pk A decorator that changes a method that is passed a pk, to a method that is passed a patient. ToDictMixin._bulk_serialise Adds a flag to the to dict mixin to determine whether the item is serialised as part of Episode/Patient.to_dict . Fixes bugs in add many subrecord radio buttons Previously multiple radio buttons for the same subrecord field on the same page would not appear to the user to update correctly. This has now been fixed. Angular UI Libraries 0.8.0 consolidates Angular UI libraries bundled with Opal. We have removed Angular Strap, and switched all components using it to their Angular UI Bootstrap equivalents. This is a breaking change. Applications taking advantage of the Forms templatetag library should require no updates, but will see some minor differences in visual style of widgets. Detailed upgrade guides for the components affected (Typeahead, Popover, Tooltip, Datepicker, Timepicker) are available in the upgrade reference documentation. Defaults for Client Side subrecords We pull through default values from subrecord fields into the Opal Schema and use those values when initializing the relevant Item instance for a new subrecord. This should greatly reduce the need to use custom Angular subrecord services to set defaults. Choices in form templatetags Template tags that use the 'field' attribute to point to a subrecord field will now infer a lookup list from the Choices of the field if it exists. Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively. element name in template tags The html attribute 'name' for form elements generated with the Opal {% forms %} templatetag library used to be inferred from the model name. Although this remains the default you can also set it with an angular expression: {% select field= Demographics.first_name element_name= ...Your Angular expression... %} Model removals The models Team , GP , CommunityNurse and LocatedModel - marked for removal since 0.6.0 have now been removed. As part of this change, the add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash. Python 3 Opal 0.8.0 is the first version of Opal to support Python 3. This has meant changing the default ordering of PatientList instances to 0 rather than None. Moving forwards we expect all new code in Opal to be compatible both Python 2.7 / 3.4 / 3.5 / 3.6. This introduces an explicit Opal dependency on the Six module for maintaining codebases that span Python 2.x and 3.x. Tabbed Patient List Groups Adds the class opal.core.patient_lists.TabbedPatientListGroup which displays groups of related lists as tabs at the top of each member list. PatientList sort order To enable custom sort orders for individual PatientList s we introduce the comparator_service attribute. This names an Angular service which will return a list of comparator functions. PatientList Arbitrary columns We now explicitly enable columns in spreadhseet lists that are not tied to subrecords. These can be included in PatientList schema instances as explicit Column() entries. Template re-naming Modal_base has now been moved into a folder called base_templates. Its also now got a form_modal_base and a two_column_form_modal_base. The latter two templates add validation around saving. The standard edit item models and others now inherit from the form_modal_base. Authorization and permissions All APIs should be permissioned with Django REST framework permission classes. The default implementation uses opal.core.api.LoginRequiredViewset, a standard DRF viewset that requires the user to be logged in. We now require the user to be logged in for any use of the search functionality. Added a custom interceptor that logs the user out if the we receive a 403 or 401 from the server Form Validation Adds the checkForm directive e.g. button check-form= form ng-click= sendDataToTheServer click me /button This adds default form submission behaviour to the a button. It will check if the form is valid, and if its not it will mark the button as disabled until it becomes valid. It will also set the form as submitted. We also now show the required error if the form has been submitted or if the field is dirty, so that the user doesn't get an ugly \"fill this field in now\" message when opening the modal/pathway but will get the error after they click submit. Removals Opal 0.8.0 removes a number of un-used features that have been slated for removal for some time: Options - both from the JSON API, and the Angular service. The legacy APIs /api/v0.1/episode/admit and /api/v0.1/episode/refer . The models GP , CommunityNurse and LocatedModel . opal.models.Tagging.import_from_reversion . This one-off classmethod on tagging was introduced to aid with the upgrade from Opal 4.x to 5.0 and has no further utility. The static argument from the forms input tag. Developers should move to the static tag. The _modal option to set on subrecords. This is because we now use large modals across the board. Misc changes The opal.core.api.EpisodeViewSet.create now expects tagging to be an object rather than a list, similar to how it details with demographics and location. The API will no longer serialise the _ft or _fk_id fields of FreeTextOrForeignKey fields - these are internal implementation details of the server that are not useful on the client side. Adds a Unique Together constraint for (Tagging.user, Tagging.episode, Tagging.value) Look up lists now load in from individual apps. The look for a file at {{ app }}/data/lookuplists.json The default admin url is now /admin/ - rather than /admin/? this results in more readable admin urls and is closer to what most applications do with the Django admin. The roles field opal.models.UserProfile.roles has been updated to be blank=True . This allows the editing of users without specific roles assigned in the Django admin. Although this introduces no changes at the database level, this does introduce a migration. Updates to the Dependency Graph Upgrades angular to v1.5.8 (from 1.3.11) you can see their change log here Updates angular-cookies and angular-mocks to v1.5.8 (both from 1.3.11) Updates angular-ui-select to 0.19.4 from 0.13.2 0.7.5 (Minor Release) The flow enter and exif functions now take an optional context argument. When called from PatientList or PatientDetail controllers this is the parent scope when the flow has been entered. Note: The current Flow API is likely to undergo substantial revision in Opal 0.9 / 0.10 do contact us on the mailing list if you are relying heavily upon it or would like to let us know your needs. 0.7.4 (Minor Release) Adds a past filter, future and past filters now take a boolean argument as to whether you should include today 0.7.3 (Minor Release) Fixes a bug whereby celery tasks are not autodiscovered - will have affected users of async extract functionality. 0.7.2 (Minor Release) Fixes a bug with the copy to category API not setting category name. Removes the hangover use of options in the list of teams per episode in the patient list 0.7.1 (Minor Release) Completes the refactor of front end data, no longer using the /api/v0.1/options/ API internally. This is slated for removal in 0.8.0. Updates DRF APIs - we now expect either Token or DjangoSession auth. Fixes several small bugs with scaffolded applications - the setting of STATIC_ROOT and SECRET_KEY , generating forms for NullBooleanFields, requirements.txt. Adds an aligned_pair templatetag to the panels library. Updates the label for Demographics.birth_place to indicate that this should be a country. Adds the clipboard directive to give the user one click copy to clipboard. Adds a tag-select directive that renders a widget for editing the tags for an episode. Adds metadata to the scope for patient detail views Updates to the Dependency Graph Django Axes 1.4.0 - 1.7.0 0.7.0 (Major Release) Episode Categories Refactors EpisodeCategory to be a discoverable feature. Renames Episode.category - Episode.category_name . Episode JSON API The Restful Episode JSON API previously available at /episode/:pk/ is now moved into /api/v0.1/episode/:pk/ for consistency with the rest of our JSON APIs. The Opal Angular layer has been updated to reflect this, and should handle the transition seamlessly, but code calling the API directly should update to reflect the new URL. Defaults for records on the client side Establishes a new way to define defaults for records initialized in Javascript without requiring that we hard-code API names to defaults in a global namespace. Update to Javascript Signatures Flow.enter() and Flow.exit() now no longer take options positional arguments - instead the controllers they initialize have Metadata and Referencedata as optional resolves arguments. AddEpisodeCtrl now no longer requires options as a resolves() option, but requires Referencedata instead. MaxLength for form helpers The input form helper will now infer the max length of char fields from the max length of the database field, and render relevant Angular directives. EpisodeDetail removed The EpisodeDetailCtrl and EpisodeDetailMixin controller and service have been removed - these were not used anywhere other than in the Wardround plugin, and redundant after enhancements to Patient Detail and Custom DetailViews in 0.6. Additional utilities Adds a datetimepicker templatetag that will render widgets for a Datetime field including time. Adds a date_of_birth_field templatetag that renders a date of birth field complete with inteligent validation. (Note this change also includes removing the old _partial/ template) Updates dependency graph: Django - 1.8.13 0.6.0 (Major Release) Detail views Moves from episode oriented detail to patient oriented detail. (All episodes plus x-episode views are available from a patient detail screen) Tagging As a performance optimisation for the frequent access of historic tags, untagging an episode simply renders the tag inactive rather than deleting it and relying on Django-Reversion for access to historical data. Date Formatting We now expect 'd/m/y' date formatting by default. Patient lists Lists are now declarative, and separate from teams. They are implemented as subclasses of opal.core.patient_lists.PatientList. Forms vs. Modals Introduces a distinction between a form and a modal. By default, we now use forms for subrecords, only overriding the modal if there is something we want to do differently specifically in the modal. Command line tools Adds $opal checkout for switching between applications or application versions. Models ContextProcessor The 'opal.context_processors.models' Context Processor will allow you to access your subrecords from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include models.Demographics.get_detail_template %} Upgrade instructions: Full upgrade instructions to work through any backwards incompatible changes are provided in the Opal docs. 0.5.5 (Minor Release) Changes the way old tags are handled. Tags are no longer deleted episodes, rather they're marked as archived. 0.5.4 (Minor Release) Include local storage 0.5.3 (Minor Release) Speed up loading of the lookup lists Fix pagination issues in search Speed up loading of many to many fields Increase test coverage Add some extra help fields to {% forms %} helpers Fixes bug with $rootScope.open_modal() where keystrokes were being intercepted 0.5.2 (Minor Release) Speed improvements on page load allow us to only show record panels if a record of that type exists disable modal buttons while saving 0.5.1 (Minor Release) Minor bug fixes 0.5 (Major release) Search Complete re-design of Search interface to provide a single search box on every page and pagination for resulta. Puts in place a pluggable interface that could be swapped out for e.g. ElasticSearch. New Service for PatientSummary() Analytics Moves Analytics integration into Opal core with the ability to blacklist pages that should never be reported List view Removed old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row. Updated scrolling and loading behaviour to snap to viewport and not display the page build. Subrecord metadata Added four new utility fields to Patient and Episode subrecords: created_by, updated_by, created, updated Select2 and list fields Added support for select2 as an input widget and Subrecord fields that can be lists of things. Also Numerous small bugfixes. Refactoring of the models package into a models module. Updated Underscore.js - 1.8.3 Updated Angular.js - 1.3.11 0.4.3 (Minor release) Refactors opal.models to be a models.py file rather than a package. Adds several improvements to forms helpers - Help argument, other argument to select. Updates dependency graph: Angular-strap - 2.3.1 0.4.2 (Minor release) Upgrades dependency graph: Django - 1.8.3 Django-reversion - 1.8.7 jQuery - 1.11.3 D3 - 3.5.6 C4 - 0.4.10 South has been removed, now using django migrations 0.4.1 (Bugfix release) Fixes some search results appearing duplicated. 0.4 (Major release) New Design Completely re-designed UI following extensive user research and multiple iterations. Managementcommands and scaffolding Features the opal command line tool for common administrative tasks http://opal.openhealthcare.org.uk/docs/guides/command_line_tool/ Form helpers templatetag library New template library for consistent form controls in line with our new interface guidelines http://opal.openhealthcare.org.uk/docs/reference/form_templatetags/ API Documentation Opal JSON APIs are now fully self-documenting for all updated instances http://opal.openhealthcare.org.uk/docs/guides/json_api/ 0.3 (Major release) Bugfixes, significant flexibility in template customisability. Minor UI updates. 0.2.2 (Bugfix release) Numerous small bugfixes. Adds the concept of undischarging patients. 0.2.1 Numerous small bugfixes. 0.2.0 Search overhaul - introduces advanced searches. 0.1.1 Initial public release","title":"Changelog"},{"location":"reference/changelog/#0180-major-release","text":"","title":"0.18.0 (Major Release)"},{"location":"reference/changelog/#load-lookuplist-data-format","text":"Fixes a bug (1695) to ensure that the data keys inside a lookuplist data file are taken from the value of .get_api_name() .","title":"Load lookuplist data format"},{"location":"reference/changelog/#allow-extract-queries-for-falsy-values","text":"Fixes a bug in extract. When querying against 0 or false the ui stated that no query had been entered. Also queries on multiple fields that included a filter against a field with 0 or false would have that portion of the query ignored.","title":"Allow extract queries for 'falsy' values"},{"location":"reference/changelog/#mentio-and-macro-removal","text":"The Macro feature and related Ment.io library have been removed. (No known applications used these features.)","title":"Ment.io and Macro removal"},{"location":"reference/changelog/#remove-additional-episodecategories","text":"The Outpatient and Liaison episode categories have been removed from opal.core.episodes . Defining these here rather than expecting applications to define them in application land means that overriding templates can only be done via monkeypatching.","title":"Remove additional EpisodeCategories"},{"location":"reference/changelog/#findpatientstep-removal","text":"Removes the FindPatientStep . Every known application with this functionality has required custom logic and re-written this step. (If there is a common case, we don't know what it is yet.)","title":"FindPatientStep removal"},{"location":"reference/changelog/#profile-can_see_pid-removal","text":"The can_see_pid method of profiles on both the front and back end was tied to hard-coded roles which were impossible to override.","title":"Profile can_see_pid removal"},{"location":"reference/changelog/#micro-test-removals","text":"A large number of microbiology specific models and lookuplists have been removed from this version of Opal along with the Investigation model. This code was rarely used and turned out to be incompatible wiht subsequent LIMS system integration. We would advise anyone using it to incorporate these models into their own applications, but consider moving away.","title":"Micro test removals"},{"location":"reference/changelog/#line-lookuplist-removals","text":"Removes line removal reason, complication, site and type lookuplists. These are rarely if used and would be better placed at present in an application rather than the core framework.","title":"Line Lookuplist removals"},{"location":"reference/changelog/#javascript-api-removals","text":"Removes the undocumented EditItemCtrl.prepopulate method. Custom Pathway controllers are recommended for complex form interactions. Also removes a series of Angular filters which were deemed of limited re-use potential. Applications may add such filters themselves trivially. microresult boxed plural Removes the undocumented UserProfile.can_edit method. This made assumptions about specific named roles which were unconfigurable and was thus unlikely to be useful.","title":"Javascript API removals"},{"location":"reference/changelog/#flow-based-controllers-removed","text":"Removes the HospitalNumberCtrl and AddEpisodeCtrl along with related tests and templates. Pathways can perform thse operations significantly more flexibly. This has also resulted in removing the undocumented Episode method findByHospitalNumber which was used by the flow controllers.","title":"Flow based controllers removed"},{"location":"reference/changelog/#allergies-sidebar","text":"Removed an undocumented template modals/_allergies_sidebar.html which was rarely used and more suited to being included in individual applications than the framework itself.","title":"Allergies sidebar"},{"location":"reference/changelog/#stories","text":"The Stories functionality is not clearly more useful than simply having an html template file in an individual application. The pattern of having them as individual feature files which are not executalbe by e.g. Cucumber adds complexity but no value. Explicit acceptance tests are encouraged for applications, but no longer live as part of Opal core.","title":"Stories"},{"location":"reference/changelog/#design-patterns","text":"Removes the design patterns library as this is incompatible with the new 'skinability' approach. Such patterns pages are encouraged for large applications or standalone themes.","title":"Design Patterns"},{"location":"reference/changelog/#pluginapplication-stylesheet-media-atribute","text":"Style sheets loaded via Opal Applicatin or Plugin objects are now included with the attribute media=\"all\" rather than `media=\"screen\".","title":"Plugin/Application stylesheet media atribute"},{"location":"reference/changelog/#minor-bugfixes","text":"For some types, e.g. decimal the core serilizer would return None . This is now resolved. Deletes a directory previously left as an artifact of scaffolding at ../../js/app/ (1554)","title":"Minor Bugfixes"},{"location":"reference/changelog/#updates-to-the-dependency-graph","text":"DjangoRESTFramework 3.7.4 - 3.10.2 python-dateutil 2.7.5 - 2.8.0","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#0171-minor-release","text":"Removes a now deleted file from the default application javascripts list","title":"0.17.1 (Minor Release)"},{"location":"reference/changelog/#0170-major-release","text":"","title":"0.17.0 (Major Release)"},{"location":"reference/changelog/#javascript-api-removals_1","text":"Removes the function Episode.isDischarged() (This was rarely if ever used, and no longer an accurate represenation of dischargedness.) Removes the Episode.getNumberOfItems method which is rarely used. Removes the methods PatientDetailCtrl.dischargeEpisode() and PatientListCtrl.dischargeEpisode() (However you're discharging episodes as of 0.17 it would be strongly unadvisable to do it this way.) Removes PatientList.removeFromMine() (The special casing of the 'Mine' list is strongly unadvised and set for complete removal.) Removes the front end Flow service","title":"Javascript API removals"},{"location":"reference/changelog/#miscelanious-changes","text":"Bumps Flake8 version to 3.7.8 - new code will now be required to pass flake8 v3.7.8","title":"Miscelanious changes"},{"location":"reference/changelog/#updates-to-the-dependency-graph_1","text":"Jinja2: 2.10 - 2.10.1 Psycopg2: 2.7.6.1 - 2.8.3 Requests: 2.20.1 - 2.22.0","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#python3","text":"Opal now only supports python 3.5 - python 3.7","title":"python3"},{"location":"reference/changelog/#0160-major-release","text":"Adds serialize_date, serialize_datetime, serialize_time utility functions to serialize date/datetime/time to strings. Diagnosis.details is now a text field. Changes the requirements.txt files that get created when we create an opal application or plugin to use python-dateutil==2.7.5","title":"0.16.0 (Major Release)"},{"location":"reference/changelog/#0150-major-release","text":"Adds an optional setting OPAL_DEFAULT_SEARCH_FIELDS that specifies the fields used to search in when a criteria isn't specified.","title":"0.15.0 (Major Release)"},{"location":"reference/changelog/#0142-minor-release","text":"Documentation fix, we're on python 3.4 now.","title":"0.14.2 (Minor Release)"},{"location":"reference/changelog/#0141-minor-release","text":"The search plugin was not excluding search strings from analytics. This change makes it so that it does.","title":"0.14.1 (Minor Release)"},{"location":"reference/changelog/#0140-major-release","text":"A User's UserProfile is now automatically created when you create a user in a post save signal. RecordEditor.editItem, RecordEditor.editItem and RecordEditor.openEditItemModal to take a url argument. This is the url of the template that should be opened with the edit item controller. RecordEditor.editItem also will now take an item or an index rather than just an index. Taking an index has been deprecated and will be removed in v0.15.0 The PatientListCtrl now does the logic of whether to create a new item or edit an item within the controller before it calls the record editor.","title":"0.14.0 (Major Release)"},{"location":"reference/changelog/#0131-minor-release","text":"Upgrades the setup.py Django version from 2.0.9 to 2.0.13. Removes the six library dependency from setup.py.","title":"0.13.1 (Minor Release)"},{"location":"reference/changelog/#0130-major-release","text":"","title":"0.13.0 (Major Release)"},{"location":"reference/changelog/#removes-support-for-python-2x","text":"Due to the upgrade to Django 2.x, Opal no longer supports Python 2.x. Opal is now tested against Python 3.5, 3.6","title":"Removes support for Python 2.x"},{"location":"reference/changelog/#episodeactive","text":"The field Episode.active was previously implicitly set when calling .set_tag_names() to something equivalent to the value of bool(len(tag_names) 0) . As of 0.13.0 the value of Episode.active is checked whenever .save() is called, prior to the database call. The correct value is looked up via Episode.category.is_active() . The default calculation of .active has also changed to be roughly equivalent to bool(self.episode.end is None) . Applications are now able to easily change this behaviour by overriding the .is_active method of the relevant EpisodeCategory .","title":"Episode.active"},{"location":"reference/changelog/#coding-systems-for-lookuplists","text":"Lookuplist entries may now have an associated coding system and code value stored against them. This enables applications to explicitly code entries against e.g. SNOMED value sets. Note: This will requires a migration to be created for all applications.","title":"Coding systems for lookuplists"},{"location":"reference/changelog/#new-date-display-format-helpers","text":"Introduces two new Angular filters: displayDate and displayDateTime . These format a date for display according to the setting DATE_DISPLAY_FORMAT . This defaults to D MMM YYYY . New applications will have this setting in their scaffold, existing applications may wish to add it. All core Opal templates that previously used shortDate or shortDateTime have been updated to use either displayDate or displayDateTime .","title":"New date display format helpers"},{"location":"reference/changelog/#removes-scopejumptoepisode-and-scopegetepisodeid-from-search-and-extract","text":"We no longer use these functions, instead we use an HTML link to the patient detail view.","title":"Removes scope.jumpToEpisode and scope.getEpisodeId from Search and Extract"},{"location":"reference/changelog/#removes-patientto_dictactive_episode_id","text":"We no longer include a value for \"active_episode_id\" as part of the Patient to_dict serialisation. This is effectively meaningless since we moved to an episode model that allows for multiple concurrent episodes.","title":"Removes Patient.to_dict().active_episode_id"},{"location":"reference/changelog/#removes-copytocategory","text":"Removes the entire CopyToCategory flow from Opal Core. If applications continue to rely on it, they are advised to implement at application level. In general application developers are advised to find alternative ways to display subrecords from multiple episodes rather than copying them however, as this is known to cause duplication of data that is hard to trace back later on. This includes the API endpoint at episode/$id/actions/copyto/$category/ , the template copy_to_category.html , the Angular controller CopyToCategoryCtrl and service CopyToCategory and Subrecord property _clonable .","title":"Removes CopyToCategory"},{"location":"reference/changelog/#lookuplist-data-format","text":"Lookuplist entries in data files are no longer required to have an empty synonyms list if the entry doesn't have a synonym. This reduces the file size and makes it easier to hand craft data files for new applications.","title":"Lookuplist data format"},{"location":"reference/changelog/#taggedpatientlist-episode-serialisation","text":"Alters the default serialisation of TaggedPatientList serialisation to no longer filter out 'inactive' episodes. Given that 'active' was always true when an episode had a tag, this was effectivly a no-op anyway unless applications were altering the get_queryset for these patient lists somehow.","title":"TaggedPatientList Episode serialisation"},{"location":"reference/changelog/#removes-the-deprecated-model_title-property","text":"Use of Model._title to set a display name of a subrecord has issued a warning for several releases - this has now been removed and will no longer work.","title":"Removes the deprecated Model._title property"},{"location":"reference/changelog/#free-text-or-foreign-key-fields-are-now-by-default-case-insensitive","text":"This can be adjusted with a flag on the field. Existing fk_or_ft fields could therefore still have the field set as free text. This change is not accompanied by a retrospective migration so your existing fk_or_ft may be stored in a case sensitive manner. It is recommended you migrate all of your fk_or_ft fields as this will give you consistent behaviour.","title":"Free text or foreign key fields are now, by default case insensitive"},{"location":"reference/changelog/#for-example","text":"Prior to this change if I had an allergy for \"paracetomol\" but an entry in the models.Drug table of \"Paracetomol\", it would be stored as free text in the Allergies.drug field, because it was case sensitive. Going forward after this change it will be saved as a foreign key. This change will not be made retrospecively however so you would need to add a migration that resaved the Allergies.drug.","title":"For example"},{"location":"reference/changelog/#misc-changes","text":"The undocumented Reopen Episode flow included in Opal 0.8.0 has now been completely removed, including the reopen_episode_modal.html template and the url/view at templates/modals/reopen_episode.html/ . Removes the method .deleteItem from the RecordEditor service. Adds in a footer updated/created by to the form base template Changes the default value of _ft fields on ForeignKeyOrFreeTextField from b'' to ''. This requires a migration __unicode__ model methods have been renamed __str__ Adds an index argument to PatientList.as_menuitem() and Pathway.as_menuitem() Adds a get_absolute_url() method to Patient and `Episode Adds btn-cancel , btn-save and btn-delete classes to the respective form buttons. Moves the cancel button by default to be left of the save button. Renames the (undocumented, internal) Angular service FieldTranslater to FieldTranslator If an item is deleted from the edit item modal, RecordEditor.openEditItemModal will now resolve after the delete item modal is closed with 'deleted'","title":"Misc Changes"},{"location":"reference/changelog/#updates-to-the-dependency-graph_2","text":"Django: 1.10.8 - 2.0.9 Django Rest Framework: 3.4.7 - 3.7.4 Django Reversion: 1.10.2 - 3.0.1 Letter: 0.4.1 - 0.5 Requests: 2.18.4 - 2.20.1 Psycopg2: 2.7 - 2.7.6.1 Python Dateutil: 2.4.2 - 2.7.5","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#0121-minor-release","text":"If an item is deleted from the edit item modal, RecordEditor.openEditItemModal will now resolve after the delete item modal is closed with 'deleted' Fixes the default investigation modal","title":"0.12.1 (Minor Release)"},{"location":"reference/changelog/#0120-major-release","text":"","title":"0.12.0 (Major Release)"},{"location":"reference/changelog/#misc-changes_1","text":"Adds the {% block analytics %} in the base template (opal/templates/base.html) that by default contains the google analytics code. Adds the block {% block javascripts %} in the base template (opal/templates/base.html) that will compress all javascripts. Adds a method .demographics() to opal.models.Patient which returns the relevant demographics instance. Adds a for_user method on to the menu item. This method takes a user and by default returns True. Override this to decide if a menu item should be shown in the nav bar.","title":"Misc Changes"},{"location":"reference/changelog/#0112-bugfix-release","text":"Includes referencedata JSON files in Manifest.","title":"0.11.2 (Bugfix Release)"},{"location":"reference/changelog/#0111-bugfix-release","text":"Fixes the user_options in the date picker tag to display the options as part of the text input.","title":"0.11.1 (Bugfix Release)"},{"location":"reference/changelog/#0110-major-release","text":"","title":"0.11.0 (Major Release)"},{"location":"reference/changelog/#adds-options-of-today-and-yesterday-in-the-date-picker","text":"If you pass in user_options=True to the date picker. You will be provided with options to select today or yesterday in the form tag.","title":"Adds options of today and yesterday in the date picker"},{"location":"reference/changelog/#adds-datehelper-to-the-rootscope","text":"The dateHelper has the functions now and yesterday that return javascript Dates for the current time and the current time - 1 day.","title":"Adds dateHelper to the rootScope"},{"location":"reference/changelog/#deprecates-the-_title-property","text":"In future we will use the standard verbose_name property as the display name. The abstract models have been changed to account for this.","title":"Deprecates the _title property"},{"location":"reference/changelog/#core-api-registration","text":"A refactor in the way that the core APIs are registered by Opal means that importing opal.core.api in a plugin API no longer results in circular imports. Fixes a bug whereby episodes were serialising differently depending on whether the code path went via .to_dict() or .objects.serialised() .","title":"Core API registration"},{"location":"reference/changelog/#helptextstep-can-now-use-a-custom-template","text":"The opal.core.pathway.steps.HelpTextStep can now have a help_text_template passed in. This is the template for what will be placed in the side bar.","title":"HelpTextStep can now use a custom template"},{"location":"reference/changelog/#adds-in-a-radio_vertical-template-tag","text":"This displays the label and then the radio buttons as a vertical list.","title":"Adds in a radio_vertical template tag"},{"location":"reference/changelog/#opalcoreserialization","text":"A number of helpers related to serialization and deserialization have been brought together in the new module opal.core.serialization .","title":"opal.core.serialization"},{"location":"reference/changelog/#removes-episode_history-from-episode-serialization","text":"Serialised episodes previously contained a \"shallow\" copy of all other episodes in a property named episode_history . This was primarially useful before we switched from episode-oriented to patient-oriented detail views by default. This also includes a change to the signature of the .serialised() method of the Episode manager, which no longer accepts a episode_history kwarg.","title":"Removes \"episode_history\" from episode serialization"},{"location":"reference/changelog/#as_menuitem-helpers","text":"Applications using Opal Menuitems often wish to add menu items for Patient Lists and Pathways. To aid this, the .as_menuitem() method now creates one from the target class with sensible but overridable defaults.","title":"as_menuitem helpers"},{"location":"reference/changelog/#opal-serve-command","text":"We add opal serve to the Opal commandline tool. Currently this simply wraps the Django runserver management command. It is envisaged that in the future this will also initialize e.g. sass precompilers with a single command.","title":"opal serve command"},{"location":"reference/changelog/#misc-changes_2","text":"Adds the utility function opal.utils.get . Similar to the getattr builtin, get looks for a method named get_$attr and will call that if it exists. Adds the method .get_absolute_url() to opal.core.pathways.Pathway and opal.core.patient_lists.PatientList .","title":"Misc Changes"},{"location":"reference/changelog/#template-removals","text":"We removed a number of superfluous templates: opal/templates/patient_lists/spreadsheet_list.html opal/templates/layouts/left-panel.html","title":"Template removals"},{"location":"reference/changelog/#static-asset-minification","text":"The Django upgrade in Opal 0.10 stopped compressor minifying files when DEBUG is set to False. This fixes that issue by upgrading Django compressor to a version that supports Django 1.10.","title":"Static asset minification"},{"location":"reference/changelog/#the-return-of-an-old-friend-ie-document-modes","text":"Users report that their system administrators sometimes configure Internet Explorer in such a way that it uses e.g. IE7 Document mode by default. This is problematical for Opal applications which do in fact make use of internet technologies that were in widespread use after say, 2006. We have altered base.html to specify \"X-UA-Compatible\" content=\"IE=Edge\" . If you override base.html in your application we advise that you add this meta tag.","title":"The return of an old friend: IE Document modes"},{"location":"reference/changelog/#misc-changes_3","text":"Adds the utility function opal.core.subrecords.singletons() which returns a generator function which will yield all subrecord singletons. Fixes a URI encoding bug in the Episode.findByHospitalNumber() method that made hospital numbers including # or / raise an error. Adds the methods .get_absolute_url() , .get_icon() and get_display_name() to opal.core.pathways.Pathway and opal.core.patient_lists.PatientList .","title":"Misc Changes"},{"location":"reference/changelog/#updates-to-the-dependency-graph_3","text":"Django compressor: 1.5 - 2.2","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#0101-minor-release","text":"","title":"0.10.1 (Minor Release)"},{"location":"reference/changelog/#plugin-api-end-points-can-now-override-application-end-points","text":"A change to the order that APIs are registered with Django Rest Framework allows plugins to now override the core Opal application APIs.","title":"Plugin API end points can now override application end points"},{"location":"reference/changelog/#fonts-are-now-locally-sourced","text":"Fonts are now served from Opal's static assets rather than from the Google CDN.","title":"Fonts are now locally sourced"},{"location":"reference/changelog/#printscreen-stylesheets-have-been-collapsed-into-opalcss","text":"Print/screen differences are now in opal.css with media tags.","title":"print/screen stylesheets have been collapsed into opal.css"},{"location":"reference/changelog/#google-analytics-is-now-deferred","text":"The loading in of Google Analytics is now deferred to the bottom of the body tag to allow the page to load without waiting on analytics scripts to load.","title":"Google Analytics is now deferred"},{"location":"reference/changelog/#scaffold-version-control-failures","text":"The startplugin and startproject commands initialize a git repository by default. If we (The subprocess module) cannot find the git command, we now continue with a message printed to screen rather than raising an exception.","title":"Scaffold version control failures"},{"location":"reference/changelog/#episodeobjectsserialised-now-uses-select_related","text":"ForeignKeyOrFreeText fields now have their ForeignKey items preselected when we use Episode.objects.serialised . This provides a speed boost for applications with moderately heavy ForeignKeyOrFreeText usage. (Approx 30-40% in our tests.)","title":"Episode.objects.serialised now uses select_related"},{"location":"reference/changelog/#0100-major-release","text":"This is a major release with breaking changes from upstream dependencies. You are almost certain to require changes to your application. Please see the upgrade guide for further details.","title":"0.10.0 (Major Release)"},{"location":"reference/changelog/#referencedata-in-new-applications","text":"Opal now includes core lookuplist data in an opal.core.referencedata plugin which is installed and loaded by default by the startproject scaffolding.","title":"Referencedata in new applications"},{"location":"reference/changelog/#deletion-cascade-behaviour","text":"Opal 0.10 changes several behaviours related to cascading deletions which, despite being Django defaults, were confusing to users and developers in our use case. When we delete and look up list instance, we no longer delete all subrecords that use that instance. Instead we set the look up list instances name in the free text field on the subrecord. When you delete a user, it will no longer delete all related episodes and subrecords","title":"Deletion cascade behaviour"},{"location":"reference/changelog/#episode-category-stages","text":"Episode categories now enforce a set of valid Episode.stage values. EpisodeCategory now includes the .get_stages() and .has_stage(stage) methods, while Episode has a set_stage setter which is used by the UpdateFromDictMixin JSON API.","title":"Episode Category stages"},{"location":"reference/changelog/#lookuplistslookuplists","text":"Adds the utility generator lookuplists.lookuplists() which wil yield every lookuplist currently available.","title":"lookuplists.lookuplists"},{"location":"reference/changelog/#discoverablefilter","text":"Disoverable features now have a filter method which allows you to filter features with matching attributes.","title":"Discoverable.filter()"},{"location":"reference/changelog/#pathways-contextprocessor","text":"The 'opal.core.pathways.context_processors.pathways' Context Processor will allow you to access your pathways from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include pathways.YourPathway.get_display_name %}","title":"Pathways ContextProcessor"},{"location":"reference/changelog/#missing-consistency-token-errors","text":".update_from_dict() will now raise the new error opal.core.errors.MissingConsistencyTokenError if it is called without a consistency token when one is set on the model. Previously it would raise APIError . The JSON API will now return a more specific message in the response boday, explaining that the problem is a missing consistency token.","title":"Missing consistency token errors"},{"location":"reference/changelog/#dump_lookup_lists-many-files","text":"Adds the --many-files option to the dump_lookup_lists command which will write each installed lookup list to a separate file in the ./data/lookuplists directory of the application.","title":"dump_lookup_lists --many-files"},{"location":"reference/changelog/#template-removals_1","text":"We remove a number of stale unused templates: changelog.html contact.html extract_footer.html tagging_detail.html _helpers/inline_form.html responsive/_phone_episode_list.html' responsive/_tablet_episode_list.html","title":"Template removals"},{"location":"reference/changelog/#removing-loginrequiredmixin","text":"As Django ships with a LoginRequiredMixin of its own we no longer roll our own in `opal.core.views.","title":"Removing LoginRequiredMixin"},{"location":"reference/changelog/#testing-options","text":"Adds a --failfast option to the test harness to stop test runs on the first failure. If you are a plugin developer upgrading an existing plugin you will have to manually add support for --failfast passthrough to your runtests.py . If you are a plugin developer upgrading an existing plugin you will have to manually add support for --failfast passthrough to your runtests.py .","title":"Testing options"},{"location":"reference/changelog/#moves-scaffold-to-be-a-django-management-command","text":"The rest of the api is still the same but now we run python manage.py scaffold {my_app_name}","title":"Moves scaffold to be a django management command"},{"location":"reference/changelog/#deprecations-completed","text":"As previously noted in console warnings, the Angular Episode service no longer supports the discharge_date , date_of_admission , date_of_episode properties. These were replaced by .start and .end .","title":"Deprecations completed"},{"location":"reference/changelog/#updates-to-the-dependency-graph_4","text":"Django: 1.8.13 - 1.10.8 Django Reversion: 1.8.7 - 1.10.2 Django Rest Framework: 3.2.2 - 3.4.7 Psycopg2: 2.5 - 2.7 Jinja2: 2.9.6 - 2.10 Ffs: 0.0.8.1 - 0.0.8.2 Requests: 2.7.0 - 2.18.4 django-celery: 3.1.17 - 3.2.2 celery: 3.1.19 - 3.1.25","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#misc-changes_4","text":"Removes the undocumented collapsed_multisave tag from the pathways templatetag library. Adds a setting OPAL_FAVICON_PATH to specify the application Favicon to use. Adds the rows option to the textarea template tag which just fills in the html textarea rows attribute. Text areas are defaulted to 5 rows (the same as before). Configures the setting CSRF_FAILURE_VIEW to use the bundled opal.views.csrf_failure view. Pathway slugs may now include hyphens as well as numbers, lower case letters and underscores. Bugfix: in edit_item.js $scope.episode_category is now set from episode.category_name as opposed to episode.category (which was always null) Fixes some instances of progressbars not being reset if unexpected error states occur. Improves the rendering of patient detail pages where no patient with the ID from route params exits. (Displays a polite message instead of erroring.) Incorrect pluralisation of subrecord names in the Admin view has been fixed. (Migrations will have to be run in all models which extend the changed core Opal models (this is due to a minor upstream Django bug) Minor change to the diagnosis form.","title":"Misc Changes"},{"location":"reference/changelog/#090-major-release","text":"","title":"0.9.0 (Major Release)"},{"location":"reference/changelog/#good-bye-date_of_episode-discharge_date-date_of_admission","text":"And hello episode.start and episode.end . These fields on the Episode model replace the multiple ways of recording Episode duration in Opal. There is a migration that sets start to date_of_episode if it exists, otherwise it uses date of admission. end will be date_of_episode if it exists, otherwise it will use discharge_date. Note that this means we no longer refer to start and end properties on the Episode category. If you override start and end in a custom episode category you should update to use the Episode model fields. This logic should be moved into your flows and you'll need to put in a migration to populate existing episodes. We also remove the episode fields date_of_episode discharge_date , and date_of_admission . Warning: Backwards migrations will not migrate back to date_of_episode but to a admission and discharge. Take backups before running these migrations! The fields start and end are both cast to moments (rather than raw js Dates) on episode.initialisation","title":"Good bye date_of_episode, discharge_date, date_of_admission"},{"location":"reference/changelog/#pathway","text":"Moves the opal-pathway module into the opal core. Pathways is an extensible way of creating forms that involve multiple subrecords.","title":"Pathway"},{"location":"reference/changelog/#weve-got-time-on-our-side","text":"Adds in the {% timepicker %} template tag, that follows the same convention as the other template tags, ie {% timepicker field=\"Dinner.time\" %}","title":"We've got time on our side"},{"location":"reference/changelog/#removes-a-js-global-declaration-of-categories","text":"Previously we declared CATEGORIES globally. This has now been removed","title":"Removes a js global declaration of categories"},{"location":"reference/changelog/#order-order","text":"Episodes in the patient list are now ordered by start, first_name and surname","title":"Order Order"},{"location":"reference/changelog/#theming-support","text":"Improvements and better documentation and guides for theming applications. Particularly of note are changes to opal.html and base.html , as well as the addition of the static_page.html template. This version also includes extensive improved support for customising the templates that display patient lists, detail views, menus and forms amongst other things. For full documentation, consult the theming guide in the documentation.","title":"Theming support"},{"location":"reference/changelog/#makes-search-fully-pluggable","text":"Search is now completely pluggable, you need to have some angular controller called SearchCtrl, but apart from that you can plugin your own implementation.","title":"Makes search fully pluggable"},{"location":"reference/changelog/#exclude-prefixes-now-work-on-actual-paths","text":"Previously they only worked with angular paths, now they work with a combination of actual paths and angular url paths (e.g. /search/#/extract)","title":"Exclude prefixes now work on actual paths"},{"location":"reference/changelog/#misc-changes_5","text":"Add the allow_add_patient and allow_edit_teams options to the patient lists. We added support for a --file or -f option for the load_lookup_lists command which allows the user to specify a particular file outside of the default locations. The default Location record display template will no longer include references to Episode.start . and Episode.stop labelled as admisssion and discharge to support the majority case where an episode relates to something other than an inpatient episode! Applications wishing to retaint this functionality should update their own temaplates to display start/stop details.","title":"Misc Changes"},{"location":"reference/changelog/#removes-deprecated-functionality-in-referencedata-metadata-userprofile-and-recordloader","text":"Previously these would make their http request when imported into a file. They now require you to call .load() for them to return the promise that loads in their respective data.","title":"Removes Deprecated functionality in ReferenceData, Metadata, UserProfile and recordLoader"},{"location":"reference/changelog/#083-minor-release","text":"","title":"0.8.3 (Minor Release)"},{"location":"reference/changelog/#opallogconfidentialemailer","text":"Adds a custom email logger. This enables Django error emails which remove any confidential patient data. Also adds in the karma config to the MANIFEST.in so that we include the karma configs on pip install. It also moves it to \"opal/tests/js_config/karma_defaults.js\".","title":"opal.log.ConfidentialEmailer"},{"location":"reference/changelog/#082-minor-release","text":"","title":"0.8.2 (Minor Release)"},{"location":"reference/changelog/#opal_location-is-added-as-a-system-variable-when-running-js-tests","text":"If you run opal test js, your karma config is now run in an environment that has access to the OPAL_LOCATION variable which points to the opal parent directory.","title":"OPAL_LOCATION is added as a system variable when running js tests"},{"location":"reference/changelog/#a-data-dictionary-in-the-extract","text":"The Extract zip file has a data dictionary with human readable metadata about each field.","title":"A Data Dictionary In The Extract"},{"location":"reference/changelog/#enhanced-application-menus","text":"The application menu API, previously python dicts stored in attributes on either plugin or application subclasses, now consists of the new opal.core.menus.MenuItem class, enabling enhanced customisation and flexibility.","title":"Enhanced Application menus"},{"location":"reference/changelog/#put-to-the-episode-api-returns-the-episode-with-all-its-subrecords","text":"Previously it only returned the episode. Now it matches the episode create api end point","title":"PUT to the episode API returns the episode with all its subrecords"},{"location":"reference/changelog/#episodepatient-links-in-admin","text":"In the admin, episodes and patients lists now have links to the patient detail pages.","title":"Episode/Patient links in admin"},{"location":"reference/changelog/#user-data-for-the-client","text":"Adds a User Angular service that enables applications to use user data. Also adds some directives to make it easy to render User names and avatars.","title":"User data for the client"},{"location":"reference/changelog/#episodegetfullname","text":"Adds a utility method to the Episode service that returns a human readable patient name.","title":"Episode.getFullName()"},{"location":"reference/changelog/#pluginget_javascripts-pluginget_styles","text":"Enhances the API available for plugins to include javascript and css by adding methods on opal.core.plugins.OpalPlugin","title":"Plugin.get_javascripts, Plugin.get_styles"},{"location":"reference/changelog/#element_type-argument-for-the-form-template-tags","text":"Numeric database fields are now set as the html5 type=\"number\" when rendering them with the forms templatetag library. This means on mobile devices it will bring up the numeric keypad. The element type can now be set via the template tag API with the 'element_type' argument.","title":"'element_type' argument for the form template tags"},{"location":"reference/changelog/#opal_logo_path","text":"This new setting allows applications to set the path at which the app logo is served. If OPAL_LOGO_PATH is set, the value is passed to the {% static %} templatetag to set the src atribute of an image in the default application header and login screen.","title":"OPAL_LOGO_PATH"},{"location":"reference/changelog/#inactive-episodes-in-patientlists","text":"Changes the behaviour of opal.core.PatientList.to_dict to serialise inactive episodes by default rather than filtering by Episode.active == True. opal.core.TaggedPatientList.to_dict continues to filter by Episode.active == True by default.","title":"Inactive episodes in PatientLists"},{"location":"reference/changelog/#notice-of-future-removals","text":"The context variables brand_name settings and extra_application in opal.views.IndexView are no longer helpful thanks to the settings context processor. These will be removed in 0.9.0 and emit warnings until then.","title":"Notice of future removals"},{"location":"reference/changelog/#misc-changes_6","text":"Adds a new filter - underscore-to-spaces for removing underscores from strings. The options for SymptomComplex.duration have moved from the default form template to a choices declaration on the model. These are scheduled to move again to a lookuplist. The default value of Subrecord.get_display_name now uses Django Meta.verbose_name .","title":"Misc changes"},{"location":"reference/changelog/#minor-fixes","text":"Fixes a bug where the allergies form rendered the provisional field twice","title":"Minor fixes"},{"location":"reference/changelog/#updates-to-the-dependency-graph_5","text":"Upgrades Font Awesome from 4.3.0 - 4.7.0 Upgrades Jinja2 from 2.8 - 2.9.6","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#081-minor-release","text":"","title":"0.8.1 (Minor Release)"},{"location":"reference/changelog/#cookies-for-the-future","text":"We now use the $cookies api as part of moving to angular v1.5.8. The default expiry of cookies is now a year in the future. The cookie name previously stored as opal.lastPatientList is now opal.previousPatientList .","title":"Cookies for the future"},{"location":"reference/changelog/#patients-as-a-service","text":"Patient becomes a service in angular. This takes in a patient as loaded by the patient loader or another service. It casts the data to Episode or Item instances as appropriate.","title":"Patients as a service"},{"location":"reference/changelog/#patientlistget_queryset-arguments","text":"PatientList.get_queryset() is now passed an extra keyword argument - user . This is the current User object.","title":"PatientList.get_queryset arguments"},{"location":"reference/changelog/#overriding-default-menu-items-behaviour","text":"The get_menu_items method of Opal Application objects is now passed an extra keyword argument - user . This is the current User object. The templatetag application_menuitems now uses this method to render navigation menus, allowing dynamic customisation of menu contents based on user.","title":"Overriding default Menu Items behaviour"},{"location":"reference/changelog/#removals","text":"Opal 0.8.1 removes some minor features which, to our knowledge are not used by any applications in active development. ReopenEpisodeCtrl - applications may implement their own 're-open' episode flow, but Opal no longer handles this out of the box. Subrecord._bulk_serialise - this flag has been removed","title":"Removals"},{"location":"reference/changelog/#pending-removals","text":"We have re-named opal.core.views._build_json_response to opal.core.views.json_response . This will issue a warning for the remainder of the 0.8.x branch, before being removed entirely in Opal 0.9.0.","title":"Pending removals"},{"location":"reference/changelog/#subrecord-list-api","text":"We have added a list method to the default Opal JSON API for subrecords - you may now obtain a list of all instances of a given subrecord from the API endpoint /api/v0.1/$api_name/ .","title":"Subrecord List API"},{"location":"reference/changelog/#misc-changes_7","text":"Updates the custom UserAdmin so that the email, first and last name fields from the Django User model are in the add user form not just the edit user form. The default test runner generated by plugin scaffolding now uses opal.urls as the default url conf in the test settings. This allows you to test urls generated by Opal - for instance default form or record templates, or simply raw templates from our generic template view.","title":"Misc Changes"},{"location":"reference/changelog/#080-major-release","text":"","title":"0.8.0 (Major Release)"},{"location":"reference/changelog/#plugins","text":"Plugins have been refactored and are now DiscoverableFeatures . This should have no impact on existing plugins, however the functions opal.core.plugins.register and opal.core.plugins.plugins are slated for removal in 0.9.0 When creating new plugins we will place the plugin definition class in plugin.py rather than __init__.py","title":"Plugins"},{"location":"reference/changelog/#opalcoreapipatient_from_pk","text":"A decorator that changes a method that is passed a pk, to a method that is passed a patient.","title":"opal.core.api.patient_from_pk"},{"location":"reference/changelog/#todictmixin_bulk_serialise","text":"Adds a flag to the to dict mixin to determine whether the item is serialised as part of Episode/Patient.to_dict .","title":"ToDictMixin._bulk_serialise"},{"location":"reference/changelog/#fixes-bugs-in-add-many-subrecord-radio-buttons","text":"Previously multiple radio buttons for the same subrecord field on the same page would not appear to the user to update correctly. This has now been fixed.","title":"Fixes bugs in add many subrecord radio buttons"},{"location":"reference/changelog/#angular-ui-libraries","text":"0.8.0 consolidates Angular UI libraries bundled with Opal. We have removed Angular Strap, and switched all components using it to their Angular UI Bootstrap equivalents. This is a breaking change. Applications taking advantage of the Forms templatetag library should require no updates, but will see some minor differences in visual style of widgets. Detailed upgrade guides for the components affected (Typeahead, Popover, Tooltip, Datepicker, Timepicker) are available in the upgrade reference documentation.","title":"Angular UI Libraries"},{"location":"reference/changelog/#defaults-for-client-side-subrecords","text":"We pull through default values from subrecord fields into the Opal Schema and use those values when initializing the relevant Item instance for a new subrecord. This should greatly reduce the need to use custom Angular subrecord services to set defaults.","title":"Defaults for Client Side subrecords"},{"location":"reference/changelog/#choices-in-form-templatetags","text":"Template tags that use the 'field' attribute to point to a subrecord field will now infer a lookup list from the Choices of the field if it exists. Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively.","title":"Choices in form templatetags"},{"location":"reference/changelog/#element-name-in-template-tags","text":"The html attribute 'name' for form elements generated with the Opal {% forms %} templatetag library used to be inferred from the model name. Although this remains the default you can also set it with an angular expression: {% select field= Demographics.first_name element_name= ...Your Angular expression... %}","title":"element name in template tags"},{"location":"reference/changelog/#model-removals","text":"The models Team , GP , CommunityNurse and LocatedModel - marked for removal since 0.6.0 have now been removed. As part of this change, the add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash.","title":"Model removals"},{"location":"reference/changelog/#python-3","text":"Opal 0.8.0 is the first version of Opal to support Python 3. This has meant changing the default ordering of PatientList instances to 0 rather than None. Moving forwards we expect all new code in Opal to be compatible both Python 2.7 / 3.4 / 3.5 / 3.6. This introduces an explicit Opal dependency on the Six module for maintaining codebases that span Python 2.x and 3.x.","title":"Python 3"},{"location":"reference/changelog/#tabbed-patient-list-groups","text":"Adds the class opal.core.patient_lists.TabbedPatientListGroup which displays groups of related lists as tabs at the top of each member list.","title":"Tabbed Patient List Groups"},{"location":"reference/changelog/#patientlist-sort-order","text":"To enable custom sort orders for individual PatientList s we introduce the comparator_service attribute. This names an Angular service which will return a list of comparator functions.","title":"PatientList sort order"},{"location":"reference/changelog/#patientlist-arbitrary-columns","text":"We now explicitly enable columns in spreadhseet lists that are not tied to subrecords. These can be included in PatientList schema instances as explicit Column() entries.","title":"PatientList Arbitrary columns"},{"location":"reference/changelog/#template-re-naming","text":"Modal_base has now been moved into a folder called base_templates. Its also now got a form_modal_base and a two_column_form_modal_base. The latter two templates add validation around saving. The standard edit item models and others now inherit from the form_modal_base.","title":"Template re-naming"},{"location":"reference/changelog/#authorization-and-permissions","text":"All APIs should be permissioned with Django REST framework permission classes. The default implementation uses opal.core.api.LoginRequiredViewset, a standard DRF viewset that requires the user to be logged in. We now require the user to be logged in for any use of the search functionality. Added a custom interceptor that logs the user out if the we receive a 403 or 401 from the server","title":"Authorization and permissions"},{"location":"reference/changelog/#form-validation","text":"Adds the checkForm directive e.g. button check-form= form ng-click= sendDataToTheServer click me /button This adds default form submission behaviour to the a button. It will check if the form is valid, and if its not it will mark the button as disabled until it becomes valid. It will also set the form as submitted. We also now show the required error if the form has been submitted or if the field is dirty, so that the user doesn't get an ugly \"fill this field in now\" message when opening the modal/pathway but will get the error after they click submit.","title":"Form Validation"},{"location":"reference/changelog/#removals_1","text":"Opal 0.8.0 removes a number of un-used features that have been slated for removal for some time: Options - both from the JSON API, and the Angular service. The legacy APIs /api/v0.1/episode/admit and /api/v0.1/episode/refer . The models GP , CommunityNurse and LocatedModel . opal.models.Tagging.import_from_reversion . This one-off classmethod on tagging was introduced to aid with the upgrade from Opal 4.x to 5.0 and has no further utility. The static argument from the forms input tag. Developers should move to the static tag. The _modal option to set on subrecords. This is because we now use large modals across the board.","title":"Removals"},{"location":"reference/changelog/#misc-changes_8","text":"The opal.core.api.EpisodeViewSet.create now expects tagging to be an object rather than a list, similar to how it details with demographics and location. The API will no longer serialise the _ft or _fk_id fields of FreeTextOrForeignKey fields - these are internal implementation details of the server that are not useful on the client side. Adds a Unique Together constraint for (Tagging.user, Tagging.episode, Tagging.value) Look up lists now load in from individual apps. The look for a file at {{ app }}/data/lookuplists.json The default admin url is now /admin/ - rather than /admin/? this results in more readable admin urls and is closer to what most applications do with the Django admin. The roles field opal.models.UserProfile.roles has been updated to be blank=True . This allows the editing of users without specific roles assigned in the Django admin. Although this introduces no changes at the database level, this does introduce a migration.","title":"Misc changes"},{"location":"reference/changelog/#updates-to-the-dependency-graph_6","text":"Upgrades angular to v1.5.8 (from 1.3.11) you can see their change log here Updates angular-cookies and angular-mocks to v1.5.8 (both from 1.3.11) Updates angular-ui-select to 0.19.4 from 0.13.2","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#075-minor-release","text":"The flow enter and exif functions now take an optional context argument. When called from PatientList or PatientDetail controllers this is the parent scope when the flow has been entered. Note: The current Flow API is likely to undergo substantial revision in Opal 0.9 / 0.10 do contact us on the mailing list if you are relying heavily upon it or would like to let us know your needs.","title":"0.7.5 (Minor Release)"},{"location":"reference/changelog/#074-minor-release","text":"Adds a past filter, future and past filters now take a boolean argument as to whether you should include today","title":"0.7.4 (Minor Release)"},{"location":"reference/changelog/#073-minor-release","text":"Fixes a bug whereby celery tasks are not autodiscovered - will have affected users of async extract functionality.","title":"0.7.3 (Minor Release)"},{"location":"reference/changelog/#072-minor-release","text":"Fixes a bug with the copy to category API not setting category name. Removes the hangover use of options in the list of teams per episode in the patient list","title":"0.7.2 (Minor Release)"},{"location":"reference/changelog/#071-minor-release","text":"Completes the refactor of front end data, no longer using the /api/v0.1/options/ API internally. This is slated for removal in 0.8.0. Updates DRF APIs - we now expect either Token or DjangoSession auth. Fixes several small bugs with scaffolded applications - the setting of STATIC_ROOT and SECRET_KEY , generating forms for NullBooleanFields, requirements.txt. Adds an aligned_pair templatetag to the panels library. Updates the label for Demographics.birth_place to indicate that this should be a country. Adds the clipboard directive to give the user one click copy to clipboard. Adds a tag-select directive that renders a widget for editing the tags for an episode. Adds metadata to the scope for patient detail views","title":"0.7.1 (Minor Release)"},{"location":"reference/changelog/#updates-to-the-dependency-graph_7","text":"Django Axes 1.4.0 - 1.7.0","title":"Updates to the Dependency Graph"},{"location":"reference/changelog/#070-major-release","text":"","title":"0.7.0 (Major Release)"},{"location":"reference/changelog/#episode-categories","text":"Refactors EpisodeCategory to be a discoverable feature. Renames Episode.category - Episode.category_name .","title":"Episode Categories"},{"location":"reference/changelog/#episode-json-api","text":"The Restful Episode JSON API previously available at /episode/:pk/ is now moved into /api/v0.1/episode/:pk/ for consistency with the rest of our JSON APIs. The Opal Angular layer has been updated to reflect this, and should handle the transition seamlessly, but code calling the API directly should update to reflect the new URL.","title":"Episode JSON API"},{"location":"reference/changelog/#defaults-for-records-on-the-client-side","text":"Establishes a new way to define defaults for records initialized in Javascript without requiring that we hard-code API names to defaults in a global namespace.","title":"Defaults for records on the client side"},{"location":"reference/changelog/#update-to-javascript-signatures","text":"Flow.enter() and Flow.exit() now no longer take options positional arguments - instead the controllers they initialize have Metadata and Referencedata as optional resolves arguments. AddEpisodeCtrl now no longer requires options as a resolves() option, but requires Referencedata instead.","title":"Update to Javascript Signatures"},{"location":"reference/changelog/#maxlength-for-form-helpers","text":"The input form helper will now infer the max length of char fields from the max length of the database field, and render relevant Angular directives.","title":"MaxLength for form helpers"},{"location":"reference/changelog/#episodedetail-removed","text":"The EpisodeDetailCtrl and EpisodeDetailMixin controller and service have been removed - these were not used anywhere other than in the Wardround plugin, and redundant after enhancements to Patient Detail and Custom DetailViews in 0.6.","title":"EpisodeDetail removed"},{"location":"reference/changelog/#additional-utilities","text":"Adds a datetimepicker templatetag that will render widgets for a Datetime field including time. Adds a date_of_birth_field templatetag that renders a date of birth field complete with inteligent validation. (Note this change also includes removing the old _partial/ template) Updates dependency graph: Django - 1.8.13","title":"Additional utilities"},{"location":"reference/changelog/#060-major-release","text":"Detail views Moves from episode oriented detail to patient oriented detail. (All episodes plus x-episode views are available from a patient detail screen) Tagging As a performance optimisation for the frequent access of historic tags, untagging an episode simply renders the tag inactive rather than deleting it and relying on Django-Reversion for access to historical data. Date Formatting We now expect 'd/m/y' date formatting by default. Patient lists Lists are now declarative, and separate from teams. They are implemented as subclasses of opal.core.patient_lists.PatientList. Forms vs. Modals Introduces a distinction between a form and a modal. By default, we now use forms for subrecords, only overriding the modal if there is something we want to do differently specifically in the modal. Command line tools Adds $opal checkout for switching between applications or application versions.","title":"0.6.0 (Major Release)"},{"location":"reference/changelog/#models-contextprocessor","text":"The 'opal.context_processors.models' Context Processor will allow you to access your subrecords from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include models.Demographics.get_detail_template %}","title":"Models ContextProcessor"},{"location":"reference/changelog/#upgrade-instructions","text":"Full upgrade instructions to work through any backwards incompatible changes are provided in the Opal docs.","title":"Upgrade instructions:"},{"location":"reference/changelog/#055-minor-release","text":"Changes the way old tags are handled. Tags are no longer deleted episodes, rather they're marked as archived.","title":"0.5.5 (Minor Release)"},{"location":"reference/changelog/#054-minor-release","text":"Include local storage","title":"0.5.4 (Minor Release)"},{"location":"reference/changelog/#053-minor-release","text":"Speed up loading of the lookup lists Fix pagination issues in search Speed up loading of many to many fields Increase test coverage Add some extra help fields to {% forms %} helpers Fixes bug with $rootScope.open_modal() where keystrokes were being intercepted","title":"0.5.3 (Minor Release)"},{"location":"reference/changelog/#052-minor-release","text":"Speed improvements on page load allow us to only show record panels if a record of that type exists disable modal buttons while saving","title":"0.5.2 (Minor Release)"},{"location":"reference/changelog/#051-minor-release","text":"Minor bug fixes","title":"0.5.1 (Minor Release)"},{"location":"reference/changelog/#05-major-release","text":"Search Complete re-design of Search interface to provide a single search box on every page and pagination for resulta. Puts in place a pluggable interface that could be swapped out for e.g. ElasticSearch. New Service for PatientSummary() Analytics Moves Analytics integration into Opal core with the ability to blacklist pages that should never be reported List view Removed old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row. Updated scrolling and loading behaviour to snap to viewport and not display the page build. Subrecord metadata Added four new utility fields to Patient and Episode subrecords: created_by, updated_by, created, updated Select2 and list fields Added support for select2 as an input widget and Subrecord fields that can be lists of things. Also Numerous small bugfixes. Refactoring of the models package into a models module. Updated Underscore.js - 1.8.3 Updated Angular.js - 1.3.11","title":"0.5 (Major release)"},{"location":"reference/changelog/#043-minor-release","text":"Refactors opal.models to be a models.py file rather than a package. Adds several improvements to forms helpers - Help argument, other argument to select. Updates dependency graph: Angular-strap - 2.3.1","title":"0.4.3 (Minor release)"},{"location":"reference/changelog/#042-minor-release","text":"Upgrades dependency graph: Django - 1.8.3 Django-reversion - 1.8.7 jQuery - 1.11.3 D3 - 3.5.6 C4 - 0.4.10 South has been removed, now using django migrations","title":"0.4.2 (Minor release)"},{"location":"reference/changelog/#041-bugfix-release","text":"Fixes some search results appearing duplicated.","title":"0.4.1 (Bugfix release)"},{"location":"reference/changelog/#04-major-release","text":"New Design Completely re-designed UI following extensive user research and multiple iterations. Managementcommands and scaffolding Features the opal command line tool for common administrative tasks http://opal.openhealthcare.org.uk/docs/guides/command_line_tool/ Form helpers templatetag library New template library for consistent form controls in line with our new interface guidelines http://opal.openhealthcare.org.uk/docs/reference/form_templatetags/ API Documentation Opal JSON APIs are now fully self-documenting for all updated instances http://opal.openhealthcare.org.uk/docs/guides/json_api/","title":"0.4 (Major release)"},{"location":"reference/changelog/#03-major-release","text":"Bugfixes, significant flexibility in template customisability. Minor UI updates.","title":"0.3 (Major release)"},{"location":"reference/changelog/#022-bugfix-release","text":"Numerous small bugfixes. Adds the concept of undischarging patients.","title":"0.2.2 (Bugfix release)"},{"location":"reference/changelog/#021","text":"Numerous small bugfixes.","title":"0.2.1"},{"location":"reference/changelog/#020","text":"Search overhaul - introduces advanced searches.","title":"0.2.0"},{"location":"reference/changelog/#011","text":"Initial public release","title":"0.1.1"},{"location":"reference/core_discoverable/","text":"opal.core.discoverable The opal.core.discoverable module contans base discoverable classes for creating features which can be re-used and subcalssd. DiscoverableFeature The base discoverable class which provides functionality to all discoverables. DiscoverableFeature properties DiscoverableFeature.module_name The name of the python module in which Opal will look for instances of this discoverable. For instance in the following feature, Opal would look in every installed app at app/ciao.py for subclasses of Greeting , even if that module had not been directly imported already. from opal.core import discoverable class Greeting(discoverable.DiscoverableFeature): module_name = 'ciao' DiscoverableFeature.display_name The human readable name for an instance of a discoverable. Use this in the UI when showing the discoverable to users. DiscoverableFeature.slug The slug for this discoverable used in URLs. Note that Opal internally useses the get_slug method below to allow more dynamic slugs. DiscoverableFeature classmethods DiscoverableFeature.is_valid() Stub function that is called at class definition to determine whether an instance is valid. Useful for enforcing business logic and expectations for third party features. Expected to raise an exception if something is wrong. DiscoverableFeature.get_slug() Return the slug for this feature. Defaults to returning the slug property if it is set, or running a slugify function on the display_name . If neither is set it will raise a ValueError. MyFeature.get_slug() # - my-feature DiscoverableFeature.list() Return a generator that yields all implementations of a discoverable. for g in Greeting.list(): print g.display_name Bonjour Hola Namaste Salaam DiscoverableFeature.filter(**kwargs) Find instances of a feature based on the value of their attributes. You may pass attributes of features as keyword arguments. Returns a list of matching features. Greeting.filter(module_name='ciao') # Essentially the same as .list() Greeting.filter(slug= bonjour , display_name= Bonjour ) # - [BonjourGreeting] SortableFeature A mixin class that provides ordering for features which will be respected by both list() and filter() . Properties SortableFeature.order An integer which is used to sort features. SortableFeature classmethods SortableFeature.list() Returns instances of the feature orderd by .order class Greeting(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name='ciao' class Namaste(Greeting): order = 2 class Hello(Greeting): order = 32098239021 class Bonjour(Greeting): order = 1 for f in Greeting.list(): print f, f.order # class '*.*.Bonjour' , 1 # class '*.*.Namaste' , 2 # class '*.*.Hello' , 3 RestrictableFeature A mixin class that provides an interface for restricting access to features based on user. class Greeting(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name='ciao' RestrictableFeature classmethods RestrictableFeature.for_user(user) Generator method that yields all instances of this discoverable which are visible to a given user. for f in Greeting.for_user(user): print f # class '*.*.Bonjour' # class '*.*.Namaste' # class '*.*.Hello' RestrictableFeature.visible_to(user) Predicate function used to determine whehter in individual feature should be visible to a given user. Defaults to simply returning True. Features may override this to provide restricted access as required. Hello.visible_to(user) # - True","title":"Discoverable"},{"location":"reference/core_discoverable/#opalcorediscoverable","text":"The opal.core.discoverable module contans base discoverable classes for creating features which can be re-used and subcalssd.","title":"opal.core.discoverable"},{"location":"reference/core_discoverable/#discoverablefeature","text":"The base discoverable class which provides functionality to all discoverables. DiscoverableFeature properties","title":"DiscoverableFeature"},{"location":"reference/core_discoverable/#discoverablefeaturemodule_name","text":"The name of the python module in which Opal will look for instances of this discoverable. For instance in the following feature, Opal would look in every installed app at app/ciao.py for subclasses of Greeting , even if that module had not been directly imported already. from opal.core import discoverable class Greeting(discoverable.DiscoverableFeature): module_name = 'ciao'","title":"DiscoverableFeature.module_name"},{"location":"reference/core_discoverable/#discoverablefeaturedisplay_name","text":"The human readable name for an instance of a discoverable. Use this in the UI when showing the discoverable to users.","title":"DiscoverableFeature.display_name"},{"location":"reference/core_discoverable/#discoverablefeatureslug","text":"The slug for this discoverable used in URLs. Note that Opal internally useses the get_slug method below to allow more dynamic slugs. DiscoverableFeature classmethods","title":"DiscoverableFeature.slug"},{"location":"reference/core_discoverable/#discoverablefeatureis_valid","text":"Stub function that is called at class definition to determine whether an instance is valid. Useful for enforcing business logic and expectations for third party features. Expected to raise an exception if something is wrong.","title":"DiscoverableFeature.is_valid()"},{"location":"reference/core_discoverable/#discoverablefeatureget_slug","text":"Return the slug for this feature. Defaults to returning the slug property if it is set, or running a slugify function on the display_name . If neither is set it will raise a ValueError. MyFeature.get_slug() # - my-feature","title":"DiscoverableFeature.get_slug()"},{"location":"reference/core_discoverable/#discoverablefeaturelist","text":"Return a generator that yields all implementations of a discoverable. for g in Greeting.list(): print g.display_name Bonjour Hola Namaste Salaam","title":"DiscoverableFeature.list()"},{"location":"reference/core_discoverable/#discoverablefeaturefilterkwargs","text":"Find instances of a feature based on the value of their attributes. You may pass attributes of features as keyword arguments. Returns a list of matching features. Greeting.filter(module_name='ciao') # Essentially the same as .list() Greeting.filter(slug= bonjour , display_name= Bonjour ) # - [BonjourGreeting]","title":"DiscoverableFeature.filter(**kwargs)"},{"location":"reference/core_discoverable/#sortablefeature","text":"A mixin class that provides ordering for features which will be respected by both list() and filter() . Properties","title":"SortableFeature"},{"location":"reference/core_discoverable/#sortablefeatureorder","text":"An integer which is used to sort features. SortableFeature classmethods","title":"SortableFeature.order"},{"location":"reference/core_discoverable/#sortablefeaturelist","text":"Returns instances of the feature orderd by .order class Greeting(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name='ciao' class Namaste(Greeting): order = 2 class Hello(Greeting): order = 32098239021 class Bonjour(Greeting): order = 1 for f in Greeting.list(): print f, f.order # class '*.*.Bonjour' , 1 # class '*.*.Namaste' , 2 # class '*.*.Hello' , 3","title":"SortableFeature.list()"},{"location":"reference/core_discoverable/#restrictablefeature","text":"A mixin class that provides an interface for restricting access to features based on user. class Greeting(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name='ciao' RestrictableFeature classmethods","title":"RestrictableFeature"},{"location":"reference/core_discoverable/#restrictablefeaturefor_useruser","text":"Generator method that yields all instances of this discoverable which are visible to a given user. for f in Greeting.for_user(user): print f # class '*.*.Bonjour' # class '*.*.Namaste' # class '*.*.Hello'","title":"RestrictableFeature.for_user(user)"},{"location":"reference/core_discoverable/#restrictablefeaturevisible_touser","text":"Predicate function used to determine whehter in individual feature should be visible to a given user. Defaults to simply returning True. Features may override this to provide restricted access as required. Hello.visible_to(user) # - True","title":"RestrictableFeature.visible_to(user)"},{"location":"reference/core_fields/","text":"# opal.core.fields The opal.core.fields module contains helper functions for working with fields, as well as custom Opal field definitions. is_numeric A helper function that returns true if a field is numeric. For our purposes, Integers, Decimals, BigIntegers, Floats and Positive Integers are considered numeric. is_numeric(models.IntegerField()) # - True enum A helper function that returns a Django choices definition from star args. enum('one', '2', 'III') # - ( # ('one', 'one'), # ('2', '2'), # ('III', 'III') # ) ForeignKeyOrFreeText A field that stores it's value as a generic foreign key to an Opal LookupList or as the value in a CharField. By default this is case insensitive, pass in case_sensitive=True to make it case sensitive when matching against lookup lists or synonyms. e.g. class Duck(object): name = ForeignKeyOrFreeText(Name) show = ForiegnKeyOrFreeText(Show, case_sensitive=True) Name.objects.create(name= Scrooge ) Show.objects.create(name= Duck Tales ) scrooge = Duck() # by default we are case insensitive, so this will be saved # as a foreign key to a Name object scrooge.name = scrooge # ie now scrooge.name == Scrooge scrooge.name_fk == Name.objects.get(name= Scrooge ) # this is not a case sensitive field so will be stored on the model as free # text scrooge.show = duck tales # ie scrooge.show_ft == duck tales","title":"Fields"},{"location":"reference/core_fields/#is_numeric","text":"A helper function that returns true if a field is numeric. For our purposes, Integers, Decimals, BigIntegers, Floats and Positive Integers are considered numeric. is_numeric(models.IntegerField()) # - True","title":"is_numeric"},{"location":"reference/core_fields/#enum","text":"A helper function that returns a Django choices definition from star args. enum('one', '2', 'III') # - ( # ('one', 'one'), # ('2', '2'), # ('III', 'III') # )","title":"enum"},{"location":"reference/core_fields/#foreignkeyorfreetext","text":"A field that stores it's value as a generic foreign key to an Opal LookupList or as the value in a CharField. By default this is case insensitive, pass in case_sensitive=True to make it case sensitive when matching against lookup lists or synonyms. e.g. class Duck(object): name = ForeignKeyOrFreeText(Name) show = ForiegnKeyOrFreeText(Show, case_sensitive=True) Name.objects.create(name= Scrooge ) Show.objects.create(name= Duck Tales ) scrooge = Duck() # by default we are case insensitive, so this will be saved # as a foreign key to a Name object scrooge.name = scrooge # ie now scrooge.name == Scrooge scrooge.name_fk == Name.objects.get(name= Scrooge ) # this is not a case sensitive field so will be stored on the model as free # text scrooge.show = duck tales # ie scrooge.show_ft == duck tales","title":"ForeignKeyOrFreeText"},{"location":"reference/core_lookuplists/","text":"opal.core.lookuplists The opal.core.lookuplists module contains utility functions for working with lookuplists. lookuplists() A generator that will yield every lookuplist currently available to the application. from opal.core import lookuplists for l in lookuplists.lookuplists(): print l # - Drug, Gender, Condition et cetera","title":"Lookuplists"},{"location":"reference/core_lookuplists/#opalcorelookuplists","text":"The opal.core.lookuplists module contains utility functions for working with lookuplists.","title":"opal.core.lookuplists"},{"location":"reference/core_lookuplists/#lookuplists","text":"A generator that will yield every lookuplist currently available to the application. from opal.core import lookuplists for l in lookuplists.lookuplists(): print l # - Drug, Gender, Condition et cetera","title":"lookuplists()"},{"location":"reference/core_menus/","text":"opal.core.menus Opal provides classes and methods to define application menus programatically. opal.core.MenuItem An item in an application menu. Arguments template_name - a template to use to render this menu item activepattern - if the current path includes this, add the active class href - the path to use as the link for this menu item icon - an icon name to be used display - the text to display in this menu item index - a number to use as the primary sort order for your menu items Methods for_user A method that takes a user and returns True by default. Override this if you want menu items hidden for certain users. opal.core.Menu The menu for an Opal application. On initialization it will construct a menu for the current user, pulling items from the current app, and any plugins.","title":"Menus"},{"location":"reference/core_menus/#opalcoremenus","text":"Opal provides classes and methods to define application menus programatically.","title":"opal.core.menus"},{"location":"reference/core_menus/#opalcoremenuitem","text":"An item in an application menu. Arguments template_name - a template to use to render this menu item activepattern - if the current path includes this, add the active class href - the path to use as the link for this menu item icon - an icon name to be used display - the text to display in this menu item index - a number to use as the primary sort order for your menu items Methods","title":"opal.core.MenuItem"},{"location":"reference/core_menus/#for_user","text":"A method that takes a user and returns True by default. Override this if you want menu items hidden for certain users.","title":"for_user"},{"location":"reference/core_menus/#opalcoremenu","text":"The menu for an Opal application. On initialization it will construct a menu for the current user, pulling items from the current app, and any plugins.","title":"opal.core.Menu"},{"location":"reference/core_serialization/","text":"opal.core.serialization Helpers for serializing and deserializing data serialize_date(value) Given a date, serialize it to a string using the settings.DATE_FORMAT as_date_str = serialize_date(datetime.date(2019, 4, 1)) serialize_datetime(value) Given a datetime, serialize it to a string using the settings.DATETIME_FORMAT as_datetime_str = serialize_datetime(datetime.datetime(2019, 4, 1, 10, 30)) serialize_time(value) Given a time, serialize it to a string using the settings.TIME_FORMAT as_datetime_str = serialize_time(datetime.time(10, 30)) deserialize_datetime(value) Given a string which represents a date time, deserialize it to a Python datetime object using the first value of settings.DATETIME_INPUT_FORMATS . as_datetime = deserialize_datetime('22/04/1959 21:20:22') deserialize_time(value) Given a string which represents a time, deserialize it to a Python time object using the first value of settings.TIME_INPUT_FORMATS . as_time = deserialize_time('14:30:59') deserialize_date(value) Given a string which represents a date, deserialize it to a Python date object using the first value of settings.DATE_INPUT_FORMATS . as_date = deserialize_date('22/04/1959') OpalSerializer A JSON serializer that will serialize the output of to_dict calls. This serializer uses date formats that can be understood by the Opal javascript applications. import json as_dict = episode.to_dict(user) as_json = json.dumps(as_dict, cls=OpalSerializer)","title":"Serialization"},{"location":"reference/core_serialization/#opalcoreserialization","text":"Helpers for serializing and deserializing data","title":"opal.core.serialization"},{"location":"reference/core_serialization/#serialize_datevalue","text":"Given a date, serialize it to a string using the settings.DATE_FORMAT as_date_str = serialize_date(datetime.date(2019, 4, 1))","title":"serialize_date(value)"},{"location":"reference/core_serialization/#serialize_datetimevalue","text":"Given a datetime, serialize it to a string using the settings.DATETIME_FORMAT as_datetime_str = serialize_datetime(datetime.datetime(2019, 4, 1, 10, 30))","title":"serialize_datetime(value)"},{"location":"reference/core_serialization/#serialize_timevalue","text":"Given a time, serialize it to a string using the settings.TIME_FORMAT as_datetime_str = serialize_time(datetime.time(10, 30))","title":"serialize_time(value)"},{"location":"reference/core_serialization/#deserialize_datetimevalue","text":"Given a string which represents a date time, deserialize it to a Python datetime object using the first value of settings.DATETIME_INPUT_FORMATS . as_datetime = deserialize_datetime('22/04/1959 21:20:22')","title":"deserialize_datetime(value)"},{"location":"reference/core_serialization/#deserialize_timevalue","text":"Given a string which represents a time, deserialize it to a Python time object using the first value of settings.TIME_INPUT_FORMATS . as_time = deserialize_time('14:30:59')","title":"deserialize_time(value)"},{"location":"reference/core_serialization/#deserialize_datevalue","text":"Given a string which represents a date, deserialize it to a Python date object using the first value of settings.DATE_INPUT_FORMATS . as_date = deserialize_date('22/04/1959')","title":"deserialize_date(value)"},{"location":"reference/core_serialization/#opalserializer","text":"A JSON serializer that will serialize the output of to_dict calls. This serializer uses date formats that can be understood by the Opal javascript applications. import json as_dict = episode.to_dict(user) as_json = json.dumps(as_dict, cls=OpalSerializer)","title":"OpalSerializer"},{"location":"reference/core_subrecords/","text":"opal.core.subrecords The opal.core.subrecords module contains utility functions for working with subrecords. episode_subrecords() Generator function that iterates through all episode subrecords. for s in episode_subrecords(): print(s) # - Location, Diagosis et cetera patient_subrecords() Generator function that iterates through all patient subrecords. for s in patient_subrecords(): print(s) # - Allergies, ContactDetails et cetera subrecords() Generator function that iterates through all subrecords. for s in subrecords(): print(s) # - Allergies, ContactDetails, Location, Diagnosis et cetera singletons() Generator function that iterates through all singleton subrecords. for s in singletons(): print(s) # - Location, Demographics Fetchers get_subrecord_from_api_name(api_name) Return a subrecord given the relevant API name for it. Raise a ValueError if no matching subrecord is found. get_subrecord_from_api_name('demographics') # - class Demographics get_subrecord_from_model_name(model_name) Return a subrecord given the relevant model name for it. Raise a ValueError if no matching subrecord is found. get_subrecord_from_api_name('Demographics') # - class Demographics","title":"Subrecords"},{"location":"reference/core_subrecords/#opalcoresubrecords","text":"The opal.core.subrecords module contains utility functions for working with subrecords.","title":"opal.core.subrecords"},{"location":"reference/core_subrecords/#episode_subrecords","text":"Generator function that iterates through all episode subrecords. for s in episode_subrecords(): print(s) # - Location, Diagosis et cetera","title":"episode_subrecords()"},{"location":"reference/core_subrecords/#patient_subrecords","text":"Generator function that iterates through all patient subrecords. for s in patient_subrecords(): print(s) # - Allergies, ContactDetails et cetera","title":"patient_subrecords()"},{"location":"reference/core_subrecords/#subrecords","text":"Generator function that iterates through all subrecords. for s in subrecords(): print(s) # - Allergies, ContactDetails, Location, Diagnosis et cetera","title":"subrecords()"},{"location":"reference/core_subrecords/#singletons","text":"Generator function that iterates through all singleton subrecords. for s in singletons(): print(s) # - Location, Demographics","title":"singletons()"},{"location":"reference/core_subrecords/#fetchers","text":"","title":"Fetchers"},{"location":"reference/core_subrecords/#get_subrecord_from_api_nameapi_name","text":"Return a subrecord given the relevant API name for it. Raise a ValueError if no matching subrecord is found. get_subrecord_from_api_name('demographics') # - class Demographics","title":"get_subrecord_from_api_name(api_name)"},{"location":"reference/core_subrecords/#get_subrecord_from_model_namemodel_name","text":"Return a subrecord given the relevant model name for it. Raise a ValueError if no matching subrecord is found. get_subrecord_from_api_name('Demographics') # - class Demographics","title":"get_subrecord_from_model_name(model_name)"},{"location":"reference/core_views/","text":"opal.core.views Opal provides a number of helper functions and classes for working with Django views. opal.core.views.LoginRequiredMixin A Mixin class that can be used with a view to ensure that we require users to be logged in in order to access the view. class MyView(LoginRequiredMixin, View): pass opal.core.views.json_response Returns a Django HTTPResponse instance with the data argument serialized using the correct serialization class. json_response(data, status_code=200):","title":"Core.Views"},{"location":"reference/core_views/#opalcoreviews","text":"Opal provides a number of helper functions and classes for working with Django views.","title":"opal.core.views"},{"location":"reference/core_views/#opalcoreviewsloginrequiredmixin","text":"A Mixin class that can be used with a view to ensure that we require users to be logged in in order to access the view. class MyView(LoginRequiredMixin, View): pass","title":"opal.core.views.LoginRequiredMixin"},{"location":"reference/core_views/#opalcoreviewsjson_response","text":"Returns a Django HTTPResponse instance with the data argument serialized using the correct serialization class. json_response(data, status_code=200):","title":"opal.core.views.json_response"},{"location":"reference/detail_views/","text":"opal.core.PatientDetailView PatientDetailViews allow us to define a custom view over either one or many episodes, available from the main Patient Detail view. PatientDetailView inherits from the discoverable features DiscoverableFeature , SortableFeature , RestrictableFeature . Fields PatientDetailView.name The machine readable name for this view. Should be lower case, and have no spaces. PatientDetailView.title The display name for this view. This is what will display in links to it. PatientDetailView.template The template we should use to render the view when it's active. PatientDetailView.order An integer controlling the order of PatientDetailViews in the episode switcher menu on the Patient Detail screen is determined by this property. Lower numbers mean higher up. Classmethods PatientDetailView.visible_to Overriding this method will restrict who the view is available to. For instance, we would implement a superuser only view: @classmethod def to_user(klass, user): return user.is_superuser","title":"Detail Views"},{"location":"reference/detail_views/#opalcorepatientdetailview","text":"PatientDetailViews allow us to define a custom view over either one or many episodes, available from the main Patient Detail view. PatientDetailView inherits from the discoverable features DiscoverableFeature , SortableFeature , RestrictableFeature .","title":"opal.core.PatientDetailView"},{"location":"reference/detail_views/#fields","text":"","title":"Fields"},{"location":"reference/detail_views/#patientdetailviewname","text":"The machine readable name for this view. Should be lower case, and have no spaces.","title":"PatientDetailView.name"},{"location":"reference/detail_views/#patientdetailviewtitle","text":"The display name for this view. This is what will display in links to it.","title":"PatientDetailView.title"},{"location":"reference/detail_views/#patientdetailviewtemplate","text":"The template we should use to render the view when it's active.","title":"PatientDetailView.template"},{"location":"reference/detail_views/#patientdetailvieworder","text":"An integer controlling the order of PatientDetailViews in the episode switcher menu on the Patient Detail screen is determined by this property. Lower numbers mean higher up.","title":"PatientDetailView.order"},{"location":"reference/detail_views/#classmethods","text":"","title":"Classmethods"},{"location":"reference/detail_views/#patientdetailviewvisible_to","text":"Overriding this method will restrict who the view is available to. For instance, we would implement a superuser only view: @classmethod def to_user(klass, user): return user.is_superuser","title":"PatientDetailView.visible_to"},{"location":"reference/episode/","text":"opal.models.Episode The opal.models.Episode class represents an episode of care for a patient. This can be either an inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic, or any other arbitrarily defined period of care. Fields Episode.category The category of this episode - e.g. inpatient, outpatient et cetera. This defaults to whatever is set on your application's subclass of opal.core.application.OpalApplication - which itself defaults to 'inpatient'. Episode.patient A foreign key relationship to the patient for whom this episode concerns. Episode.active A boolean to provide a quick lookup for whether this is an active or closed episode. Episode.start This should be the start of the episode. If this is an inpatient episode, the date of admission. Episode.end This should be the end of the episode. If this is an inpatient episode, the date of discharge. Episode.consistency_token A (automatically generated) hash of the above fields. This is used for detecting concurrent edits. Methods The Episode model has the following methods: Episode.get_absolute_url() Return the URL for this Episode Episode.to_dict(user) Return a dictionary of field value pairs for this episode episode.to_dict(user) Arguments: user The User for whom we want to serialise this episode Keywords: shallow Boolean to indicate whether we want just this episode, or also a sorted set of previous and subsequent episodes Episode.get_tag_names(user) Arguments: user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.get_tag_names(user) # ['mine', 'infectioncontrol'] Episode.set_tag_names(tag_names, user) Arguments: tag_names The list of tags that we want to be active for this Episode. user The user for whom we want the tag names. Set tags for this Episode. episode.set_tag_names(['mine', 'infectioncontrol'], user) Episode.set_tag_names_from_tagging_dict(tagging_dict, user) Arguments: tagging_dict The dictionary of {tag_name: boolean} tags to set user The user for whom we want the tag names. Set tags for this Episode. episode.set_tag_names_from_tagging_dict({'inpatient': True}, user) Episode.set_stage(stage, user, data) Setter function for episode stage. Will validate that the stage given is valid for the current EpisodeCategory and raise ValueError if it is invalid. episode.set_stage('Discharged', user, {}) episode.stage # - 'Discharged' Manager The custom manager for Episodes has the following methods: Episode.objects.serialised() Return a set of serialised episodes. Episode.objects.serialised(User, [episode, ...], historic_tags=False) Arguments: user The User for whom we want to serialise this episode episodes An iterable of Episode instances Keywords: historic_tags A boolean to indicate whether the user desires historic or just current tags to be serialised Episode.objects.search As a useful utility, the episode manager has a search method that will search on first name, last name and/or hospital number, under the hood it uses Patient search opal.core.api.EpisodeViewSet Gives you an api for create/update/list/retrieve apis for episodes. Its recommended that you use opal.core.patient_lists rather than the list api, as this gives you more flexibility. The Create api accepts { demographics: {{ a serialised demographics model }}, location: {{ a serialised location model }}. tagging: {{ a dictionary of tag names to True }} }","title":"The Episode model"},{"location":"reference/episode/#opalmodelsepisode","text":"The opal.models.Episode class represents an episode of care for a patient. This can be either an inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic, or any other arbitrarily defined period of care.","title":"opal.models.Episode"},{"location":"reference/episode/#fields","text":"","title":"Fields"},{"location":"reference/episode/#episodecategory","text":"The category of this episode - e.g. inpatient, outpatient et cetera. This defaults to whatever is set on your application's subclass of opal.core.application.OpalApplication - which itself defaults to 'inpatient'.","title":"Episode.category"},{"location":"reference/episode/#episodepatient","text":"A foreign key relationship to the patient for whom this episode concerns.","title":"Episode.patient"},{"location":"reference/episode/#episodeactive","text":"A boolean to provide a quick lookup for whether this is an active or closed episode.","title":"Episode.active"},{"location":"reference/episode/#episodestart","text":"This should be the start of the episode. If this is an inpatient episode, the date of admission.","title":"Episode.start"},{"location":"reference/episode/#episodeend","text":"This should be the end of the episode. If this is an inpatient episode, the date of discharge.","title":"Episode.end"},{"location":"reference/episode/#episodeconsistency_token","text":"A (automatically generated) hash of the above fields. This is used for detecting concurrent edits.","title":"Episode.consistency_token"},{"location":"reference/episode/#methods","text":"The Episode model has the following methods:","title":"Methods"},{"location":"reference/episode/#episodeget_absolute_url","text":"Return the URL for this Episode","title":"Episode.get_absolute_url()"},{"location":"reference/episode/#episodeto_dictuser","text":"Return a dictionary of field value pairs for this episode episode.to_dict(user) Arguments: user The User for whom we want to serialise this episode Keywords: shallow Boolean to indicate whether we want just this episode, or also a sorted set of previous and subsequent episodes","title":"Episode.to_dict(user)"},{"location":"reference/episode/#episodeget_tag_namesuser","text":"Arguments: user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.get_tag_names(user) # ['mine', 'infectioncontrol']","title":"Episode.get_tag_names(user)"},{"location":"reference/episode/#episodeset_tag_namestag_names-user","text":"Arguments: tag_names The list of tags that we want to be active for this Episode. user The user for whom we want the tag names. Set tags for this Episode. episode.set_tag_names(['mine', 'infectioncontrol'], user)","title":"Episode.set_tag_names(tag_names, user)"},{"location":"reference/episode/#episodeset_tag_names_from_tagging_dicttagging_dict-user","text":"Arguments: tagging_dict The dictionary of {tag_name: boolean} tags to set user The user for whom we want the tag names. Set tags for this Episode. episode.set_tag_names_from_tagging_dict({'inpatient': True}, user)","title":"Episode.set_tag_names_from_tagging_dict(tagging_dict, user)"},{"location":"reference/episode/#episodeset_stagestage-user-data","text":"Setter function for episode stage. Will validate that the stage given is valid for the current EpisodeCategory and raise ValueError if it is invalid. episode.set_stage('Discharged', user, {}) episode.stage # - 'Discharged'","title":"Episode.set_stage(stage, user, data)"},{"location":"reference/episode/#manager","text":"The custom manager for Episodes has the following methods:","title":"Manager"},{"location":"reference/episode/#episodeobjectsserialised","text":"Return a set of serialised episodes. Episode.objects.serialised(User, [episode, ...], historic_tags=False) Arguments: user The User for whom we want to serialise this episode episodes An iterable of Episode instances Keywords: historic_tags A boolean to indicate whether the user desires historic or just current tags to be serialised","title":"Episode.objects.serialised()"},{"location":"reference/episode/#episodeobjectssearch","text":"As a useful utility, the episode manager has a search method that will search on first name, last name and/or hospital number, under the hood it uses Patient search","title":"Episode.objects.search"},{"location":"reference/episode/#opalcoreapiepisodeviewset","text":"Gives you an api for create/update/list/retrieve apis for episodes. Its recommended that you use opal.core.patient_lists rather than the list api, as this gives you more flexibility. The Create api accepts { demographics: {{ a serialised demographics model }}, location: {{ a serialised location model }}. tagging: {{ a dictionary of tag names to True }} }","title":"opal.core.api.EpisodeViewSet"},{"location":"reference/episode_categories/","text":"opal.core.episodes EpisodeCategory Opal Episodes have an associated category. These categories are implemented as subclasses of opal.core.episodes.EpisodeCategory . This class is an Opal DiscoverableFeature and thus inherits all of the core Discoverable API. The category of any episode can be accessed as the .category property of any Episode instance. An episode category must be initialized with an instance of an episode. from opal.core.episodes import InpatientEpisode category = InpatientEpisode(episode) Properties EpisodeCategory.detail_template This is the template used within the Patient Detail View to display information about episodes of this category. EpisodeCategory.stages A list of strings that are valid values for Episode.stage for this category. Classmethods EpisodeCategory.episode_visible_to(episode, user) Predidcate function to determine whether an episode of this category is visible to a particular user. The default implementation will return True unless UserProfile.restricted_only is set to True. (In which case this user should not see any elements which are visible 'by default' for this application.) InpatientEpisode.episode_visible_to(episode, user) # - True Methods EpisodeCategory.get_stages() Returns a list of stages for this category as strings. InpatientEpisode(episode).get_stages() # - ['Inpatient', 'Followup', 'Discharged'] EpisodeCategory.has_stage(stage) Predicate function to determine whether a string is a valid stage for this category. InpatientEpisode(episode).has_stage('Inpatient') # - True EpisodeCategory.is_active() Predicate function to determine whether this episode is active. The default implementation looks to see whether an end date has been set on the episode. InpatientEpisode(Episode()).is_active() # - True EpisodeCategory.set_stage(stage, user, data) Sets the stage on the episode. It gets passed the user, and the rest of the data that's been used to update the episode. InpatientEpisode(episode).set_stage('Discharged', user, data_dict) # - True InpatientEpisode This is the default EpisodeCategory imlpementation - applications started with Opal's scaffolding scripts will use this as the OpalApplication.default_episode_category . It sets the detail template to detail/inpatient.html","title":"Episode Categories"},{"location":"reference/episode_categories/#opalcoreepisodes","text":"","title":"opal.core.episodes"},{"location":"reference/episode_categories/#episodecategory","text":"Opal Episodes have an associated category. These categories are implemented as subclasses of opal.core.episodes.EpisodeCategory . This class is an Opal DiscoverableFeature and thus inherits all of the core Discoverable API. The category of any episode can be accessed as the .category property of any Episode instance. An episode category must be initialized with an instance of an episode. from opal.core.episodes import InpatientEpisode category = InpatientEpisode(episode) Properties","title":"EpisodeCategory"},{"location":"reference/episode_categories/#episodecategorydetail_template","text":"This is the template used within the Patient Detail View to display information about episodes of this category.","title":"EpisodeCategory.detail_template"},{"location":"reference/episode_categories/#episodecategorystages","text":"A list of strings that are valid values for Episode.stage for this category. Classmethods","title":"EpisodeCategory.stages"},{"location":"reference/episode_categories/#episodecategoryepisode_visible_toepisode-user","text":"Predidcate function to determine whether an episode of this category is visible to a particular user. The default implementation will return True unless UserProfile.restricted_only is set to True. (In which case this user should not see any elements which are visible 'by default' for this application.) InpatientEpisode.episode_visible_to(episode, user) # - True Methods","title":"EpisodeCategory.episode_visible_to(episode, user)"},{"location":"reference/episode_categories/#episodecategoryget_stages","text":"Returns a list of stages for this category as strings. InpatientEpisode(episode).get_stages() # - ['Inpatient', 'Followup', 'Discharged']","title":"EpisodeCategory.get_stages()"},{"location":"reference/episode_categories/#episodecategoryhas_stagestage","text":"Predicate function to determine whether a string is a valid stage for this category. InpatientEpisode(episode).has_stage('Inpatient') # - True","title":"EpisodeCategory.has_stage(stage)"},{"location":"reference/episode_categories/#episodecategoryis_active","text":"Predicate function to determine whether this episode is active. The default implementation looks to see whether an end date has been set on the episode. InpatientEpisode(Episode()).is_active() # - True","title":"EpisodeCategory.is_active()"},{"location":"reference/episode_categories/#episodecategoryset_stagestage-user-data","text":"Sets the stage on the episode. It gets passed the user, and the rest of the data that's been used to update the episode. InpatientEpisode(episode).set_stage('Discharged', user, data_dict) # - True","title":"EpisodeCategory.set_stage(stage, user, data)"},{"location":"reference/episode_categories/#inpatientepisode","text":"This is the default EpisodeCategory imlpementation - applications started with Opal's scaffolding scripts will use this as the OpalApplication.default_episode_category . It sets the detail template to detail/inpatient.html","title":"InpatientEpisode"},{"location":"reference/form_templatetags/","text":"Form Helpers Opal comes with a selection of templatetags that can help you with the repetitive task of generating Bootstrap and Opal compatible markup for your forms. To use these in your HTML templates you need to load them: !-- myapp/templates/forms/mytemplate.html -- {% load forms %} ... {% checkbox ... %} Generates a checkbox Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed disabled If this exists, we use this as the expression for the ng-disabled directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' {% datepicker ... %} Generates a datepicker Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive required Label to show when we're required mindate Angular Javascript expression to return the minimum possible date element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' user_options If set to True this will add the default options of today , ie the current date, or yesterday , ie t-1. {% timepicker ... %} Generates a time picker widget Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe the date field (defaults to 'Date') model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' {% datetimepicker ... %} Generates a date time fields, a date field on one line and a time field on another Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields date_label The Label with which to describe the date field (defaults to 'Date') time_label The Label with which to describe the date field (defaults to 'Time') model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html datetime picker element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' {% input ... %} The input template tag generates you a form input that will play nicely with Opal's styling. Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the lookuplist values required Label to show when we're required enter expression to evaluate if the user presses return when in this input maxlength maximum number of characters for this input. Will render the form invalid and display help text if exceeded. element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element element_type If this exists it sets the input 'type' on the html tag. For numeric fields set by the 'field' parameter this will default to number. Otherwise it will just default to 'text'. style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' Inputs with units We also often want to display the unit of a particular field to help our users - consistent styling for this is available by using the unit argument e.g. {% input label= Weight model= editing.weight unit= kg %} {% radio ... %} Generates an inline radio input. Options are rendered in rows with multiple options on each row. Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' {% radio_vertical ... %} Generates a vertical radio input. Options are rendered one option per row. Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' {% select ... %} Generates an inline select input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values other A boolean parameter that if true, provides a free text option when 'Other' is selected help a template to use as the contents of a help popover static an Angular expression that will swap the display to be a static input if it evaluates to true element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element* style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' {% textarea ... %} Generates an inline textarea input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' rows The number of rows in the textarea. Used to fill the html textarea row attribute. Defaults to 5. Inference from subrecord fields A very common pattern is to render form fields that relate to fields of Subrecords . Template tags will use this to infer useful information. The display name will be set to the verbose_name and the the ng-model will be inferred. If its required, it will set as a required field. If its a CharField with a max length it will set a validation rule accordingly. If the field is a free text or foreign key we will infer the lookup list. Alternatively if the field has choices attached to it we will infer the choices into the field. {% input field= Allergies.drug %} Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively. All inferences can be overridden by declarations in the template tag. For Example {% input field= Allergies.drug label= Something else %} Will render the input with a different label. {% static ... %} Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles). Takes one positional argument, a string representing the subrecord field path. {% static \"Demographics.name\" %} !-- Renders as -- div class=\"form-group\" label class=\"control-label col-sm-3\" Name /label p class=\"form-control-static col-sm-8\" [[ editing.demographics.name ]] /p /div {% icon \"icon-name\" %} Renders a Bootstrap style Icon tag. If the icon starts with fa or glyphicon then we will insert the preceding fa . {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i {% icon \"cusom-icon\"} i class=\"custom-icon\" /i","title":"Form helpers"},{"location":"reference/form_templatetags/#form-helpers","text":"Opal comes with a selection of templatetags that can help you with the repetitive task of generating Bootstrap and Opal compatible markup for your forms. To use these in your HTML templates you need to load them: !-- myapp/templates/forms/mytemplate.html -- {% load forms %} ...","title":"Form Helpers"},{"location":"reference/form_templatetags/#checkbox","text":"Generates a checkbox Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed disabled If this exists, we use this as the expression for the ng-disabled directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal'","title":"{% checkbox ... %}"},{"location":"reference/form_templatetags/#datepicker","text":"Generates a datepicker Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive required Label to show when we're required mindate Angular Javascript expression to return the minimum possible date element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' user_options If set to True this will add the default options of today , ie the current date, or yesterday , ie t-1.","title":"{% datepicker ... %}"},{"location":"reference/form_templatetags/#timepicker","text":"Generates a time picker widget Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe the date field (defaults to 'Date') model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal'","title":"{% timepicker ... %}"},{"location":"reference/form_templatetags/#datetimepicker","text":"Generates a date time fields, a date field on one line and a time field on another Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields date_label The Label with which to describe the date field (defaults to 'Date') time_label The Label with which to describe the date field (defaults to 'Time') model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html datetime picker element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal'","title":"{% datetimepicker ... %}"},{"location":"reference/form_templatetags/#input","text":"The input template tag generates you a form input that will play nicely with Opal's styling. Keywords: field a string of the models api name '.' field which infers attributes for the model, for more information see Inference from subrecord fields label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the lookuplist values required Label to show when we're required enter expression to evaluate if the user presses return when in this input maxlength maximum number of characters for this input. Will render the form invalid and display help text if exceeded. element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element element_type If this exists it sets the input 'type' on the html tag. For numeric fields set by the 'field' parameter this will default to number. Otherwise it will just default to 'text'. style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal'","title":"{% input ... %}"},{"location":"reference/form_templatetags/#inputs-with-units","text":"We also often want to display the unit of a particular field to help our users - consistent styling for this is available by using the unit argument e.g. {% input label= Weight model= editing.weight unit= kg %}","title":"Inputs with units"},{"location":"reference/form_templatetags/#radio","text":"Generates an inline radio input. Options are rendered in rows with multiple options on each row. Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal'","title":"{% radio ... %}"},{"location":"reference/form_templatetags/#radio_vertical","text":"Generates a vertical radio input. Options are rendered one option per row. Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal'","title":"{% radio_vertical ... %}"},{"location":"reference/form_templatetags/#select","text":"Generates an inline select input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values other A boolean parameter that if true, provides a free text option when 'Other' is selected help a template to use as the contents of a help popover static an Angular expression that will swap the display to be a static input if it evaluates to true element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element* style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal'","title":"{% select ... %}"},{"location":"reference/form_templatetags/#textarea","text":"Generates an inline textarea input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) change A javascript function that fires if the field has changed show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive element_name If this exists this is an Angular expression that is set to the 'name' attribute of the html element style The form style to render this widget with. Possible values are ['horizontal', 'vertical'] . Defaults to 'horizontal' rows The number of rows in the textarea. Used to fill the html textarea row attribute. Defaults to 5.","title":"{% textarea ... %}"},{"location":"reference/form_templatetags/#inference-from-subrecord-fields","text":"A very common pattern is to render form fields that relate to fields of Subrecords . Template tags will use this to infer useful information. The display name will be set to the verbose_name and the the ng-model will be inferred. If its required, it will set as a required field. If its a CharField with a max length it will set a validation rule accordingly. If the field is a free text or foreign key we will infer the lookup list. Alternatively if the field has choices attached to it we will infer the choices into the field. {% input field= Allergies.drug %} Note unlike the traditional choices implementation only the last value of the choices is used and saved to the database Colours = ( ('P', 'Purple'), ('R', 'Red'), ) What is displayed to the user and saved to the database is 'Purple' or 'Red' respectively. All inferences can be overridden by declarations in the template tag. For Example {% input field= Allergies.drug label= Something else %} Will render the input with a different label.","title":"Inference from subrecord fields"},{"location":"reference/form_templatetags/#static","text":"Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles). Takes one positional argument, a string representing the subrecord field path. {% static \"Demographics.name\" %} !-- Renders as -- div class=\"form-group\" label class=\"control-label col-sm-3\" Name /label p class=\"form-control-static col-sm-8\" [[ editing.demographics.name ]] /p /div","title":"{% static ... %}"},{"location":"reference/form_templatetags/#icon-icon-name","text":"Renders a Bootstrap style Icon tag. If the icon starts with fa or glyphicon then we will insert the preceding fa . {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i {% icon \"cusom-icon\"} i class=\"custom-icon\" /i","title":"{% icon \"icon-name\" %}"},{"location":"reference/loggers/","text":"opal.core.log.ConfidentialEmailer A confidential emailer that does not send the stack trace but provides the file name and error line that the issue happened. Along with the host name and user who had the issue.","title":"Log"},{"location":"reference/loggers/#opalcorelogconfidentialemailer","text":"A confidential emailer that does not send the stack trace but provides the file name and error line that the issue happened. Along with the host name and user who had the issue.","title":"opal.core.log.ConfidentialEmailer"},{"location":"reference/management_commands/","text":"Opal Management Commands Opal ships with a number of Django management commands which can be invoked with python manage.py command . create_random_data Creates patients with randomised data. Arguments : --number - The number of patients to create. Defaults to 100. python manage.py create_random_data --number 3000 create_singletons Creates any subrecord singletons which are missing. This is useful when creating a new singleton subrecord to backfill existing patients or episodes. Will not create anything if singletons exist, so safe to be run as part of e.g. a deployment script. python manage.py create_singletons delete_all_lookuplists Deletes all instances of lookuplist and synonym entries. python manage.py delete_all_lookuplists detect_duplicates Examines patients in the system and looks for possible duplicates. Prints a report of patients with matching names, dates of birth or hospital numbers. python manage.py detect_duplicates dump_lookup_lists Arguments : --many-files - write lookuplists to separate files instead of printing them to stdout. Prints current lookuplist and synonym values as JSON to stdout. Suitable to be used as the input to load_lookup_lists python manage.py dump_lookup_lists load_lookup_lists Load lookuplists and synonym values. Arguments : --file - Load one specific file only. By default this command will look in ./yourapp/data/lookuplists.json as well as in ./yourapp/data/ for any files with a name matching the API name of a lookuplist (e.g. ./yourapp/data/conditions.json ) python manage.py load_lookup_lists serve addrport Run the development server. By default this will start a web server on localhost:8000 . Users may specify either a port or an addr port pair to change this. opal serve # server on localhost:8000 opal serve 7798 # server on localhost:7798 opal serve 0.0.0.0:8080 # server on 0.0.0.0:8080 scaffold appname Use with new record models. Creates and runs automatic migrations, creates display and form (modal) templates. Running with --dry-run will run makemigrations with --dry-run and print display and form templates that would be generated.","title":"Management commands"},{"location":"reference/management_commands/#opal-management-commands","text":"Opal ships with a number of Django management commands which can be invoked with python manage.py command .","title":"Opal Management Commands"},{"location":"reference/management_commands/#create_random_data","text":"Creates patients with randomised data. Arguments : --number - The number of patients to create. Defaults to 100. python manage.py create_random_data --number 3000","title":"create_random_data"},{"location":"reference/management_commands/#create_singletons","text":"Creates any subrecord singletons which are missing. This is useful when creating a new singleton subrecord to backfill existing patients or episodes. Will not create anything if singletons exist, so safe to be run as part of e.g. a deployment script. python manage.py create_singletons","title":"create_singletons"},{"location":"reference/management_commands/#delete_all_lookuplists","text":"Deletes all instances of lookuplist and synonym entries. python manage.py delete_all_lookuplists","title":"delete_all_lookuplists"},{"location":"reference/management_commands/#detect_duplicates","text":"Examines patients in the system and looks for possible duplicates. Prints a report of patients with matching names, dates of birth or hospital numbers. python manage.py detect_duplicates","title":"detect_duplicates"},{"location":"reference/management_commands/#dump_lookup_lists","text":"Arguments : --many-files - write lookuplists to separate files instead of printing them to stdout. Prints current lookuplist and synonym values as JSON to stdout. Suitable to be used as the input to load_lookup_lists python manage.py dump_lookup_lists","title":"dump_lookup_lists"},{"location":"reference/management_commands/#load_lookup_lists","text":"Load lookuplists and synonym values. Arguments : --file - Load one specific file only. By default this command will look in ./yourapp/data/lookuplists.json as well as in ./yourapp/data/ for any files with a name matching the API name of a lookuplist (e.g. ./yourapp/data/conditions.json ) python manage.py load_lookup_lists","title":"load_lookup_lists"},{"location":"reference/management_commands/#serve-addrport","text":"Run the development server. By default this will start a web server on localhost:8000 . Users may specify either a port or an addr port pair to change this. opal serve # server on localhost:8000 opal serve 7798 # server on localhost:7798 opal serve 0.0.0.0:8080 # server on 0.0.0.0:8080","title":"serve &lt;addrport&gt;"},{"location":"reference/management_commands/#scaffold-appname","text":"Use with new record models. Creates and runs automatic migrations, creates display and form (modal) templates. Running with --dry-run will run makemigrations with --dry-run and print display and form templates that would be generated.","title":"scaffold &lt;appname&gt;"},{"location":"reference/menus_templatetags/","text":"The Menus templatetag library The menu templatetag takes care of rendering an Opal application menu. {% load menus %} {% menu %}","title":"Menu Template tag"},{"location":"reference/menus_templatetags/#the-menus-templatetag-library","text":"The menu templatetag takes care of rendering an Opal application menu. {% load menus %} {% menu %}","title":"The Menus templatetag library"},{"location":"reference/mixins/","text":"Opal mixins SerialisableFields Provides the fields that are on the model for example if we have an allergy model with a field drug it might serialise like below Allergy._get_fieldnames_to_serialize() - [\"id\", \"drug\"] build_schema_for_field_name Takes in a field name and returns a json description of the field. get_human_readable_type Provides a human readable description of the field name for example Date Time for a DateTime Field. get_lookup_list_api_name Provides the api name of the lookup list related to the field if it exists ToDictMixin Provides a method that serialises a model to a dictionary for example if we have an allergy model with a field drug it might serialise like below allergy.to_dict() - {\"id\": 1, \"drug\": \"penicillin\"} UpdateFromDict Provides a method that updates a model based on a dictionary of fields, for example For example on a new allergy allergy.update_from_dict({\"drug\": \"penicillin\"}) will update the allergy to have the drug penicillin.","title":"Mixins"},{"location":"reference/mixins/#opal-mixins","text":"","title":"Opal mixins"},{"location":"reference/mixins/#serialisablefields","text":"Provides the fields that are on the model for example if we have an allergy model with a field drug it might serialise like below Allergy._get_fieldnames_to_serialize() - [\"id\", \"drug\"]","title":"SerialisableFields"},{"location":"reference/mixins/#build_schema_for_field_name","text":"Takes in a field name and returns a json description of the field.","title":"build_schema_for_field_name"},{"location":"reference/mixins/#get_human_readable_type","text":"Provides a human readable description of the field name for example Date Time for a DateTime Field.","title":"get_human_readable_type"},{"location":"reference/mixins/#get_lookup_list_api_name","text":"Provides the api name of the lookup list related to the field if it exists","title":"get_lookup_list_api_name"},{"location":"reference/mixins/#todictmixin","text":"Provides a method that serialises a model to a dictionary for example if we have an allergy model with a field drug it might serialise like below allergy.to_dict() - {\"id\": 1, \"drug\": \"penicillin\"}","title":"ToDictMixin"},{"location":"reference/mixins/#updatefromdict","text":"Provides a method that updates a model based on a dictionary of fields, for example For example on a new allergy allergy.update_from_dict({\"drug\": \"penicillin\"}) will update the allergy to have the drug penicillin.","title":"UpdateFromDict"},{"location":"reference/opal_application/","text":"opal.core.application Utility functions get_app Returns the application class for the currently active application. get_all_components Returns an iterator of all the of the plugins and the current application OpalApplication The base class for your main application entry point is opal.core.application.OpalApplication. You must subclass this in order for Opal to discover your application. If you started your Opal project via $ opal startproject yourproject then this will have been generated for you, and located in yourproject/yourproject/__init__.py Properties Properties available on an OpalApplication: OpalApplication.actions OpalApplication.default_episode_category The default category is 'Inpatient', but can be overridden in the OpalApplication subclass for your implementation. OpalApplication.angular_module_deps When you initialise an angular application you need to register dependencies. This allows you to add to the dependencies of the default opal application. OpalApplication.javascripts A list of javascripts that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . class MyApplication(OpalApplication): javascripts = ['js/one.js'] OpalApplication.menuitems A list of items to add to the top level menu OpalApplication.styles A list of stylesheets that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . These styles are included after the default Opal styles. class MyApplication(OpalApplication): styles = ['css/app.css'] Classmethods Classmethod API for OpalApplication instances: OpalApplication.get_core_javascripts(namespace) Return a list of the core javascript files specified within a given namespace. These will be relative paths ready for staticfiles. application.get_core_javascripts('opal.utils') # - ['js/opal/utils.js', ...] OpalApplication.get_javascripts() Return a list of the application's javascripts as paths to them ready for staticfiles. Defaults to returning the OpalApplication.javascripts property. application.get_javascripts() # - ['js/one.js', 'js/two.js', ...] OpalApplication.directory Returns the file system location of the module. OpalApplication.get_menu_items(user=None) Hook to customise the visibility of menu items to e.g. restrict some based on the current user. OpalApplication.get_styles() Return a list of the application's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalApplication.styles . application.get_styles() # - ['css/app.css', ...]","title":"OpalApplication"},{"location":"reference/opal_application/#opalcoreapplication","text":"","title":"opal.core.application"},{"location":"reference/opal_application/#utility-functions","text":"","title":"Utility functions"},{"location":"reference/opal_application/#get_app","text":"Returns the application class for the currently active application.","title":"get_app"},{"location":"reference/opal_application/#get_all_components","text":"Returns an iterator of all the of the plugins and the current application","title":"get_all_components"},{"location":"reference/opal_application/#opalapplication","text":"The base class for your main application entry point is opal.core.application.OpalApplication. You must subclass this in order for Opal to discover your application. If you started your Opal project via $ opal startproject yourproject then this will have been generated for you, and located in yourproject/yourproject/__init__.py","title":"OpalApplication"},{"location":"reference/opal_application/#properties","text":"Properties available on an OpalApplication:","title":"Properties"},{"location":"reference/opal_application/#opalapplicationactions","text":"","title":"OpalApplication.actions"},{"location":"reference/opal_application/#opalapplicationdefault_episode_category","text":"The default category is 'Inpatient', but can be overridden in the OpalApplication subclass for your implementation.","title":"OpalApplication.default_episode_category"},{"location":"reference/opal_application/#opalapplicationangular_module_deps","text":"When you initialise an angular application you need to register dependencies. This allows you to add to the dependencies of the default opal application.","title":"OpalApplication.angular_module_deps"},{"location":"reference/opal_application/#opalapplicationjavascripts","text":"A list of javascripts that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . class MyApplication(OpalApplication): javascripts = ['js/one.js']","title":"OpalApplication.javascripts"},{"location":"reference/opal_application/#opalapplicationmenuitems","text":"A list of items to add to the top level menu","title":"OpalApplication.menuitems"},{"location":"reference/opal_application/#opalapplicationstyles","text":"A list of stylesheets that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . These styles are included after the default Opal styles. class MyApplication(OpalApplication): styles = ['css/app.css']","title":"OpalApplication.styles"},{"location":"reference/opal_application/#classmethods","text":"Classmethod API for OpalApplication instances:","title":"Classmethods"},{"location":"reference/opal_application/#opalapplicationget_core_javascriptsnamespace","text":"Return a list of the core javascript files specified within a given namespace. These will be relative paths ready for staticfiles. application.get_core_javascripts('opal.utils') # - ['js/opal/utils.js', ...]","title":"OpalApplication.get_core_javascripts(namespace)"},{"location":"reference/opal_application/#opalapplicationget_javascripts","text":"Return a list of the application's javascripts as paths to them ready for staticfiles. Defaults to returning the OpalApplication.javascripts property. application.get_javascripts() # - ['js/one.js', 'js/two.js', ...]","title":"OpalApplication.get_javascripts()"},{"location":"reference/opal_application/#opalapplicationdirectory","text":"Returns the file system location of the module.","title":"OpalApplication.directory"},{"location":"reference/opal_application/#opalapplicationget_menu_itemsusernone","text":"Hook to customise the visibility of menu items to e.g. restrict some based on the current user.","title":"OpalApplication.get_menu_items(user=None)"},{"location":"reference/opal_application/#opalapplicationget_styles","text":"Return a list of the application's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalApplication.styles . application.get_styles() # - ['css/app.css', ...]","title":"OpalApplication.get_styles()"},{"location":"reference/panels_templatetags/","text":"Panel helpers Opal comes with a selection of templatetags for rendering Opal panels for a given subrecord. These panels also allow the user to see instances of the model against the current value of episode in Angular $scope . The user can also create new instances of the given model, as well as editing any existing ones. {% record_panel ... %} Render a panel for a given record that will allow the user to view, create, update and delete instances. The record panel template expects the relevant Angular $scope to have newNamedItem(name, index) , editNamedItem(name, index) methods implemented. Default implementations of these are available from the EpisodeDetailMixin . {% load panels %} {% record_panel Diagnosis %} Keywords: model : The model we want to render our panel for title : The display title for this panel detail_template : The display template to use. Defaults to Subrecord.get_detail_template() editable : Whether this panel should allow editing. Defaults to True. angular_filter : An Angular expression that will be evaluated to decide whether to show each item noentries : A string to render if there are no instances of model for the current episode only_display_if_exists : Boolean defaulting to False. If true, the panel will simply not render if there are no instances of model {% record_timeline ... %} Similar to record_panel , record_timeline renders a panel for a given record as a timeline - particularly useful for subrecord types where the date is a key field. {% load panels %} {% record_panel Diagnosis 'when' %} Arguments: model : The model we want to render our panel for whenfield : String of the field that we're using to sort by. {% aligned_pair ... %} Render a key value pair in their own Bootstrap row using columns of width md-4 each. Particularly useful for occasions when we have multiple entries that need to be presented one after another but the data is not naturally tabular. {% load panels %} {% aligned_pair model= episode.start_date | displayDate label= Start Date %} {% aligned_pair model= 22 label= Next Data Point %} Arguments: label : The left hand item, to be rendered bold. model : The right hand item, to be rendered as an angular expression","title":"Panel Template tags"},{"location":"reference/panels_templatetags/#panel-helpers","text":"Opal comes with a selection of templatetags for rendering Opal panels for a given subrecord. These panels also allow the user to see instances of the model against the current value of episode in Angular $scope . The user can also create new instances of the given model, as well as editing any existing ones.","title":"Panel helpers"},{"location":"reference/panels_templatetags/#record_panel","text":"Render a panel for a given record that will allow the user to view, create, update and delete instances. The record panel template expects the relevant Angular $scope to have newNamedItem(name, index) , editNamedItem(name, index) methods implemented. Default implementations of these are available from the EpisodeDetailMixin . {% load panels %} {% record_panel Diagnosis %} Keywords: model : The model we want to render our panel for title : The display title for this panel detail_template : The display template to use. Defaults to Subrecord.get_detail_template() editable : Whether this panel should allow editing. Defaults to True. angular_filter : An Angular expression that will be evaluated to decide whether to show each item noentries : A string to render if there are no instances of model for the current episode only_display_if_exists : Boolean defaulting to False. If true, the panel will simply not render if there are no instances of model","title":"{% record_panel ... %}"},{"location":"reference/panels_templatetags/#record_timeline","text":"Similar to record_panel , record_timeline renders a panel for a given record as a timeline - particularly useful for subrecord types where the date is a key field. {% load panels %} {% record_panel Diagnosis 'when' %} Arguments: model : The model we want to render our panel for whenfield : String of the field that we're using to sort by.","title":"{% record_timeline ... %}"},{"location":"reference/panels_templatetags/#aligned_pair","text":"Render a key value pair in their own Bootstrap row using columns of width md-4 each. Particularly useful for occasions when we have multiple entries that need to be presented one after another but the data is not naturally tabular. {% load panels %} {% aligned_pair model= episode.start_date | displayDate label= Start Date %} {% aligned_pair model= 22 label= Next Data Point %} Arguments: label : The left hand item, to be rendered bold. model : The right hand item, to be rendered as an angular expression","title":"{% aligned_pair ... %}"},{"location":"reference/pathways/","text":"Reference docs: opal.core.pathway Pathway Pathway is the base class for most complex forms in Opal applications. Attributes Pathway.display_name The human readable display name for this pathway. Will be used in the base template for full page pathways. Pathway.slug The slug to use in the URL for accessing an individual pathway, and the string that can be passed to Pathway.get() that will return it. Pathway.steps The steps that make up this pathway. A tuple of either opal.models.Subrecord or pathway.Step subclasses. Pathway.pathway_service The Service that is used to instantiate the pathway. This should inherit from the Pathway js service. Pathway.pathway_insert The name of the class that you're replaceing with the pathway template. You probably shouldn't have to change this. Pathway.template The name of the pathway template, it must include a div/span with the class .to_append which will be replaced by the wrapped step templates. Pathway.modal_template If set, this template will be used if your pathway is opened in a modal. If its not set the template attribute will be used. Class Methods Pathway.as_menuitem(href=None, activepattern=None, icon=None, display=None, index=None) Return an instance of opal.core.menus.MenuItem that will direct the user to this pathway. Pathway.get_slug() Returns a string which should be used as the slug for this Pathway. MyPathwy.get_slug() mypathway Pathway.get_absolute_url() Returns a string which is the absolute URL of this Pathway. MyPathway.get_absolute_url() /pathway/#/mypathway/ Pathway.get_icon() Returns a string which is the icon for this pathway. Defaults to None. MyPathway.get_icon() fa-wave Pathway.get_display_name() Returns a string which is the display name for this pathway. Defaults to None MyPathway.get_display_name() The Form Methods Pathway.redirect_url(self, patient, episde) Returns a string that we should redirect to on success. Defaults to an episode detail screen Pathway.save(user=None, episode=None, patient=None) Saves a pathway, it removes items that haven't changed and then saves with the Patient.bulk_update method WizardPathway Inherits from opal.core.pathway.Pathway , this displays one step per page, with next and back buttons to navigate through the form. PagePathway Inherits from opal.core.pathway.Pathway , this displays all steps as one long form. Step Steps are a single section within a form, and can be instances of either opal.models.Subrecord or pathway.Step subclasses. You can use both types of Step in a given Pathway. More detail on Steps is given in the Guides section on Pathways HelpTextStep A Step subclass with help text to the side of the form. As arguments these takes either help_text or help_text_template . help_text will be displayed in a side bar next to the step. help_text_template will completely replace the normal side bar template with the template that you pass in. RedirectsToPatientMixin After saving, redirect the browser to the patient detail page for the relevant patient.","title":"Pathway"},{"location":"reference/pathways/#reference-docs-opalcorepathway","text":"","title":"Reference docs: opal.core.pathway"},{"location":"reference/pathways/#pathway","text":"Pathway is the base class for most complex forms in Opal applications.","title":"Pathway"},{"location":"reference/pathways/#attributes","text":"","title":"Attributes"},{"location":"reference/pathways/#pathwaydisplay_name","text":"The human readable display name for this pathway. Will be used in the base template for full page pathways.","title":"Pathway.display_name"},{"location":"reference/pathways/#pathwayslug","text":"The slug to use in the URL for accessing an individual pathway, and the string that can be passed to Pathway.get() that will return it.","title":"Pathway.slug"},{"location":"reference/pathways/#pathwaysteps","text":"The steps that make up this pathway. A tuple of either opal.models.Subrecord or pathway.Step subclasses.","title":"Pathway.steps"},{"location":"reference/pathways/#pathwaypathway_service","text":"The Service that is used to instantiate the pathway. This should inherit from the Pathway js service.","title":"Pathway.pathway_service"},{"location":"reference/pathways/#pathwaypathway_insert","text":"The name of the class that you're replaceing with the pathway template. You probably shouldn't have to change this.","title":"Pathway.pathway_insert"},{"location":"reference/pathways/#pathwaytemplate","text":"The name of the pathway template, it must include a div/span with the class .to_append which will be replaced by the wrapped step templates.","title":"Pathway.template"},{"location":"reference/pathways/#pathwaymodal_template","text":"If set, this template will be used if your pathway is opened in a modal. If its not set the template attribute will be used.","title":"Pathway.modal_template"},{"location":"reference/pathways/#class-methods","text":"","title":"Class Methods"},{"location":"reference/pathways/#pathwayas_menuitemhrefnone-activepatternnone-iconnone-displaynone-indexnone","text":"Return an instance of opal.core.menus.MenuItem that will direct the user to this pathway.","title":"Pathway.as_menuitem(href=None, activepattern=None, icon=None, display=None, index=None)"},{"location":"reference/pathways/#pathwayget_slug","text":"Returns a string which should be used as the slug for this Pathway. MyPathwy.get_slug() mypathway","title":"Pathway.get_slug()"},{"location":"reference/pathways/#pathwayget_absolute_url","text":"Returns a string which is the absolute URL of this Pathway. MyPathway.get_absolute_url() /pathway/#/mypathway/","title":"Pathway.get_absolute_url()"},{"location":"reference/pathways/#pathwayget_icon","text":"Returns a string which is the icon for this pathway. Defaults to None. MyPathway.get_icon() fa-wave","title":"Pathway.get_icon()"},{"location":"reference/pathways/#pathwayget_display_name","text":"Returns a string which is the display name for this pathway. Defaults to None MyPathway.get_display_name() The Form","title":"Pathway.get_display_name()"},{"location":"reference/pathways/#methods","text":"","title":"Methods"},{"location":"reference/pathways/#pathwayredirect_urlself-patient-episde","text":"Returns a string that we should redirect to on success. Defaults to an episode detail screen","title":"Pathway.redirect_url(self, patient, episde)"},{"location":"reference/pathways/#pathwaysaveusernone-episodenone-patientnone","text":"Saves a pathway, it removes items that haven't changed and then saves with the Patient.bulk_update method","title":"Pathway.save(user=None, episode=None, patient=None)"},{"location":"reference/pathways/#wizardpathway","text":"Inherits from opal.core.pathway.Pathway , this displays one step per page, with next and back buttons to navigate through the form.","title":"WizardPathway"},{"location":"reference/pathways/#pagepathway","text":"Inherits from opal.core.pathway.Pathway , this displays all steps as one long form.","title":"PagePathway"},{"location":"reference/pathways/#step","text":"Steps are a single section within a form, and can be instances of either opal.models.Subrecord or pathway.Step subclasses. You can use both types of Step in a given Pathway. More detail on Steps is given in the Guides section on Pathways","title":"Step"},{"location":"reference/pathways/#helptextstep","text":"A Step subclass with help text to the side of the form. As arguments these takes either help_text or help_text_template . help_text will be displayed in a side bar next to the step. help_text_template will completely replace the normal side bar template with the template that you pass in.","title":"HelpTextStep"},{"location":"reference/pathways/#redirectstopatientmixin","text":"After saving, redirect the browser to the patient detail page for the relevant patient.","title":"RedirectsToPatientMixin"},{"location":"reference/patient/","text":"opal.models.Patient methods Patient.demographics() Returns the relevant Demographics instance for the patient. Patient.create_episode() Returns a new Episode for this patient. Patient.get_absolute_url() Return the URL for this patient to_dict Return the dictionary representation of this patient - suitable for serialization. patient.to_dict(user) bulk_update Create or update many subrecords in one go, from a serialised dictionary of data. Pass in a dictionary of subrecords you want to update, as well as an episode if one exists. This method will create all the subrecords and implicitly create a new episode if required. This API will execute all create/update operations as an atomic transaction. For example the following will create a patient: patient = Patient() patient.bulk_update( { \"demographics\": \"hospital_number\": \"1231212\", \"allergies\": [ {\"drug\": \"penicillin\"}, {\"drug\": \"aspirin\"}, ] }, user ) Manager The custom manager for Patient has the following methods: Patient.objects.search A useful utility the patient manager has a search method that will search on first name last name hospital number. Its splits the string input on space, so if you do \"12 Jane\", you will get all Patients who's name, surname or hospital number contains either 12 or Jane, in this example most probably people who's hospital number contains 12 and who's first name is Jane.","title":"The Patient model"},{"location":"reference/patient/#opalmodelspatient","text":"","title":"opal.models.Patient"},{"location":"reference/patient/#methods","text":"","title":"methods"},{"location":"reference/patient/#patientdemographics","text":"Returns the relevant Demographics instance for the patient.","title":"Patient.demographics()"},{"location":"reference/patient/#patientcreate_episode","text":"Returns a new Episode for this patient.","title":"Patient.create_episode()"},{"location":"reference/patient/#patientget_absolute_url","text":"Return the URL for this patient","title":"Patient.get_absolute_url()"},{"location":"reference/patient/#to_dict","text":"Return the dictionary representation of this patient - suitable for serialization. patient.to_dict(user)","title":"to_dict"},{"location":"reference/patient/#bulk_update","text":"Create or update many subrecords in one go, from a serialised dictionary of data. Pass in a dictionary of subrecords you want to update, as well as an episode if one exists. This method will create all the subrecords and implicitly create a new episode if required. This API will execute all create/update operations as an atomic transaction. For example the following will create a patient: patient = Patient() patient.bulk_update( { \"demographics\": \"hospital_number\": \"1231212\", \"allergies\": [ {\"drug\": \"penicillin\"}, {\"drug\": \"aspirin\"}, ] }, user )","title":"bulk_update"},{"location":"reference/patient/#manager","text":"The custom manager for Patient has the following methods:","title":"Manager"},{"location":"reference/patient/#patientobjectssearch","text":"A useful utility the patient manager has a search method that will search on first name last name hospital number. Its splits the string input on space, so if you do \"12 Jane\", you will get all Patients who's name, surname or hospital number contains either 12 or Jane, in this example most probably people who's hospital number contains 12 and who's first name is Jane.","title":"Patient.objects.search"},{"location":"reference/patient_list/","text":"opal.core.patient_lists The patient_lists module defines a number of classes for working with lists of patients. class opal.core.patient_lists.PatientList PatientList.allow_add_patient Whether we should show the add patient button. Defaults to True . PatientList.allow_edit_teams Whether we should allow the user to edit teams. Defaults to True . PatientList.comparator_service A custom comparator service to set sort order within a list. Defaults to None. Further information on Comparators can be found in the Opal Guides section. PatientList.direct_add Further information is available in the Guides section . PatientList.display_name How we want to refer to this list on screen to users. PatientList.order Passing an integer to PatientList.order will allow you to control the order of display of Patient Lists in dropdowns and other views. Further information is available in the Guides section . PatientList.queryset Further information is available in the Guides section . PatientList.schema Further information is available in the Guides section . PatientList.slug Further information is available in the Guides section . PatientList.template_name To override the default Patient List template opal/templates/patient_list/layouts/spreadsheet_list.html with a custom template specify the path of the custom template (relative to /myapp/templates/ ) with this property. # myapp/patient_lists.py class MyPatientList(PatientList): template_name = 'my_layout.html' Will look for a template at /myapp/templates/my_layout.html . Opal includes three patient lists out of the box: spreadsheet_list.html , card_list.html , and table_list.html . See Built-in PatientList Templates below for further details. All these patient list layout templates use Django {% extends %} syntax to extend their base templates respectively. Each of these base templates contains Django {% block %} s, so you can override selected parts of the base template by creating a new file in patient_lists/layouts/ called, for example spreadsheet_list.html , and redefining the content of those blocks. !-- patient_lists/layouts/spreadsheet_list.html -- {% extends 'patient_lists/layouts/spreadsheet_list_base.html' %} {% block content %} ... my new block content ... {% endblock content %} Classmethods PatientList.get_absolute_url() Returns a string which is the absolute URL of this list. MyList.get_absolute_url() /#/list/my_list PatientList.get_icon() Returns a string which is the icon for this list. Defaults to None. MyList.get_icon() fa-wave PatientList.get_display_name() Returns a string which is the display name for this list. Defaults to None MyList.get_display_name() The List PatientList.as_menuitem(href=None, activepattern=None, icon=None, display=None, index=None) Return an instance of opal.core.menus.MenuItem that will direct the user to this patient list. TaggedPatientList Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists. PatientList.visible_to Further information is available in the Guides section . class TaggedPatientList Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists. Properties TaggedPatientList.tag The main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK. Further information is available in the Guides section . TaggedPatientList.subtag The child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK. class TabbedPatientListGroup Groups Patient Lists together, to display as tabs at the top of any list in the group. . TabbedPatientListGroup.for_list Returns the group for a given PatientList. Raises ValueError if not passed a PatientList. TabbedPatientListGroup.get_member_lists A hook for dynamically customising the members of this list group. Returns an iterable of PatientLists. Defaults to the .member_lists property. TabbedPatientListGroup.get_member_lists_for_user Returns an iterable of the visible member lists for a given user. TabbedPatientListGroup.member_lists A list containing the PatientList subclasses in this group. TabbedPatientListGroup.visible_to Predicate function to determine whether this list is meaningfully visible to this user. Built-in PatientList Templates Opal includes three patient lists out of the box: spreadsheet_list.html , card_list.html , and table_list.html . All these patient list layout templates use Django {% extends %} syntax to extend their base templates respectively. Each of these base templates contains Django {% block %} s, so you can override selected parts of the base template by creating a new file in patient_lists/layouts/ called, for example spreadsheet_list.html , and redefining the content of those blocks. 'Spreadsheet' PatientList Layout This is the default template, which gives you a 'spreadsheet'-like view of the patient list, with a sidebar containing default demographic info, tags and action tools. 'Card' PatientList Layout This will display the patient list as a series of 'cards', more analogous to a Twitter stream than the spreadsheet-like appearance of the default list. To use this layout, change your PatientList template_name to \"patient_lists/layouts/card_list.html\". 'Table' PatientList Layout This will display the patient list as a wide 'table', similar to the spreadsheet-like appearance of the default list, but without the sidebar and without the ability to edit individual items from this view. This view is commonly used when the user action is to click through to a patient detail view, or to provide action buttons in a column. To use, just change your PatientList template_name to \"patient_lists/layouts/table_list.html\".","title":"Patient Lists"},{"location":"reference/patient_list/#opalcorepatient_lists","text":"The patient_lists module defines a number of classes for working with lists of patients.","title":"opal.core.patient_lists"},{"location":"reference/patient_list/#class-opalcorepatient_listspatientlist","text":"","title":"class opal.core.patient_lists.PatientList"},{"location":"reference/patient_list/#patientlistallow_add_patient","text":"Whether we should show the add patient button. Defaults to True .","title":"PatientList.allow_add_patient"},{"location":"reference/patient_list/#patientlistallow_edit_teams","text":"Whether we should allow the user to edit teams. Defaults to True .","title":"PatientList.allow_edit_teams"},{"location":"reference/patient_list/#patientlistcomparator_service","text":"A custom comparator service to set sort order within a list. Defaults to None. Further information on Comparators can be found in the Opal Guides section.","title":"PatientList.comparator_service"},{"location":"reference/patient_list/#patientlistdirect_add","text":"Further information is available in the Guides section .","title":"PatientList.direct_add"},{"location":"reference/patient_list/#patientlistdisplay_name","text":"How we want to refer to this list on screen to users.","title":"PatientList.display_name"},{"location":"reference/patient_list/#patientlistorder","text":"Passing an integer to PatientList.order will allow you to control the order of display of Patient Lists in dropdowns and other views. Further information is available in the Guides section .","title":"PatientList.order"},{"location":"reference/patient_list/#patientlistqueryset","text":"Further information is available in the Guides section .","title":"PatientList.queryset"},{"location":"reference/patient_list/#patientlistschema","text":"Further information is available in the Guides section .","title":"PatientList.schema"},{"location":"reference/patient_list/#patientlistslug","text":"Further information is available in the Guides section .","title":"PatientList.slug"},{"location":"reference/patient_list/#patientlisttemplate_name","text":"To override the default Patient List template opal/templates/patient_list/layouts/spreadsheet_list.html with a custom template specify the path of the custom template (relative to /myapp/templates/ ) with this property. # myapp/patient_lists.py class MyPatientList(PatientList): template_name = 'my_layout.html' Will look for a template at /myapp/templates/my_layout.html . Opal includes three patient lists out of the box: spreadsheet_list.html , card_list.html , and table_list.html . See Built-in PatientList Templates below for further details. All these patient list layout templates use Django {% extends %} syntax to extend their base templates respectively. Each of these base templates contains Django {% block %} s, so you can override selected parts of the base template by creating a new file in patient_lists/layouts/ called, for example spreadsheet_list.html , and redefining the content of those blocks. !-- patient_lists/layouts/spreadsheet_list.html -- {% extends 'patient_lists/layouts/spreadsheet_list_base.html' %} {% block content %} ... my new block content ... {% endblock content %}","title":"PatientList.template_name"},{"location":"reference/patient_list/#classmethods","text":"","title":"Classmethods"},{"location":"reference/patient_list/#patientlistget_absolute_url","text":"Returns a string which is the absolute URL of this list. MyList.get_absolute_url() /#/list/my_list","title":"PatientList.get_absolute_url()"},{"location":"reference/patient_list/#patientlistget_icon","text":"Returns a string which is the icon for this list. Defaults to None. MyList.get_icon() fa-wave","title":"PatientList.get_icon()"},{"location":"reference/patient_list/#patientlistget_display_name","text":"Returns a string which is the display name for this list. Defaults to None MyList.get_display_name() The List","title":"PatientList.get_display_name()"},{"location":"reference/patient_list/#patientlistas_menuitemhrefnone-activepatternnone-iconnone-displaynone-indexnone","text":"Return an instance of opal.core.menus.MenuItem that will direct the user to this patient list.","title":"PatientList.as_menuitem(href=None, activepattern=None, icon=None, display=None, index=None)"},{"location":"reference/patient_list/#taggedpatientlist","text":"Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists.","title":"TaggedPatientList"},{"location":"reference/patient_list/#patientlistvisible_to","text":"Further information is available in the Guides section .","title":"PatientList.visible_to"},{"location":"reference/patient_list/#class-taggedpatientlist","text":"Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists.","title":"class TaggedPatientList"},{"location":"reference/patient_list/#properties","text":"","title":"Properties"},{"location":"reference/patient_list/#taggedpatientlisttag","text":"The main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK. Further information is available in the Guides section .","title":"TaggedPatientList.tag"},{"location":"reference/patient_list/#taggedpatientlistsubtag","text":"The child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.","title":"TaggedPatientList.subtag"},{"location":"reference/patient_list/#class-tabbedpatientlistgroup","text":"Groups Patient Lists together, to display as tabs at the top of any list in the group. .","title":"class TabbedPatientListGroup"},{"location":"reference/patient_list/#tabbedpatientlistgroupfor_list","text":"Returns the group for a given PatientList. Raises ValueError if not passed a PatientList.","title":"TabbedPatientListGroup.for_list"},{"location":"reference/patient_list/#tabbedpatientlistgroupget_member_lists","text":"A hook for dynamically customising the members of this list group. Returns an iterable of PatientLists. Defaults to the .member_lists property.","title":"TabbedPatientListGroup.get_member_lists"},{"location":"reference/patient_list/#tabbedpatientlistgroupget_member_lists_for_user","text":"Returns an iterable of the visible member lists for a given user.","title":"TabbedPatientListGroup.get_member_lists_for_user"},{"location":"reference/patient_list/#tabbedpatientlistgroupmember_lists","text":"A list containing the PatientList subclasses in this group.","title":"TabbedPatientListGroup.member_lists"},{"location":"reference/patient_list/#tabbedpatientlistgroupvisible_to","text":"Predicate function to determine whether this list is meaningfully visible to this user.","title":"TabbedPatientListGroup.visible_to"},{"location":"reference/patient_list/#built-in-patientlist-templates","text":"Opal includes three patient lists out of the box: spreadsheet_list.html , card_list.html , and table_list.html . All these patient list layout templates use Django {% extends %} syntax to extend their base templates respectively. Each of these base templates contains Django {% block %} s, so you can override selected parts of the base template by creating a new file in patient_lists/layouts/ called, for example spreadsheet_list.html , and redefining the content of those blocks.","title":"Built-in PatientList Templates"},{"location":"reference/patient_list/#spreadsheet-patientlist-layout","text":"This is the default template, which gives you a 'spreadsheet'-like view of the patient list, with a sidebar containing default demographic info, tags and action tools.","title":"'Spreadsheet' PatientList Layout"},{"location":"reference/patient_list/#card-patientlist-layout","text":"This will display the patient list as a series of 'cards', more analogous to a Twitter stream than the spreadsheet-like appearance of the default list. To use this layout, change your PatientList template_name to \"patient_lists/layouts/card_list.html\".","title":"'Card' PatientList Layout"},{"location":"reference/patient_list/#table-patientlist-layout","text":"This will display the patient list as a wide 'table', similar to the spreadsheet-like appearance of the default list, but without the sidebar and without the ability to edit individual items from this view. This view is commonly used when the user action is to click through to a patient detail view, or to provide action buttons in a column. To use, just change your PatientList template_name to \"patient_lists/layouts/table_list.html\".","title":"'Table' PatientList Layout"},{"location":"reference/plugin/","text":"Plugins Opal provides a plugin mechanism to help developers write generic reusable components. Plugins must inherit from opal.core.plugins.OpalPlugin . OpalPlugin OpalPlugin is a discoverable feature - it will be automatically discovered by Opal if placed in a plugin.py file within an installed Django app. Attributes OpalPlugin.urls A Django urlpatterns object to add to our urls. Default is []. OpalPlugin.javascripts A python dictionary containing namespaced sets of javascript files to include in our application. These will be included on every page by default. class MyPlugin(OpalPlugin): javascripts = { 'opal.services': [ 'js/myplugin/awesome_service.js' ] } OpalPlugin.apis A python iterable of APIs to add to the Django Rest Framework APIs available. class MyPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ] OpalPlugin.stylesheets A python iterable of stylesheets to add to our application. These will be included on every page by default. class MyPlugin(OpalPlugin): stylesheets = 'css/myawesomestyles.css' ] OpalPlugin.menuitems A python iterable of items to add to the main menu of our application. OpalPlugin.actions A Python iterable of templates to include as actions - e.g. additional buttons to add to the context of a detail, list or other view. These are visible everywhere by default, so care should be taken to ensure appropriate show/hide logic is present. Classmethods OpalPlugin.get_urls() Returns the Django url patterns to be registered. Defaults to simply returning the urls attribute. OpalPlugin.get_apis() Returns the APIs to be registered with the Django Rest Framework APIs. Defaults to simply returning the apis attribute. OpalPlugin.directory() Returns the path to the directory containing the file in which this plugin is defined. OpalPlugin.get_javascripts() Return a dictionary of namespaced javascript files as paths to them ready for staticfiles. Defaults to returning the OpalPlugin.javascripts property. plugin.get_javascripts() # - {'opal.test': ['js/test/notreal.js']} OpalPlugin.get_styles() Return a list of the plugin's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalPlugin.styles . plugin.get_styles() # - ['css/app.css', ...] OpalPlugin.angular_module_deps When you initialise an angular application you need to register dependencies This allows you to add to the dependencies of the default opal application","title":"OpalPlugin"},{"location":"reference/plugin/#plugins","text":"Opal provides a plugin mechanism to help developers write generic reusable components. Plugins must inherit from opal.core.plugins.OpalPlugin .","title":"Plugins"},{"location":"reference/plugin/#opalplugin","text":"OpalPlugin is a discoverable feature - it will be automatically discovered by Opal if placed in a plugin.py file within an installed Django app.","title":"OpalPlugin"},{"location":"reference/plugin/#attributes","text":"","title":"Attributes"},{"location":"reference/plugin/#opalpluginurls","text":"A Django urlpatterns object to add to our urls. Default is [].","title":"OpalPlugin.urls"},{"location":"reference/plugin/#opalpluginjavascripts","text":"A python dictionary containing namespaced sets of javascript files to include in our application. These will be included on every page by default. class MyPlugin(OpalPlugin): javascripts = { 'opal.services': [ 'js/myplugin/awesome_service.js' ] }","title":"OpalPlugin.javascripts"},{"location":"reference/plugin/#opalpluginapis","text":"A python iterable of APIs to add to the Django Rest Framework APIs available. class MyPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ]","title":"OpalPlugin.apis"},{"location":"reference/plugin/#opalpluginstylesheets","text":"A python iterable of stylesheets to add to our application. These will be included on every page by default. class MyPlugin(OpalPlugin): stylesheets = 'css/myawesomestyles.css' ]","title":"OpalPlugin.stylesheets"},{"location":"reference/plugin/#opalpluginmenuitems","text":"A python iterable of items to add to the main menu of our application.","title":"OpalPlugin.menuitems"},{"location":"reference/plugin/#opalpluginactions","text":"A Python iterable of templates to include as actions - e.g. additional buttons to add to the context of a detail, list or other view. These are visible everywhere by default, so care should be taken to ensure appropriate show/hide logic is present.","title":"OpalPlugin.actions"},{"location":"reference/plugin/#classmethods","text":"","title":"Classmethods"},{"location":"reference/plugin/#opalpluginget_urls","text":"Returns the Django url patterns to be registered. Defaults to simply returning the urls attribute.","title":"OpalPlugin.get_urls()"},{"location":"reference/plugin/#opalpluginget_apis","text":"Returns the APIs to be registered with the Django Rest Framework APIs. Defaults to simply returning the apis attribute.","title":"OpalPlugin.get_apis()"},{"location":"reference/plugin/#opalplugindirectory","text":"Returns the path to the directory containing the file in which this plugin is defined.","title":"OpalPlugin.directory()"},{"location":"reference/plugin/#opalpluginget_javascripts","text":"Return a dictionary of namespaced javascript files as paths to them ready for staticfiles. Defaults to returning the OpalPlugin.javascripts property. plugin.get_javascripts() # - {'opal.test': ['js/test/notreal.js']}","title":"OpalPlugin.get_javascripts()"},{"location":"reference/plugin/#opalpluginget_styles","text":"Return a list of the plugin's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalPlugin.styles . plugin.get_styles() # - ['css/app.css', ...]","title":"OpalPlugin.get_styles()"},{"location":"reference/plugin/#opalpluginangular_module_deps","text":"When you initialise an angular application you need to register dependencies This allows you to add to the dependencies of the default opal application","title":"OpalPlugin.angular_module_deps"},{"location":"reference/reference_guides/","text":"Opal Reference material The following reference guides are available: Models opal.models.Episode The central Episode model opal.models.Patient The Patient model opal.models.Subrecord for subrecords of Episodes or Patients opal.models.UserProfile The Opal UserProfile model opal.models.* Mixin helpers for useful functionality Opal Core opal.core.application Opal Application objects opal.core.detail Detail Views - Custom views over one or many episodes. opal.core.discoverable Reusable feature groups for plugins and applications opal.core.episodes Episode Categories - Controlling the behaviour of different types of episode opal.core.fields Field helpers - custom field types and utility functions opal.core.patient_lists Patient Lists - defining different types of list opal.core.log Log Helpers - custom email error loggers opal.core.lookuplists Utilities for working with lookuplists opal.core.menus Menus - declaring application menus opal.core.plugin Plugins - defining plugins to package reusable functionality opal.core.schemas Schemas - Dynamic columns for the table views opal.core.serialization Helpers for serializing and deserializing data opal.core.subrecords Helpers for working with subrecords Angular Services Patient Patient objects Episode Episode objects Item Subrecord objects User User objects PatientSummary Patient search result summaries Search Services Services from the Search module Loaders JS Services that load in from patient list, episode and patient apis Helper libraries The forms Templatetag library The building blocks for Opal forms The panels Templatetag library Rendering record panels The menus Templatetag library Rendering application menus Javascript Helpers Angular directives, filters and $rootScope methods Utils module The opal.utils module - miscellaneous helpful python utilities Opal core modules Making Search Queries Search query backends and helper functions Pathway Simple or complicated multilayed forms Miscellaneous documentation Settings Opal settings Changelog Opal Changelog Upgrading Upgrading between Opal versions Javascript dependencies External javascript libraries available Testing Testing Management commands Django management commands","title":"Reference"},{"location":"reference/reference_guides/#opal-reference-material","text":"The following reference guides are available:","title":"Opal Reference material"},{"location":"reference/reference_guides/#models","text":"opal.models.Episode The central Episode model opal.models.Patient The Patient model opal.models.Subrecord for subrecords of Episodes or Patients opal.models.UserProfile The Opal UserProfile model opal.models.* Mixin helpers for useful functionality","title":"Models"},{"location":"reference/reference_guides/#opal-core","text":"opal.core.application Opal Application objects opal.core.detail Detail Views - Custom views over one or many episodes. opal.core.discoverable Reusable feature groups for plugins and applications opal.core.episodes Episode Categories - Controlling the behaviour of different types of episode opal.core.fields Field helpers - custom field types and utility functions opal.core.patient_lists Patient Lists - defining different types of list opal.core.log Log Helpers - custom email error loggers opal.core.lookuplists Utilities for working with lookuplists opal.core.menus Menus - declaring application menus opal.core.plugin Plugins - defining plugins to package reusable functionality opal.core.schemas Schemas - Dynamic columns for the table views opal.core.serialization Helpers for serializing and deserializing data opal.core.subrecords Helpers for working with subrecords","title":"Opal Core"},{"location":"reference/reference_guides/#angular-services","text":"Patient Patient objects Episode Episode objects Item Subrecord objects User User objects PatientSummary Patient search result summaries Search Services Services from the Search module Loaders JS Services that load in from patient list, episode and patient apis","title":"Angular Services"},{"location":"reference/reference_guides/#helper-libraries","text":"The forms Templatetag library The building blocks for Opal forms The panels Templatetag library Rendering record panels The menus Templatetag library Rendering application menus Javascript Helpers Angular directives, filters and $rootScope methods Utils module The opal.utils module - miscellaneous helpful python utilities","title":"Helper libraries"},{"location":"reference/reference_guides/#opal-core-modules","text":"Making Search Queries Search query backends and helper functions Pathway Simple or complicated multilayed forms","title":"Opal core modules"},{"location":"reference/reference_guides/#miscellaneous-documentation","text":"Settings Opal settings Changelog Opal Changelog Upgrading Upgrading between Opal versions Javascript dependencies External javascript libraries available Testing Testing Management commands Django management commands","title":"Miscellaneous documentation"},{"location":"reference/schemas/","text":"Opal Schemas Opal schemas provide a JSON representation of the structure of subrecords. Opal uses these schemas internally to construct the Item classes in AngularJS on the client side. The Schema for an Opal application is available at the url /api/v0.1/record/ and contains the serialized representation of all subrecords and their fields. Subrecord information Individual subrecords are serialized to the schema using the function opal.core.schemas.serialize_model . Schema Subrecord fields name: the result of Subrecord.get_api_name() display_name: the result of Subrecord.get_display_name() single: Whether the Subrecord is a singleton advanced_searchable: if the Subrecord should appear in the advanced search view fields: a represention of each field Optional fields: sort: an Angular string that describes how subrecord of this type should be ordered readOnly: if this Subrecord is read only form_url: the url of the form of this Subrecord icon: the icon class of this Subrecord if it exists angular_service: an Angular service used to initialize the Item in the Opal client side application. class Colour(models.EpisodeSubrecord): _advanced_searchable = False _exclude_from_extract = True _angular_service = 'Colour' _icon = fa fa-comments name = dmodels.CharField(max_length=200) # becomes:... { 'advanced_searchable': False, 'angular_service': 'Colour', 'display_name': 'Colour', 'fields': [ # field information as noted below ], 'form_url': u'/templates/forms/colour.html', 'icon': 'fa fa-comments', 'name': 'colour', 'single': False } Subrecord Field information Opal makes the most out of the rich Django model interface by delivering much of the derivable metadata about the structure of fields straight from the model. default: the default value for the field to appear in the form. At present this will accept a callable but won't serialise date/datetime fields. model: The name of the model this field relates to. lookup_list: For ForeignKeyOrFreeText fields this returns name of the lookup list that relates to this field. title: The verbose_name of this field, type: The type of field. Allows us to correctly cast fields into moments on the front end. name: the api name for the field class Birthday(models.PatientSubrecord): party = dmodels.DateTimeField(verbose_name= Party Time! blank=True) name = dmodels.CharField(default='Dave', blank=True, null=True) # becomes... [ { 'default': Dave , 'lookup_list': None, 'model': 'Birthday', 'name': 'name', 'title': u'Name', 'type': 'string' }, { 'default': None, 'lookup_list': None, 'model': 'Birthday', 'name': 'party', 'title': u'Party Time!', 'type': 'date_time' } ]","title":"Schemas"},{"location":"reference/schemas/#opal-schemas","text":"Opal schemas provide a JSON representation of the structure of subrecords. Opal uses these schemas internally to construct the Item classes in AngularJS on the client side. The Schema for an Opal application is available at the url /api/v0.1/record/ and contains the serialized representation of all subrecords and their fields.","title":"Opal Schemas"},{"location":"reference/schemas/#subrecord-information","text":"Individual subrecords are serialized to the schema using the function opal.core.schemas.serialize_model .","title":"Subrecord information"},{"location":"reference/schemas/#schema-subrecord-fields","text":"name: the result of Subrecord.get_api_name() display_name: the result of Subrecord.get_display_name() single: Whether the Subrecord is a singleton advanced_searchable: if the Subrecord should appear in the advanced search view fields: a represention of each field Optional fields: sort: an Angular string that describes how subrecord of this type should be ordered readOnly: if this Subrecord is read only form_url: the url of the form of this Subrecord icon: the icon class of this Subrecord if it exists angular_service: an Angular service used to initialize the Item in the Opal client side application. class Colour(models.EpisodeSubrecord): _advanced_searchable = False _exclude_from_extract = True _angular_service = 'Colour' _icon = fa fa-comments name = dmodels.CharField(max_length=200) # becomes:... { 'advanced_searchable': False, 'angular_service': 'Colour', 'display_name': 'Colour', 'fields': [ # field information as noted below ], 'form_url': u'/templates/forms/colour.html', 'icon': 'fa fa-comments', 'name': 'colour', 'single': False }","title":"Schema Subrecord fields"},{"location":"reference/schemas/#subrecord-field-information","text":"Opal makes the most out of the rich Django model interface by delivering much of the derivable metadata about the structure of fields straight from the model. default: the default value for the field to appear in the form. At present this will accept a callable but won't serialise date/datetime fields. model: The name of the model this field relates to. lookup_list: For ForeignKeyOrFreeText fields this returns name of the lookup list that relates to this field. title: The verbose_name of this field, type: The type of field. Allows us to correctly cast fields into moments on the front end. name: the api name for the field class Birthday(models.PatientSubrecord): party = dmodels.DateTimeField(verbose_name= Party Time! blank=True) name = dmodels.CharField(default='Dave', blank=True, null=True) # becomes... [ { 'default': Dave , 'lookup_list': None, 'model': 'Birthday', 'name': 'name', 'title': u'Name', 'type': 'string' }, { 'default': None, 'lookup_list': None, 'model': 'Birthday', 'name': 'party', 'title': u'Party Time!', 'type': 'date_time' } ]","title":"Subrecord Field information"},{"location":"reference/search_queries/","text":"opal.core.search.queries This module provides our base classes for query backends as well as helper functions. episodes_for_user Given an iterable of EPISODES and a USER, return a filtered list of episodes that this user has the permissions to know about. filtered_episodes = episodes_for_user(episodes, user) fuzzy_query Given a partial fragment for example Jane 123, return all patients that have either a first name, last name or hospital number including jane or 123. Under the covers it uses Patient.objects.search . It then orders patients by which have had their episodes created most recently.","title":"Search Queries"},{"location":"reference/search_queries/#opalcoresearchqueries","text":"This module provides our base classes for query backends as well as helper functions.","title":"opal.core.search.queries"},{"location":"reference/search_queries/#episodes_for_user","text":"Given an iterable of EPISODES and a USER, return a filtered list of episodes that this user has the permissions to know about. filtered_episodes = episodes_for_user(episodes, user)","title":"episodes_for_user"},{"location":"reference/search_queries/#fuzzy_query","text":"Given a partial fragment for example Jane 123, return all patients that have either a first name, last name or hospital number including jane or 123. Under the covers it uses Patient.objects.search . It then orders patients by which have had their episodes created most recently.","title":"fuzzy_query"},{"location":"reference/settings/","text":"Opal Settings Opal applications provide a number of settings in the settings.py of your application. OPAL_AUTOCOMPLETE_SEARCH Whether to enable autocomplete on search from the navbar. Defaults to False. OPAL_BRAND_NAME The human readable form of your application name. Displayed in the header by default. Scaffolded applications start with whatever is passed in to opal startproject . OPAL_DEFAULT_SEARCH_FIELDS Search fields that we look in by default when a user enters a search term. Defaults to [ demographics__hospital_number , demographics__first_name , demographics__surname ] OPAL_LOG_OUT_DURATION Opal will log users out if they have been inactive for greater than this value. Scaffolded applications set this to 15 minutes by default. Unit is milliseconds. OPAL_LOGO_PATH If OPAL_LOGO_PATH is set, the value is passed to the {% static %} templatetag to set the src attribute of an image in the default application header and login screen. OPAL_FAVICON_PATH If OPAL_FAVICON_PATH is set, the value is passed to the {% static %} templatetag to set the href attribute for the favicon tag in the default application head VERSION_NUMBER The version number of your application. Displayed in the header by default. Scaffolded applications start at 0.0.1 . DATE_DISPLAY_FORMAT The format string to use when rendering dates using the displayDate Angular filter. This defaults to D MMM YYYY . Note that as formatting is performed by calling the Moment.js .format() method, the date formatting syntax is neither Python strftime nor Django date formatting syntax. For full details consult https://momentjs.com/docs/#/displaying/format/","title":"Settings"},{"location":"reference/settings/#opal-settings","text":"Opal applications provide a number of settings in the settings.py of your application.","title":"Opal Settings"},{"location":"reference/settings/#opal_autocomplete_search","text":"Whether to enable autocomplete on search from the navbar. Defaults to False.","title":"OPAL_AUTOCOMPLETE_SEARCH"},{"location":"reference/settings/#opal_brand_name","text":"The human readable form of your application name. Displayed in the header by default. Scaffolded applications start with whatever is passed in to opal startproject .","title":"OPAL_BRAND_NAME"},{"location":"reference/settings/#opal_default_search_fields","text":"Search fields that we look in by default when a user enters a search term. Defaults to [ demographics__hospital_number , demographics__first_name , demographics__surname ]","title":"OPAL_DEFAULT_SEARCH_FIELDS"},{"location":"reference/settings/#opal_log_out_duration","text":"Opal will log users out if they have been inactive for greater than this value. Scaffolded applications set this to 15 minutes by default. Unit is milliseconds.","title":"OPAL_LOG_OUT_DURATION"},{"location":"reference/settings/#opal_logo_path","text":"If OPAL_LOGO_PATH is set, the value is passed to the {% static %} templatetag to set the src attribute of an image in the default application header and login screen.","title":"OPAL_LOGO_PATH"},{"location":"reference/settings/#opal_favicon_path","text":"If OPAL_FAVICON_PATH is set, the value is passed to the {% static %} templatetag to set the href attribute for the favicon tag in the default application head","title":"OPAL_FAVICON_PATH"},{"location":"reference/settings/#version_number","text":"The version number of your application. Displayed in the header by default. Scaffolded applications start at 0.0.1 .","title":"VERSION_NUMBER"},{"location":"reference/settings/#date_display_format","text":"The format string to use when rendering dates using the displayDate Angular filter. This defaults to D MMM YYYY . Note that as formatting is performed by calling the Moment.js .format() method, the date formatting syntax is neither Python strftime nor Django date formatting syntax. For full details consult https://momentjs.com/docs/#/displaying/format/","title":"DATE_DISPLAY_FORMAT"},{"location":"reference/subrecords/","text":"Opal Subrecords Opal Subrecords are models that relate to either Patients or Episodes, and inherit from base classes opal.models.PatientSubrecord or opal.models.EpisodeSubrecord They themselves inherit from the mixins opal.models.ToDictMixin , opal.models.UpdateFromDict Properties Subrecord._angular_service Name of the Angular service you would like to use to customise the initialization of this subrecord in the javascript layer. class Demographics(PatientSubrecord): _angular_service = 'Demographics' Subrecord._icon String that provides the name of the icon to use for forms, column headings etc. class Demographics(PatientSubrecord): _icon = 'fa fa-user' Subrecord._is_singleton Boolean that determines whether this subrecord is a singleton. There may only be one of each singleton Subrecord, which is created with the parent. class Demographics(PatientSubrecord): _is_singleton = True For this case, when a Patient is created, an empty Demographics instance will automatically be created. Subrecord._list_limit Integer to indicate the maximum number of entries to display in list view for this model. Useful for record types where many entries will accrue, or where display is particularly verbose. class BloodPressureReading(EpisodeSubrecord): _list_limit = 3 Subrecord._sort Name of the field by which we want to sort these records when displaying. class Antimicrobial(EpisodeSubrecord): _sort = 'start_date' Subrecord._exclude_from_extract Boolean to specify that this subrecord should be excluded from any standard data extract. This implicitly defaults to False. class Antimicrobial(EpisodeSubrecord): _exclude_from_extract = 'Abx' Subrecord.pid_fields An iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID). This is used when creating data extracts to exclude PID from e.g. CSV downloads. Methods Subrecord.get_api_name() Classmethod that returns a snake case version of the API name for this subrecord. This will be used in the URL for the subrecord API, and as a property name in Javascript representations of the data. Demographics.get_api_name() demographics Subrecord.get_display_name() Classmethod that returns the display name of the subrecord. This is used as the user visible title of subrecord panels and modals amongst other places. By default this uses the Django Meta verbose_name property PastMedicalHistory.get_display_name() PMH Subrecord.get_display_template() Classmethod to locate the display template for our record. By default this looks in the location {{ template_dir }}/records/{{ subrecord api name }}.html . Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_display_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/records/example/subrecord.html {{ template_dir }}/records/subrecord.html Subrecord.get_detail_template() Classmethod to locate a more detailed template for the subrecord. This is the template used by the record panel. It looks for a template in {{ template_dir }}/records/{{ subrecord api name }}_detail.html . It defaults to the display template if it can't find one there. Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_display_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/records/example/subrecord_detail.html {{ template_dir }}/records/example/subrecord.html {{ template_dir }}/records/subrecord_detail.html {{ template_dir }}/records/subrecord.html Subrecord.get_form_template() Classmethod to locate the active template for our record. Returns the name of a template or None. It looks for a template in {{ template_dir }}/forms/{{ subrecord api name }}_form.html Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_form_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/forms/example/subrecord_form.html {{ template_dir }}/forms/subrecord_form.html Subrecord.get_modal_template() Classmethod to locate the active template for our record. Returns the name of a template or None. By default it will render a modal with a form template from Subrecord.get_form_template(). You can override this by putting a template named {{ template_dir }}/modals/{{ subrecord api name }}_modal.html Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_modal_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/modals/example/subrecord_modal.html {{ template_dir }}/modals/subrecord_modal.html And default to a modal containing the Subrecord.get_form_template . Subrecord.get_modal_footer_template Classmethod to add a custom footer to a modal, used for example to denote if the data from a model has been sourced from an external source Subrecord.bulk_update_from_dicts() A Classmethod to allow the creation of multiple objects. Takes in the parent model - an episode for EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates over all the subrecords, adds in the parent relationship and calls update_from_dict. It returns a list of the objects updated. Subrecord Mixins TrackedModel A Tracked Model automatically has created, created_by, updated, updated_by and these are only updated when used via the api ExternallySourcedModel Often we want data to be sourced from external systems, this mixin adds in the fields external_system and external_identifier to allow us to track where they come from and how they are referenced by that system. These fields are then often used in forms to make the data read only","title":"Subrecords"},{"location":"reference/subrecords/#opal-subrecords","text":"Opal Subrecords are models that relate to either Patients or Episodes, and inherit from base classes opal.models.PatientSubrecord or opal.models.EpisodeSubrecord They themselves inherit from the mixins opal.models.ToDictMixin , opal.models.UpdateFromDict","title":"Opal Subrecords"},{"location":"reference/subrecords/#properties","text":"","title":"Properties"},{"location":"reference/subrecords/#subrecord_angular_service","text":"Name of the Angular service you would like to use to customise the initialization of this subrecord in the javascript layer. class Demographics(PatientSubrecord): _angular_service = 'Demographics'","title":"Subrecord._angular_service"},{"location":"reference/subrecords/#subrecord_icon","text":"String that provides the name of the icon to use for forms, column headings etc. class Demographics(PatientSubrecord): _icon = 'fa fa-user'","title":"Subrecord._icon"},{"location":"reference/subrecords/#subrecord_is_singleton","text":"Boolean that determines whether this subrecord is a singleton. There may only be one of each singleton Subrecord, which is created with the parent. class Demographics(PatientSubrecord): _is_singleton = True For this case, when a Patient is created, an empty Demographics instance will automatically be created.","title":"Subrecord._is_singleton"},{"location":"reference/subrecords/#subrecord_list_limit","text":"Integer to indicate the maximum number of entries to display in list view for this model. Useful for record types where many entries will accrue, or where display is particularly verbose. class BloodPressureReading(EpisodeSubrecord): _list_limit = 3","title":"Subrecord._list_limit"},{"location":"reference/subrecords/#subrecord_sort","text":"Name of the field by which we want to sort these records when displaying. class Antimicrobial(EpisodeSubrecord): _sort = 'start_date'","title":"Subrecord._sort"},{"location":"reference/subrecords/#subrecord_exclude_from_extract","text":"Boolean to specify that this subrecord should be excluded from any standard data extract. This implicitly defaults to False. class Antimicrobial(EpisodeSubrecord): _exclude_from_extract = 'Abx'","title":"Subrecord._exclude_from_extract"},{"location":"reference/subrecords/#subrecordpid_fields","text":"An iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID). This is used when creating data extracts to exclude PID from e.g. CSV downloads.","title":"Subrecord.pid_fields"},{"location":"reference/subrecords/#methods","text":"","title":"Methods"},{"location":"reference/subrecords/#subrecordget_api_name","text":"Classmethod that returns a snake case version of the API name for this subrecord. This will be used in the URL for the subrecord API, and as a property name in Javascript representations of the data. Demographics.get_api_name() demographics","title":"Subrecord.get_api_name()"},{"location":"reference/subrecords/#subrecordget_display_name","text":"Classmethod that returns the display name of the subrecord. This is used as the user visible title of subrecord panels and modals amongst other places. By default this uses the Django Meta verbose_name property PastMedicalHistory.get_display_name() PMH","title":"Subrecord.get_display_name()"},{"location":"reference/subrecords/#subrecordget_display_template","text":"Classmethod to locate the display template for our record. By default this looks in the location {{ template_dir }}/records/{{ subrecord api name }}.html . Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_display_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/records/example/subrecord.html {{ template_dir }}/records/subrecord.html","title":"Subrecord.get_display_template()"},{"location":"reference/subrecords/#subrecordget_detail_template","text":"Classmethod to locate a more detailed template for the subrecord. This is the template used by the record panel. It looks for a template in {{ template_dir }}/records/{{ subrecord api name }}_detail.html . It defaults to the display template if it can't find one there. Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_display_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/records/example/subrecord_detail.html {{ template_dir }}/records/example/subrecord.html {{ template_dir }}/records/subrecord_detail.html {{ template_dir }}/records/subrecord.html","title":"Subrecord.get_detail_template()"},{"location":"reference/subrecords/#subrecordget_form_template","text":"Classmethod to locate the active template for our record. Returns the name of a template or None. It looks for a template in {{ template_dir }}/forms/{{ subrecord api name }}_form.html Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_form_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/forms/example/subrecord_form.html {{ template_dir }}/forms/subrecord_form.html","title":"Subrecord.get_form_template()"},{"location":"reference/subrecords/#subrecordget_modal_template","text":"Classmethod to locate the active template for our record. Returns the name of a template or None. By default it will render a modal with a form template from Subrecord.get_form_template(). You can override this by putting a template named {{ template_dir }}/modals/{{ subrecord api name }}_modal.html Keywords: prefixes An optional list of prefixes that allow you to put templates behind an optional directory for example: Subrecord.get_modal_template(prefixes=[ example ]) Would use the first template it found, looking at: {{ template_dir }}/modals/example/subrecord_modal.html {{ template_dir }}/modals/subrecord_modal.html And default to a modal containing the Subrecord.get_form_template .","title":"Subrecord.get_modal_template()"},{"location":"reference/subrecords/#subrecordget_modal_footer_template","text":"Classmethod to add a custom footer to a modal, used for example to denote if the data from a model has been sourced from an external source","title":"Subrecord.get_modal_footer_template"},{"location":"reference/subrecords/#subrecordbulk_update_from_dicts","text":"A Classmethod to allow the creation of multiple objects. Takes in the parent model - an episode for EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates over all the subrecords, adds in the parent relationship and calls update_from_dict. It returns a list of the objects updated.","title":"Subrecord.bulk_update_from_dicts()"},{"location":"reference/subrecords/#subrecord-mixins","text":"","title":"Subrecord Mixins"},{"location":"reference/subrecords/#trackedmodel","text":"A Tracked Model automatically has created, created_by, updated, updated_by and these are only updated when used via the api","title":"TrackedModel"},{"location":"reference/subrecords/#externallysourcedmodel","text":"Often we want data to be sourced from external systems, this mixin adds in the fields external_system and external_identifier to allow us to track where they come from and how they are referenced by that system. These fields are then often used in forms to make the data read only","title":"ExternallySourcedModel"},{"location":"reference/testing/","text":"Automated Testing Built on top of Django and Angular, Opal applications have great support for automated testing. Opal provides some utilities to make testing your application even easier. Command Line test runner The opal command line tool has a test command which will run unittests for both the server and client side components of your application. Javascript testing By default, we recommend using Jasmine and Karma to test your javascript code. Of course you can use any test framework you choose, although Opal doesn't currently ship with helpers for any other frameworks. Installing javascript testing tools To installing Karma, Jasmine and Phantomjs in a local directory: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher Setting up the karma environment for your application If you'd like to run karma tests, Opal ships with a function to give you a default karma config. In your karma config just require('[[ path to opal ]]/config/karma_defaults.js') The function takes in the files you want to include and runs karma tests on them. // config/karma.config.js module.exports = function(config){ var opalPath = process.env.OPAL_LOCATION; var karmaDefaults = require(opalPath + '/config/karma_defaults.js'); var baseDir = __dirname + '/..'; var includedFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir); config.set(defaultConfig); }; If run from opal test js, we set the path to opal as an env variable called OPAL_LOCATION Test Coverage The Opal test runner has a -c option which runs coverage reports for both Python and Javascript code: opal test -c Python test coverage uses the coverage tool and you may want to set include/excludes in a .coveragerc . Javascript test files to be reported on should be passed as an extra argument to karmaDefaults : var coverageFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir, coverageFiles); HTML test coverage reports will be output to the directory htmlcov and htmlcov/js at the root of your application.","title":"Testing"},{"location":"reference/testing/#automated-testing","text":"Built on top of Django and Angular, Opal applications have great support for automated testing. Opal provides some utilities to make testing your application even easier.","title":"Automated Testing"},{"location":"reference/testing/#command-line-test-runner","text":"The opal command line tool has a test command which will run unittests for both the server and client side components of your application.","title":"Command Line test runner"},{"location":"reference/testing/#javascript-testing","text":"By default, we recommend using Jasmine and Karma to test your javascript code. Of course you can use any test framework you choose, although Opal doesn't currently ship with helpers for any other frameworks.","title":"Javascript testing"},{"location":"reference/testing/#installing-javascript-testing-tools","text":"To installing Karma, Jasmine and Phantomjs in a local directory: npm install jasmine-core karma karma-coverage karma-jasmine karma-phantomjs-launcher","title":"Installing javascript testing tools"},{"location":"reference/testing/#setting-up-the-karma-environment-for-your-application","text":"If you'd like to run karma tests, Opal ships with a function to give you a default karma config. In your karma config just require('[[ path to opal ]]/config/karma_defaults.js') The function takes in the files you want to include and runs karma tests on them. // config/karma.config.js module.exports = function(config){ var opalPath = process.env.OPAL_LOCATION; var karmaDefaults = require(opalPath + '/config/karma_defaults.js'); var baseDir = __dirname + '/..'; var includedFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir); config.set(defaultConfig); }; If run from opal test js, we set the path to opal as an env variable called OPAL_LOCATION","title":"Setting up the karma environment for your application"},{"location":"reference/testing/#test-coverage","text":"The Opal test runner has a -c option which runs coverage reports for both Python and Javascript code: opal test -c Python test coverage uses the coverage tool and you may want to set include/excludes in a .coveragerc . Javascript test files to be reported on should be passed as an extra argument to karmaDefaults : var coverageFiles = [ ... ]; var defaultConfig = karmaDefaults(includedFiles, baseDir, coverageFiles); HTML test coverage reports will be output to the directory htmlcov and htmlcov/js at the root of your application.","title":"Test Coverage"},{"location":"reference/upgrading/","text":"Upgrading Your Opal Application This document provides instructions for specific steps required to upgrading your Opal application to a later version where there are extra steps required. v0.17.1 - v0.18.0 Style sheets loaded via Opal Applicatin or Plugin objects are now included with the attribute media=\"all\" rather than `media=\"screen\". This may affect how pages in your application print and require additional print styles. v0.15.0 - v0.16.0 Diagnosis.details is now a text field. Please make and run migrations if you are using it in your app. The record template for diagnosis now shows the details on the next row. 0.13.1 - 0.14.0 If you were creating a UserProfile, this will now fail as a UserProfile is created automatically after creating a user (by a signal). 0.13.0 - 0.13.1 Upgrades django (minor security upgrade). How you do this depends on how you have configured your application. You will need to update both the Opal version, and versions of upgraded dependencies if you have specified them in for instance, a requirements.txt. (This will be the case if you use the requirements.txt originally provided by opal startproject ) # requirements.txt opal==0.13.1 django==2.0.13 0.12.0 - 0.11.2 - 0.13.0 Python versions Opal 0.13.0 drops support for Python 2.x If you have not already done so, you will need to upgrade your application to Python 3 in order to upgrade. You may also like to run the tests for your application with the 'show warnings' flag e.g. python -Wd manage.py test Upgrading Opal How you do this depends on how you have configured your application. You will need to update both the Opal version, and versions of upgraded dependencies if you have specified them in for instance, a requirements.txt. (This will be the case if you use the requirements.txt originally provided by opal startproject ) # requirements.txt opal==0.13.0 django==2.0.9 django-reversion==3.0.1 djangorestframework==3.7.4 letter==0.5 psycopg==2.7.6.1 python-dateutil==2.7.5 requests=2.20.1 Free text or foreign key fields are now, by default case insensitive It is recommended you resave all model values for fk_or_ft fields as this will give you consistent behaviour. Otherwise fk_ft values wihch differ from fkt values only by case prior to this upgrade will be stored as ft and those afterwards will be stored as the relevant fk. Migrations You will need to run the migrations for Opal 0.13.0 $ python manage.py migrate opal As Opal 0.13.0 contains changes to the definition of lookuplists, you will need to run a makemigrations command to update your lookuplists to enable code values and change case sensitivity. python manage.py makemigrations yourapp python manage.py migrate yourapp 0.11.1 - 0.11.2 This bugfix release should be entirely backwards compatible. 0.11.0 - 0.11.1 This bugfix release should be entirely backwards compatible. 0.10.1 - 0.11.0 Please upgrade django-compressor version to 2.2, ie update your requirements to requirements.txt django-compressor==2.2 0.10.0 - 0.10.1 Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.10.1 There are no migrations or additional commands for this upgrae, and we are not aware of any backwards incompatible changes. 0.9.0 - 0.10.0 Upgrading Opal How you do this depends on how you have configured your application. You will need to update both the Opal version, and versions of dependencies upgraded dependencies if you have specified them in for instance, a requirements.txt. (This will be the case if you use the requirements.txt originally provided by opal startproject ) # requirements.txt django==1.10.8 django-reversion==1.10.2 djangorestframework==3.4.7 psycopg==2.7 ffs==0.0.8.2 opal==0.10.0 requests==2.18.4 django-celery==3.2.2 celery==3.1.25 django-compressor==2.2 After re-installing (via for instance pip install -r requirements.txt ) you will likely need to make some changes to your application code to fix errors that arise as a result of upstream breaking changes. Breaking changes from dependencies The jump in Django versions introduces some breaking changes. Some common problems are outlined here. Early imports of models Importing models in a package init .py file is no longer allowed - if you see django.core.exceptions.AppRegistryNotReady this is the likely cause. Django reversion Reversion has reorganized its package structure to avoid importing models. Specifically: # Old-style import for accessing the admin class. import reversion # New-style import for accesssing admin class. from reversion.admin import VersionAdmin # Old-style import for accessing the low-level API. import reversion # New-style import for accesssing the low-level API. from reversion import revisions as reversion You should examine your admin.py to see whether you do this. Urlpatterns django.conf.urls.patterns is now removed rather than deprecated. The default urlconfs generated by older Opal versions use them, but these should now be replaced with lists. TEMPLATES setting You will need to convert to the new style TEMPLATES-* dictionary-style configuration in settings.py. Details are in the relevant section of the Django documentation . Note that Django's own context processors have moved from django.core to django.template . AUTOCOMPLETE_SEARCH setting The (previously undocumented) setting AUTOCOMPLETE_SEARCH has been renamed to OPAL_AUTOCOMPLETE_SEARCH to match other Opal settings. Update your settings.py to the new setting name if you had enabled this feature. Migrations You will need to run the migrations for Opal 0.10.0 $ python manage.py migrate opal As Opal 0.10.0 contains changes to the cascading deletion behaviour of subrecords, you will need to run a makemigrations command to update your subrecords. python manage.py makemigrations yourapp python manage.py migrate yourapp LoginRequiredMixin Django now ships with django.contrib.auth.mixins.LoginRequiredMixin . Accordingly we have removed opal.core.views.LoginRequiredMixin . A direct switch to the Django class should work seamlessly without any functional differences. CSRF_FAILURE_VIEW We now ship the opal.views.csrf_failure view which can be enabled by adding CSRF_FAILURE_VIEW = 'opal.views.csrf_failure' in your settings.py. This will redirect a user to their intended destination on a CSRF failure. This mitigates an edge case where an unauthenticated user opens two pages at the same time. Both pages will get redirected to the login form and whichever page the user logs into second will throw a CSRF failure because Django invalidates CSRF tokens on login. 0.8.3 - 0.9.0 episode.date_of_episode , episode.date_of_admission and episode.discharge_date are all deprecated. We now expect episodes to use episode.start and episode.end . You should search your codebase for any instances where the three variables are used and switch to the start/end properties. 0.8.2 - 0.8.3 No changes. 0.8.1 - 0.8.2 The application menu API, previously python dicts stored in attributes on either plugin or application subclasses, now consists of the new opal.core.menus.MenuItem class, enabling enhanced customisation and flexibility. If you previously were adding Menu Items with the dictionary format. These should be converted to use a MenuItem class. 0.8.0 - 0.8.1 Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.8.0 There are no Opal migrations for this version. PatientList.get_queryset The PatientList.get_queryset method now takes keyword arguments - at the current time it is only passed user - the user for the current request, but in the future this may be extended, so applications should consider using **kwargs to ensure this method does not raise exceptions in the future. ReopenEpisodeCtrl We've removed the undocumented ReopenEpisodeCtrl from Opal. Applications wishing to retain this functionality may copy the controller from the v0.7.1 branch (opal/static/js/opal/controllers/reopen_episode.js). However we would warn developers that this flow has proven to be problematic and confusing for users whenever used - hence the removal. 0.7.1 - 0.8.0 Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.8.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal Options Options are now an ex-API. Applications should convert to use either Referencedata (canonical terms for common data), or Metadata (App specific data you wish to pass into the front end). UI Components Those applications relying on Angular strap ui components (Typeahead, Popover, Tooltip, Datepicker, Timepicker) should convert their templates to use the Angular UI Boostrap equivalents, or the Opal templatetags. If you are simply using Opal templatetags from forms and not overriding these templates, then the transition should be seamless. Otherwise, searching your codebase for html files containing bs- and looking for angular strap components is a good start. Applications or plugins with javascript tests may need to update their includes to remove references to old library files. Full documentation of the markup and options for these components is found here extending modal_base.html We now have different base templates for modals, forms and two column modal forms (essentially a form with a side bar). The form templates add validation checks around the saving to catch any validation errors a form might through. They assume the existence of a form called 'form'. As part of this modal_base has been moved into a folder in templates called base_templates Rename any templates extending modal_base.html to extend the correct template in base_templates/ . This will be either modal_base.html or modal_form_base.html . Add episode modal url The add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash. Admin URL The Admin url has changed to require a trailing slash, so any links to /admin - for instance, in a custom menu bar, will need to be updated to /admin/ . 0.7.0 - 0.7.1 Downstream dependencies Opal 0.7.1 updates the expected version of Django Axes to 1.7.0 - you will wish to update this in your requirements.txt or similar accordingly. DRF Authentication We highly recommend that applications explicitly set Django Rest Framework authentication classes in their settings.py . By default Opal now uses session and token auth, which will require a migration to install the DRF Token authentication app. INSTALLED_APPS = ( # .... 'rest_framework', 'rest_framework.authtoken', # ... ) REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.TokenAuthentication', 'rest_framework.authentication.SessionAuthentication', ) } 6.x - 7.x Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.7.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.7.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp Breaking changes Opal 0.7 contains a number of breaking changes. Name changes opal.models.Episode.category has been re-named category_name . If your application directly sets category, you will be required to update all instances where this happens. The /episode/:pk/ API has moved to /api/v0.1/episode/:pk/ so any code (typically javascript) code that directly saves to this API endpoint rather than using the Opal JS Episode services should work immediately when re-pointed at the new URL. Moving from options to referencedata and metadata The signature of the EditItemCtrl has been updated - this modal controller no longer takes an options argument, rather it uses the new 0.7.x referencedata and metadata services. Applications that call EditItemCtrl directly should look to update the resolves option they were passing to $modal.open . (Alternatively, developers should consider refactoring to use the new recordEditor API.) The signatures of Flow enter and exit methods has changed to no longer accept options as a positional argument, and enter/exit controllers will no longer be initialized with access to options as a resolved provider. They will have access to either/both of referencedata and metadata so if your application includes custom flow controllers that use options you will need to refactor these to use the new x-data arguments instead. referencedata and metadata between them have all data previously in options, so the refactor here should be relatively painless. Date of birth fields in forms The partial partials/_date_of_birth_field.html has been removed and replaced with the {% date_of_birth_field %} templatetag in the forms library. You should update any forms to use this new tag. 5.x - 6.x Upgrading Opal How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.6.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal Changes to abstract models If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.6.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp You should note that as of Opal 0.6.x Demographics now splits names into first, surname, middle name and title. The previous name field will be converted to be first_name . Strategies for updating your data to use the appropriate fields will vary from application to application, but one good such strategy is to use a data migration such as the one done here . Update settings Many of the default Opal templates now assume that the 'opal.context_processors.models' Context Processor is available - you should add that to the TEMPLATE_CONTEXT_PROCESSORS setting in your application's settings.py The default date formats in Opal have changed - and so you should update your DATE_X settings to match: DATE_FORMAT = 'd/m/Y' DATE_INPUT_FORMATS = ['%d/%m/%Y'] DATETIME_FORMAT = 'd/m/Y H:i:s' DATETIME_INPUT_FORMATS = ['%d/%m/%Y %H:%M:%S'] Upgrade plugins A number of Opal plugins have new releases to work with the changes in Opal 0.6.x opal-referral - Upgrade to 0.1.4 opal-wardround - Upgrade to 0.6.0 opal-observations - Upgrade to 0.1.2 opal-dischargesummary - Upgrade to 0.2.0 opal-dashboard - Upgrade to 0.1.3 Meanwhile the opal-taskrunner plugin has now been deprecated, this functionality now living natively within Opal core. Update your Teams to be PatientLists Patient Lists are now driven by subclasses of opal.core.PatientList , so we will need to convert your Teams to be PatientLists. You may want to re-enable the Team admin while you do so - this is simple, by updating your application's admin.py : # yourapp/admin.py ... from opal.admin import TeamAdmin from opal.models import Team admin.site.register(Team, TeamAdmin) Patient lists are now declarative. For instance, to replicate the following team: We would convert that to: # yourapp/patient*lists.py from opal.core import patient_lists class RespiratoryList(patient_lists.TaggedPatientList): display_name = 'Respiratory' tag = 'respiratory' order = 4 schema = [models.Demographics, models.Treatment] The schema property will likely be available to you in your application's schema.py file - which is now obsolete. See the full patient list documentation for further details of the options available for Patient Lists. Form and Display templates. We may now be missing some form or display templates, as your application may be relying on templates previously in Opal. To discover which these are, run $ opal scaffold --dry-run You may either create templates by hand, or have Opal generate boilerplate templates for you by running $ opal scaffold . Modal templates already in your application will likely be referencing invalid paths to their Angular variables. You should update these to include the record name - for example: !-- Was -- {% input label= Drug model= editing.drug lookuplist= antimicrobial_list %} !-- Becomes -- {% input label= Drug model= editing.treatment.drug lookuplist= antimicrobial_list %} The Inpatient episode category The default Episode Category - Inpatient episodes has updated it's database identifier from inpatient to Inpatient . To update your episodes run : from opal.models import Episode for e in Episode.objects.filter(category='inpatient'): ... e.category='Inpatient' ... e.save() ... Any references to episode category in templates (for e.g. ng-hide) or controllers for logic will also require updates. Flow is now defined in JS Flow is no longer defined on the server side in python, but rather is a javascript service. See the documentation for information about setting up custom flows. At a minimum applications that use custom flows will have to implement their own flow service and reference it in their settings. 4.X - 5.x Migrations Before upgrading from 4.x to 5.x you should ensure that you have upgraded from South to Djangomigrations. $ rm yourapp/migrations/* $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp --fake-initial Opal Next you will need to upgrade the Opal version itself. How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. This will also update FFS and Django Axes as well as adding Python Dateutil. -e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal Migrations. Opal has fresh migrations in 0.5.x, which we should run. There are also changes to the base abstract model classes (to add created/updated timestamps) so you'll need to create fresh migrations for your own application. $ python manage.py migrate $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp At this stage you'll want to commit your new migrations, as well as any changes to your application's requirements file. Tags As of 0.5.5, old tags in Opal are stored directly on the Tagging model rather than via Django Reversion. We can import those old tags by doing the following. $ python manage.py shell from opal.models import Tagging Tagging.import_from_reversion() Deployment The first time you deploy your upgraded application you'll need to run the following commands to upgrade your database: $ python manage.py migrate --fake-initial You'll also have to repeat the Tagging step once for each deployment.","title":"Upgrading"},{"location":"reference/upgrading/#upgrading-your-opal-application","text":"This document provides instructions for specific steps required to upgrading your Opal application to a later version where there are extra steps required.","title":"Upgrading Your Opal Application"},{"location":"reference/upgrading/#v0171-v0180","text":"Style sheets loaded via Opal Applicatin or Plugin objects are now included with the attribute media=\"all\" rather than `media=\"screen\". This may affect how pages in your application print and require additional print styles.","title":"v0.17.1 -&gt; v0.18.0"},{"location":"reference/upgrading/#v0150-v0160","text":"Diagnosis.details is now a text field. Please make and run migrations if you are using it in your app. The record template for diagnosis now shows the details on the next row.","title":"v0.15.0 -&gt; v0.16.0"},{"location":"reference/upgrading/#0131-0140","text":"If you were creating a UserProfile, this will now fail as a UserProfile is created automatically after creating a user (by a signal).","title":"0.13.1 -&gt; 0.14.0"},{"location":"reference/upgrading/#0130-0131","text":"Upgrades django (minor security upgrade). How you do this depends on how you have configured your application. You will need to update both the Opal version, and versions of upgraded dependencies if you have specified them in for instance, a requirements.txt. (This will be the case if you use the requirements.txt originally provided by opal startproject ) # requirements.txt opal==0.13.1 django==2.0.13","title":"0.13.0 -&gt; 0.13.1"},{"location":"reference/upgrading/#0120-0112-0130","text":"","title":"0.12.0 - 0.11.2 -&gt; 0.13.0"},{"location":"reference/upgrading/#python-versions","text":"Opal 0.13.0 drops support for Python 2.x If you have not already done so, you will need to upgrade your application to Python 3 in order to upgrade. You may also like to run the tests for your application with the 'show warnings' flag e.g. python -Wd manage.py test","title":"Python versions"},{"location":"reference/upgrading/#upgrading-opal","text":"How you do this depends on how you have configured your application. You will need to update both the Opal version, and versions of upgraded dependencies if you have specified them in for instance, a requirements.txt. (This will be the case if you use the requirements.txt originally provided by opal startproject ) # requirements.txt opal==0.13.0 django==2.0.9 django-reversion==3.0.1 djangorestframework==3.7.4 letter==0.5 psycopg==2.7.6.1 python-dateutil==2.7.5 requests=2.20.1","title":"Upgrading Opal"},{"location":"reference/upgrading/#free-text-or-foreign-key-fields-are-now-by-default-case-insensitive","text":"It is recommended you resave all model values for fk_or_ft fields as this will give you consistent behaviour. Otherwise fk_ft values wihch differ from fkt values only by case prior to this upgrade will be stored as ft and those afterwards will be stored as the relevant fk.","title":"Free text or foreign key fields are now, by default case insensitive"},{"location":"reference/upgrading/#migrations","text":"You will need to run the migrations for Opal 0.13.0 $ python manage.py migrate opal As Opal 0.13.0 contains changes to the definition of lookuplists, you will need to run a makemigrations command to update your lookuplists to enable code values and change case sensitivity. python manage.py makemigrations yourapp python manage.py migrate yourapp","title":"Migrations"},{"location":"reference/upgrading/#0111-0112","text":"This bugfix release should be entirely backwards compatible.","title":"0.11.1 -&gt; 0.11.2"},{"location":"reference/upgrading/#0110-0111","text":"This bugfix release should be entirely backwards compatible.","title":"0.11.0 -&gt; 0.11.1"},{"location":"reference/upgrading/#0101-0110","text":"Please upgrade django-compressor version to 2.2, ie update your requirements to","title":"0.10.1 -&gt; 0.11.0"},{"location":"reference/upgrading/#requirementstxt","text":"django-compressor==2.2","title":"requirements.txt"},{"location":"reference/upgrading/#0100-0101","text":"","title":"0.10.0 -&gt; 0.10.1"},{"location":"reference/upgrading/#upgrading-opal_1","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.10.1 There are no migrations or additional commands for this upgrae, and we are not aware of any backwards incompatible changes.","title":"Upgrading Opal"},{"location":"reference/upgrading/#090-0100","text":"","title":"0.9.0 -&gt; 0.10.0"},{"location":"reference/upgrading/#upgrading-opal_2","text":"How you do this depends on how you have configured your application. You will need to update both the Opal version, and versions of dependencies upgraded dependencies if you have specified them in for instance, a requirements.txt. (This will be the case if you use the requirements.txt originally provided by opal startproject ) # requirements.txt django==1.10.8 django-reversion==1.10.2 djangorestframework==3.4.7 psycopg==2.7 ffs==0.0.8.2 opal==0.10.0 requests==2.18.4 django-celery==3.2.2 celery==3.1.25 django-compressor==2.2 After re-installing (via for instance pip install -r requirements.txt ) you will likely need to make some changes to your application code to fix errors that arise as a result of upstream breaking changes.","title":"Upgrading Opal"},{"location":"reference/upgrading/#breaking-changes-from-dependencies","text":"The jump in Django versions introduces some breaking changes. Some common problems are outlined here. Early imports of models Importing models in a package init .py file is no longer allowed - if you see django.core.exceptions.AppRegistryNotReady this is the likely cause. Django reversion Reversion has reorganized its package structure to avoid importing models. Specifically: # Old-style import for accessing the admin class. import reversion # New-style import for accesssing admin class. from reversion.admin import VersionAdmin # Old-style import for accessing the low-level API. import reversion # New-style import for accesssing the low-level API. from reversion import revisions as reversion You should examine your admin.py to see whether you do this. Urlpatterns django.conf.urls.patterns is now removed rather than deprecated. The default urlconfs generated by older Opal versions use them, but these should now be replaced with lists. TEMPLATES setting You will need to convert to the new style TEMPLATES-* dictionary-style configuration in settings.py. Details are in the relevant section of the Django documentation . Note that Django's own context processors have moved from django.core to django.template . AUTOCOMPLETE_SEARCH setting The (previously undocumented) setting AUTOCOMPLETE_SEARCH has been renamed to OPAL_AUTOCOMPLETE_SEARCH to match other Opal settings. Update your settings.py to the new setting name if you had enabled this feature.","title":"Breaking changes from dependencies"},{"location":"reference/upgrading/#migrations_1","text":"You will need to run the migrations for Opal 0.10.0 $ python manage.py migrate opal As Opal 0.10.0 contains changes to the cascading deletion behaviour of subrecords, you will need to run a makemigrations command to update your subrecords. python manage.py makemigrations yourapp python manage.py migrate yourapp","title":"Migrations"},{"location":"reference/upgrading/#loginrequiredmixin","text":"Django now ships with django.contrib.auth.mixins.LoginRequiredMixin . Accordingly we have removed opal.core.views.LoginRequiredMixin . A direct switch to the Django class should work seamlessly without any functional differences.","title":"LoginRequiredMixin"},{"location":"reference/upgrading/#csrf_failure_view","text":"We now ship the opal.views.csrf_failure view which can be enabled by adding CSRF_FAILURE_VIEW = 'opal.views.csrf_failure' in your settings.py. This will redirect a user to their intended destination on a CSRF failure. This mitigates an edge case where an unauthenticated user opens two pages at the same time. Both pages will get redirected to the login form and whichever page the user logs into second will throw a CSRF failure because Django invalidates CSRF tokens on login.","title":"CSRF_FAILURE_VIEW"},{"location":"reference/upgrading/#083-090","text":"episode.date_of_episode , episode.date_of_admission and episode.discharge_date are all deprecated. We now expect episodes to use episode.start and episode.end . You should search your codebase for any instances where the three variables are used and switch to the start/end properties.","title":"0.8.3 -&gt; 0.9.0"},{"location":"reference/upgrading/#082-083","text":"No changes.","title":"0.8.2 -&gt; 0.8.3"},{"location":"reference/upgrading/#081-082","text":"The application menu API, previously python dicts stored in attributes on either plugin or application subclasses, now consists of the new opal.core.menus.MenuItem class, enabling enhanced customisation and flexibility. If you previously were adding Menu Items with the dictionary format. These should be converted to use a MenuItem class.","title":"0.8.1 -&gt; 0.8.2"},{"location":"reference/upgrading/#080-081","text":"","title":"0.8.0 -&gt; 0.8.1"},{"location":"reference/upgrading/#upgrading-opal_3","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.8.0 There are no Opal migrations for this version.","title":"Upgrading Opal"},{"location":"reference/upgrading/#patientlistget_queryset","text":"The PatientList.get_queryset method now takes keyword arguments - at the current time it is only passed user - the user for the current request, but in the future this may be extended, so applications should consider using **kwargs to ensure this method does not raise exceptions in the future.","title":"PatientList.get_queryset"},{"location":"reference/upgrading/#reopenepisodectrl","text":"We've removed the undocumented ReopenEpisodeCtrl from Opal. Applications wishing to retain this functionality may copy the controller from the v0.7.1 branch (opal/static/js/opal/controllers/reopen_episode.js). However we would warn developers that this flow has proven to be problematic and confusing for users whenever used - hence the removal.","title":"ReopenEpisodeCtrl"},{"location":"reference/upgrading/#071-080","text":"","title":"0.7.1 -&gt; 0.8.0"},{"location":"reference/upgrading/#upgrading-opal_4","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.8.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal","title":"Upgrading Opal"},{"location":"reference/upgrading/#options","text":"Options are now an ex-API. Applications should convert to use either Referencedata (canonical terms for common data), or Metadata (App specific data you wish to pass into the front end).","title":"Options"},{"location":"reference/upgrading/#ui-components","text":"Those applications relying on Angular strap ui components (Typeahead, Popover, Tooltip, Datepicker, Timepicker) should convert their templates to use the Angular UI Boostrap equivalents, or the Opal templatetags. If you are simply using Opal templatetags from forms and not overriding these templates, then the transition should be seamless. Otherwise, searching your codebase for html files containing bs- and looking for angular strap components is a good start. Applications or plugins with javascript tests may need to update their includes to remove references to old library files. Full documentation of the markup and options for these components is found here","title":"UI Components"},{"location":"reference/upgrading/#extending-modal_basehtml","text":"We now have different base templates for modals, forms and two column modal forms (essentially a form with a side bar). The form templates add validation checks around the saving to catch any validation errors a form might through. They assume the existence of a form called 'form'. As part of this modal_base has been moved into a folder in templates called base_templates Rename any templates extending modal_base.html to extend the correct template in base_templates/ . This will be either modal_base.html or modal_form_base.html .","title":"extending modal_base.html"},{"location":"reference/upgrading/#add-episode-modal-url","text":"The add episode modal previously available at /templates/modals/add_episode.html/ is now not available at the url with a trailing slash. Any controllers attempting to open the modal e.g. custom list flows should update their $modal.open call to remove the trailing slash.","title":"Add episode modal url"},{"location":"reference/upgrading/#admin-url","text":"The Admin url has changed to require a trailing slash, so any links to /admin - for instance, in a custom menu bar, will need to be updated to /admin/ .","title":"Admin URL"},{"location":"reference/upgrading/#070-071","text":"","title":"0.7.0 -&gt; 0.7.1"},{"location":"reference/upgrading/#downstream-dependencies","text":"Opal 0.7.1 updates the expected version of Django Axes to 1.7.0 - you will wish to update this in your requirements.txt or similar accordingly.","title":"Downstream dependencies"},{"location":"reference/upgrading/#drf-authentication","text":"We highly recommend that applications explicitly set Django Rest Framework authentication classes in their settings.py . By default Opal now uses session and token auth, which will require a migration to install the DRF Token authentication app. INSTALLED_APPS = ( # .... 'rest_framework', 'rest_framework.authtoken', # ... ) REST_FRAMEWORK = { 'DEFAULT_AUTHENTICATION_CLASSES': ( 'rest_framework.authentication.TokenAuthentication', 'rest_framework.authentication.SessionAuthentication', ) }","title":"DRF Authentication"},{"location":"reference/upgrading/#6x-7x","text":"","title":"6.x -&gt; 7.x"},{"location":"reference/upgrading/#upgrading-opal_5","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.7.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.7.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp","title":"Upgrading Opal"},{"location":"reference/upgrading/#breaking-changes","text":"Opal 0.7 contains a number of breaking changes.","title":"Breaking changes"},{"location":"reference/upgrading/#name-changes","text":"opal.models.Episode.category has been re-named category_name . If your application directly sets category, you will be required to update all instances where this happens. The /episode/:pk/ API has moved to /api/v0.1/episode/:pk/ so any code (typically javascript) code that directly saves to this API endpoint rather than using the Opal JS Episode services should work immediately when re-pointed at the new URL.","title":"Name changes"},{"location":"reference/upgrading/#moving-from-options-to-referencedata-and-metadata","text":"The signature of the EditItemCtrl has been updated - this modal controller no longer takes an options argument, rather it uses the new 0.7.x referencedata and metadata services. Applications that call EditItemCtrl directly should look to update the resolves option they were passing to $modal.open . (Alternatively, developers should consider refactoring to use the new recordEditor API.) The signatures of Flow enter and exit methods has changed to no longer accept options as a positional argument, and enter/exit controllers will no longer be initialized with access to options as a resolved provider. They will have access to either/both of referencedata and metadata so if your application includes custom flow controllers that use options you will need to refactor these to use the new x-data arguments instead. referencedata and metadata between them have all data previously in options, so the refactor here should be relatively painless.","title":"Moving from options to referencedata and metadata"},{"location":"reference/upgrading/#date-of-birth-fields-in-forms","text":"The partial partials/_date_of_birth_field.html has been removed and replaced with the {% date_of_birth_field %} templatetag in the forms library. You should update any forms to use this new tag.","title":"Date of birth fields in forms"},{"location":"reference/upgrading/#5x-6x","text":"","title":"5.x -&gt; 6.x"},{"location":"reference/upgrading/#upgrading-opal_6","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.6.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for Opal 0.6.x $ python manage.py migrate opal","title":"Upgrading Opal"},{"location":"reference/upgrading/#changes-to-abstract-models","text":"If you are inheriting from the abstract models in Opal e.g. Demographics then you should run a makemigrations command to update to the 0.6.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp You should note that as of Opal 0.6.x Demographics now splits names into first, surname, middle name and title. The previous name field will be converted to be first_name . Strategies for updating your data to use the appropriate fields will vary from application to application, but one good such strategy is to use a data migration such as the one done here .","title":"Changes to abstract models"},{"location":"reference/upgrading/#update-settings","text":"Many of the default Opal templates now assume that the 'opal.context_processors.models' Context Processor is available - you should add that to the TEMPLATE_CONTEXT_PROCESSORS setting in your application's settings.py The default date formats in Opal have changed - and so you should update your DATE_X settings to match: DATE_FORMAT = 'd/m/Y' DATE_INPUT_FORMATS = ['%d/%m/%Y'] DATETIME_FORMAT = 'd/m/Y H:i:s' DATETIME_INPUT_FORMATS = ['%d/%m/%Y %H:%M:%S']","title":"Update settings"},{"location":"reference/upgrading/#upgrade-plugins","text":"A number of Opal plugins have new releases to work with the changes in Opal 0.6.x opal-referral - Upgrade to 0.1.4 opal-wardround - Upgrade to 0.6.0 opal-observations - Upgrade to 0.1.2 opal-dischargesummary - Upgrade to 0.2.0 opal-dashboard - Upgrade to 0.1.3 Meanwhile the opal-taskrunner plugin has now been deprecated, this functionality now living natively within Opal core.","title":"Upgrade plugins"},{"location":"reference/upgrading/#update-your-teams-to-be-patientlists","text":"Patient Lists are now driven by subclasses of opal.core.PatientList , so we will need to convert your Teams to be PatientLists. You may want to re-enable the Team admin while you do so - this is simple, by updating your application's admin.py : # yourapp/admin.py ... from opal.admin import TeamAdmin from opal.models import Team admin.site.register(Team, TeamAdmin) Patient lists are now declarative. For instance, to replicate the following team: We would convert that to: # yourapp/patient*lists.py from opal.core import patient_lists class RespiratoryList(patient_lists.TaggedPatientList): display_name = 'Respiratory' tag = 'respiratory' order = 4 schema = [models.Demographics, models.Treatment] The schema property will likely be available to you in your application's schema.py file - which is now obsolete. See the full patient list documentation for further details of the options available for Patient Lists.","title":"Update your Teams to be PatientLists"},{"location":"reference/upgrading/#form-and-display-templates","text":"We may now be missing some form or display templates, as your application may be relying on templates previously in Opal. To discover which these are, run $ opal scaffold --dry-run You may either create templates by hand, or have Opal generate boilerplate templates for you by running $ opal scaffold . Modal templates already in your application will likely be referencing invalid paths to their Angular variables. You should update these to include the record name - for example: !-- Was -- {% input label= Drug model= editing.drug lookuplist= antimicrobial_list %} !-- Becomes -- {% input label= Drug model= editing.treatment.drug lookuplist= antimicrobial_list %}","title":"Form and Display templates."},{"location":"reference/upgrading/#the-inpatient-episode-category","text":"The default Episode Category - Inpatient episodes has updated it's database identifier from inpatient to Inpatient . To update your episodes run : from opal.models import Episode for e in Episode.objects.filter(category='inpatient'): ... e.category='Inpatient' ... e.save() ... Any references to episode category in templates (for e.g. ng-hide) or controllers for logic will also require updates.","title":"The Inpatient episode category"},{"location":"reference/upgrading/#flow-is-now-defined-in-js","text":"Flow is no longer defined on the server side in python, but rather is a javascript service. See the documentation for information about setting up custom flows. At a minimum applications that use custom flows will have to implement their own flow service and reference it in their settings.","title":"Flow is now defined in JS"},{"location":"reference/upgrading/#4x-5x","text":"","title":"4.X -&gt; 5.x"},{"location":"reference/upgrading/#migrations_2","text":"Before upgrading from 4.x to 5.x you should ensure that you have upgraded from South to Djangomigrations. $ rm yourapp/migrations/* $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp --fake-initial","title":"Migrations"},{"location":"reference/upgrading/#opal","text":"Next you will need to upgrade the Opal version itself. How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. This will also update FFS and Django Axes as well as adding Python Dateutil. -e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal","title":"Opal"},{"location":"reference/upgrading/#migrations_3","text":"Opal has fresh migrations in 0.5.x, which we should run. There are also changes to the base abstract model classes (to add created/updated timestamps) so you'll need to create fresh migrations for your own application. $ python manage.py migrate $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp At this stage you'll want to commit your new migrations, as well as any changes to your application's requirements file.","title":"Migrations."},{"location":"reference/upgrading/#tags","text":"As of 0.5.5, old tags in Opal are stored directly on the Tagging model rather than via Django Reversion. We can import those old tags by doing the following. $ python manage.py shell from opal.models import Tagging Tagging.import_from_reversion()","title":"Tags"},{"location":"reference/upgrading/#deployment","text":"The first time you deploy your upgraded application you'll need to run the following commands to upgrade your database: $ python manage.py migrate --fake-initial You'll also have to repeat the Tagging step once for each deployment.","title":"Deployment"},{"location":"reference/user_profile_model/","text":"opal.models.UserProfile The model which stores individual user profile information. Methods UserProfile.get_avatar_url Return the URL at which the avatar for this user may be found. Uses the User email address if it exists or the username to locate a Gravatar URL. profile = UserProfile.objects.get(pk=1) profile.get_avatar_url() # http://gravatar....","title":"UserProfile"},{"location":"reference/user_profile_model/#opalmodelsuserprofile","text":"The model which stores individual user profile information.","title":"opal.models.UserProfile"},{"location":"reference/user_profile_model/#methods","text":"","title":"Methods"},{"location":"reference/user_profile_model/#userprofileget_avatar_url","text":"Return the URL at which the avatar for this user may be found. Uses the User email address if it exists or the username to locate a Gravatar URL. profile = UserProfile.objects.get(pk=1) profile.get_avatar_url() # http://gravatar....","title":"UserProfile.get_avatar_url"},{"location":"reference/utils/","text":"opal.utils The opal.utils module contains a number of helpful python utilities. find_template( template_list ) Given an iterable of template paths, return the first one that exists on our template path or None. find_template(['not_a_real_template.html']) None write( what ) Writes the argument to sys.stdout unless it detects an active test run. If run during tests, it should do nothing. Used by Opal for chatty commandline utilities that should be quieter during test runs. write('hai') hai","title":"Utils module"},{"location":"reference/utils/#opalutils","text":"The opal.utils module contains a number of helpful python utilities.","title":"opal.utils"},{"location":"reference/utils/#find_template-template_list","text":"Given an iterable of template paths, return the first one that exists on our template path or None. find_template(['not_a_real_template.html']) None","title":"find_template( template_list )"},{"location":"reference/utils/#write-what","text":"Writes the argument to sys.stdout unless it detects an active test run. If run during tests, it should do nothing. Used by Opal for chatty commandline utilities that should be quieter during test runs. write('hai') hai","title":"write( what )"},{"location":"reference/javascript/episode_service/","text":"The Episode service The Episode service in opal.services provides us with core functionality related to interacting with episodes in the client. Constructor The Episode service is instantiated with the Episode data that comes back from the Episode JSON API. var episode = new Episode(json_data); Methods Episode.getTags Return a list of the current tags this episode has as strings. episode.getTags(); // ['mine', 'infectioncontrol'] Episode.getFullName Return a human readable version of the Patient name suitable for rendering. episode.getFullName() // - 'Jane Doe' Episode.hasTag Predicate function that determines whether the episode is tagged with a given tag. Arguments: tag : The tag you are interested in. Episode.newItem Instantiate a new subrecord for this episode of a given type. Arguments: recordName : The name of the type of record you want to instantiate. Example usage: episode.newItem('diagnosis'); // item (an Item() instance. Episode.recordEditor.newItem(name) Takes a string, opens a modal from which the user can create a new subrecord of type name . It takes the optional argument of url which is the url of the template to be opened. This defaults to the modal form template for the subrecord of name . episode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save Episode.recordEditor.editItem(name, item) Open a modal from which the user may edit the item of type name . It takes the optional argument of url which is the url of the template to be opened. This defaults to the modal form template for the subrecord of name . episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis","title":"Episode service"},{"location":"reference/javascript/episode_service/#the-episode-service","text":"The Episode service in opal.services provides us with core functionality related to interacting with episodes in the client.","title":"The Episode service"},{"location":"reference/javascript/episode_service/#constructor","text":"The Episode service is instantiated with the Episode data that comes back from the Episode JSON API. var episode = new Episode(json_data);","title":"Constructor"},{"location":"reference/javascript/episode_service/#methods","text":"","title":"Methods"},{"location":"reference/javascript/episode_service/#episodegettags","text":"Return a list of the current tags this episode has as strings. episode.getTags(); // ['mine', 'infectioncontrol']","title":"Episode.getTags"},{"location":"reference/javascript/episode_service/#episodegetfullname","text":"Return a human readable version of the Patient name suitable for rendering. episode.getFullName() // - 'Jane Doe'","title":"Episode.getFullName"},{"location":"reference/javascript/episode_service/#episodehastag","text":"Predicate function that determines whether the episode is tagged with a given tag. Arguments: tag : The tag you are interested in.","title":"Episode.hasTag"},{"location":"reference/javascript/episode_service/#episodenewitem","text":"Instantiate a new subrecord for this episode of a given type. Arguments: recordName : The name of the type of record you want to instantiate. Example usage: episode.newItem('diagnosis'); // item (an Item() instance.","title":"Episode.newItem"},{"location":"reference/javascript/episode_service/#episoderecordeditornewitemname","text":"Takes a string, opens a modal from which the user can create a new subrecord of type name . It takes the optional argument of url which is the url of the template to be opened. This defaults to the modal form template for the subrecord of name . episode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save","title":"Episode.recordEditor.newItem(name)"},{"location":"reference/javascript/episode_service/#episoderecordeditoredititemname-item","text":"Open a modal from which the user may edit the item of type name . It takes the optional argument of url which is the url of the template to be opened. This defaults to the modal form template for the subrecord of name . episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis","title":"Episode.recordEditor.editItem(name, item)"},{"location":"reference/javascript/item_service/","text":"The Item service The Item service in opal.services provides us with core functionality related to interacting with subrecord in the client. Methods Item.makeCopy Returns a clone of the editable fields + consistency token so that we can then update them in isolation elsewhere. Item.save Saves attributes to the server. item.save(data_to_save); Item.formController The Angular controller used by the modal that is opened when you edit this item to allow custom logic. Defaults to 'EditItemCtrl';","title":"Item service"},{"location":"reference/javascript/item_service/#the-item-service","text":"The Item service in opal.services provides us with core functionality related to interacting with subrecord in the client.","title":"The Item service"},{"location":"reference/javascript/item_service/#methods","text":"","title":"Methods"},{"location":"reference/javascript/item_service/#itemmakecopy","text":"Returns a clone of the editable fields + consistency token so that we can then update them in isolation elsewhere.","title":"Item.makeCopy"},{"location":"reference/javascript/item_service/#itemsave","text":"Saves attributes to the server. item.save(data_to_save);","title":"Item.save"},{"location":"reference/javascript/item_service/#itemformcontroller","text":"The Angular controller used by the modal that is opened when you edit this item to allow custom logic. Defaults to 'EditItemCtrl';","title":"Item.formController"},{"location":"reference/javascript/javascript_dependencies/","text":"Opal Javascript Dependencies Opal makes use of a number of upstream dependencies which are available for developers to use in building applications. | -|- Modernizr | Opal has a custom modernizr build that detects touch events Jquery | 1.11.3 Angular | 1.5.8 Angular-ui-select | 0.19.4 Underscore.js | 1.8.3 D3 | 3.5.6 C3 | 0.4.10","title":"Javascript dependencies"},{"location":"reference/javascript/javascript_dependencies/#opal-javascript-dependencies","text":"Opal makes use of a number of upstream dependencies which are available for developers to use in building applications. | -|- Modernizr | Opal has a custom modernizr build that detects touch events Jquery | 1.11.3 Angular | 1.5.8 Angular-ui-select | 0.19.4 Underscore.js | 1.8.3 D3 | 3.5.6 C3 | 0.4.10","title":"Opal Javascript Dependencies"},{"location":"reference/javascript/javascript_helpers/","text":"Opal Javascript Helpers $rootScope methods Opal provides some methods on the Angular $rootScope object. open_modal $rootScope.open_modal(controller, template, {episode: episode}) Open an arbitrary controller in a modal, passing in the name of the controller, the url for the template. You may also pass through a dictionary of items to resolve. Angular Directives Opal provides some built-in Angular directives for your project to use. date-of-birth Creates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old. tag-select Creates a multi select box where users can remove or add tags. Only tags set as direct_add tags can be set here. This property is set on individual PatientList subclasses, and passed to the front end with the Metadata service. We set the Angular model to be a copy of an episode's tagging. $scope.editing.tagging = episode.tagging[0].makeCopy(); We can instantiate the tag-select widget in our markup as follows. div tag-select ng-model= editing.tagging metadata= metadata class= col-sm-8 /div Note: this directive will load the Metadata service over HTTP if it has not been loaded already. one-click-only A directive that if set with no arguments, or set to true, will only allow a button to be clicked on once and then it'll be disabled. Useful for example to make sure that multiple save requests aren't accidentally triggered. check-form Similar to one click only but it takes the form in use as an argument e.g. button check-form= form ng-click= sendDataToTheServer click me /button This checks the form for valid on click. If the form is then not valid. It will not call the second function, but mark the form as submitted and disable the button. It will watch for the form to become valid and enable the button when that happens. If the form is valid, it will allow the ng-click function to be called. This means that if you only want to show error messages after the user has clicked the save button you can do so with the form.$submitted variable. scroll-top Adds a click handler to the element that when click will animate the body of the element to scroll to the top go-to-top Similar to scroll-top, this moves the scroll bar to the top of the page but doesn't animate the transition. copy to clipboard e.g. button clipboard data-clipboard-target= #content-to-copy Copy to Clipboard /button This is a wrapper around clipboard.js, it lets the user copy text from an element that matches the selector you pass it. It will present a growl message saying that the text has been copied. fullNameForUser Given a User ID, inserts the full name of a user into the element the directive is on span full-name-for-user= 2 /span !-- Becomes -- span Jane Doe /span avatarForUser Intended for use on an img tag, given a User ID, sets the src attribute to the correct avatar URL. img avatar-for-user= 1 / !-- Becomes -- img src= http://gravatar.com..... / Angular Filters Opal provides some built-in Angular filters for your project to use. Age Calculates a persons current age from their date of birth hhmm Displays the hours minutes portion of a javascript Date object as HH:MM moment-date-filter Allows a us to use moment.js formatters in the template exactly like you would use moment.format short-date Displays a date as DD/MM if it's this year, else DD/MM/YYYY short-date-time Displays a date time, short date as above and time as in hhmm above title Converts a string to title case upper Converts a string to upper case underscore-to-spaces Converts strings with underscores (e.g. variable names etc) to words with spaces. [[ 'some_underscore_string' | underscore-to-spaces ]] - some underscore string Angular HTTP Interceptors Opal uses opal.services.LogoutInterceptor to intercept all failed responses from the server. If they're a 401 or a 403 we redirect the user to the login page, otherwise it passes them through.","title":"Javascript helpers"},{"location":"reference/javascript/javascript_helpers/#opal-javascript-helpers","text":"","title":"Opal Javascript Helpers"},{"location":"reference/javascript/javascript_helpers/#rootscope-methods","text":"Opal provides some methods on the Angular $rootScope object.","title":"$rootScope methods"},{"location":"reference/javascript/javascript_helpers/#open_modal","text":"$rootScope.open_modal(controller, template, {episode: episode}) Open an arbitrary controller in a modal, passing in the name of the controller, the url for the template. You may also pass through a dictionary of items to resolve.","title":"open_modal"},{"location":"reference/javascript/javascript_helpers/#angular-directives","text":"Opal provides some built-in Angular directives for your project to use.","title":"Angular Directives"},{"location":"reference/javascript/javascript_helpers/#date-of-birth","text":"Creates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old.","title":"date-of-birth"},{"location":"reference/javascript/javascript_helpers/#tag-select","text":"Creates a multi select box where users can remove or add tags. Only tags set as direct_add tags can be set here. This property is set on individual PatientList subclasses, and passed to the front end with the Metadata service. We set the Angular model to be a copy of an episode's tagging. $scope.editing.tagging = episode.tagging[0].makeCopy(); We can instantiate the tag-select widget in our markup as follows. div tag-select ng-model= editing.tagging metadata= metadata class= col-sm-8 /div Note: this directive will load the Metadata service over HTTP if it has not been loaded already.","title":"tag-select"},{"location":"reference/javascript/javascript_helpers/#one-click-only","text":"A directive that if set with no arguments, or set to true, will only allow a button to be clicked on once and then it'll be disabled. Useful for example to make sure that multiple save requests aren't accidentally triggered.","title":"one-click-only"},{"location":"reference/javascript/javascript_helpers/#check-form","text":"Similar to one click only but it takes the form in use as an argument e.g. button check-form= form ng-click= sendDataToTheServer click me /button This checks the form for valid on click. If the form is then not valid. It will not call the second function, but mark the form as submitted and disable the button. It will watch for the form to become valid and enable the button when that happens. If the form is valid, it will allow the ng-click function to be called. This means that if you only want to show error messages after the user has clicked the save button you can do so with the form.$submitted variable.","title":"check-form"},{"location":"reference/javascript/javascript_helpers/#scroll-top","text":"Adds a click handler to the element that when click will animate the body of the element to scroll to the top","title":"scroll-top"},{"location":"reference/javascript/javascript_helpers/#go-to-top","text":"Similar to scroll-top, this moves the scroll bar to the top of the page but doesn't animate the transition.","title":"go-to-top"},{"location":"reference/javascript/javascript_helpers/#copy-to-clipboard","text":"","title":"copy to clipboard"},{"location":"reference/javascript/javascript_helpers/#eg","text":"button clipboard data-clipboard-target= #content-to-copy Copy to Clipboard /button This is a wrapper around clipboard.js, it lets the user copy text from an element that matches the selector you pass it. It will present a growl message saying that the text has been copied.","title":"e.g."},{"location":"reference/javascript/javascript_helpers/#fullnameforuser","text":"Given a User ID, inserts the full name of a user into the element the directive is on span full-name-for-user= 2 /span !-- Becomes -- span Jane Doe /span","title":"fullNameForUser"},{"location":"reference/javascript/javascript_helpers/#avatarforuser","text":"Intended for use on an img tag, given a User ID, sets the src attribute to the correct avatar URL. img avatar-for-user= 1 / !-- Becomes -- img src= http://gravatar.com..... /","title":"avatarForUser"},{"location":"reference/javascript/javascript_helpers/#angular-filters","text":"Opal provides some built-in Angular filters for your project to use.","title":"Angular Filters"},{"location":"reference/javascript/javascript_helpers/#age","text":"Calculates a persons current age from their date of birth","title":"Age"},{"location":"reference/javascript/javascript_helpers/#hhmm","text":"Displays the hours minutes portion of a javascript Date object as HH:MM","title":"hhmm"},{"location":"reference/javascript/javascript_helpers/#moment-date-filter","text":"Allows a us to use moment.js formatters in the template exactly like you would use moment.format","title":"moment-date-filter"},{"location":"reference/javascript/javascript_helpers/#short-date","text":"Displays a date as DD/MM if it's this year, else DD/MM/YYYY","title":"short-date"},{"location":"reference/javascript/javascript_helpers/#short-date-time","text":"Displays a date time, short date as above and time as in hhmm above","title":"short-date-time"},{"location":"reference/javascript/javascript_helpers/#title","text":"Converts a string to title case","title":"title"},{"location":"reference/javascript/javascript_helpers/#upper","text":"Converts a string to upper case","title":"upper"},{"location":"reference/javascript/javascript_helpers/#underscore-to-spaces","text":"Converts strings with underscores (e.g. variable names etc) to words with spaces. [[ 'some_underscore_string' | underscore-to-spaces ]] - some underscore string","title":"underscore-to-spaces"},{"location":"reference/javascript/javascript_helpers/#angular-http-interceptors","text":"Opal uses opal.services.LogoutInterceptor to intercept all failed responses from the server. If they're a 401 or a 403 we redirect the user to the login page, otherwise it passes them through.","title":"Angular HTTP Interceptors"},{"location":"reference/javascript/loaders/","text":"The Patient List Loader service The patientListLoader service in opal.services provides a function that will get the episodes from a previously defined patient list By default this will be the tag in the route params, alternatively you can pass in a tag. The Episode Loader service Loads in an episode from an id, either passed in, or as the parameter of 'id' on the current route. It casts it to an Episode The Patient Loader service Loads in a patient from the patient id, either passed in, or as the parameter of 'patient_id' on the current route. It casts it to an Patient","title":"Loaders"},{"location":"reference/javascript/loaders/#the-patient-list-loader-service","text":"The patientListLoader service in opal.services provides a function that will get the episodes from a previously defined patient list By default this will be the tag in the route params, alternatively you can pass in a tag.","title":"The Patient List Loader service"},{"location":"reference/javascript/loaders/#the-episode-loader-service","text":"Loads in an episode from an id, either passed in, or as the parameter of 'id' on the current route. It casts it to an Episode","title":"The Episode Loader service"},{"location":"reference/javascript/loaders/#the-patient-loader-service","text":"Loads in a patient from the patient id, either passed in, or as the parameter of 'patient_id' on the current route. It casts it to an Patient","title":"The Patient Loader service"},{"location":"reference/javascript/patient_service/","text":"The Patient service The Patient service in opal.services is the client side representation of a patient model. Constructor The Patient service is instantiated with the Patient data that comes back from the Patient JSON API. It will cast any Episode data to Episode objects, and any PatientSubrecord data to Item objects var patient = new Patient(json_data)","title":"Patient service"},{"location":"reference/javascript/patient_service/#the-patient-service","text":"The Patient service in opal.services is the client side representation of a patient model.","title":"The Patient service"},{"location":"reference/javascript/patient_service/#constructor","text":"The Patient service is instantiated with the Patient data that comes back from the Patient JSON API. It will cast any Episode data to Episode objects, and any PatientSubrecord data to Item objects var patient = new Patient(json_data)","title":"Constructor"},{"location":"reference/javascript/patient_summary_service/","text":"The PatientSummary service The PatientSummary service in opal.services provides us with core functionality related to interacting with patient search results in the client. Constructor The PatientSummary service is instantiated with the Patient search result data that comes back from the Patient search JSON API. var patient_summary = new PatientSummary(json_data);","title":"Patient summary service"},{"location":"reference/javascript/patient_summary_service/#the-patientsummary-service","text":"The PatientSummary service in opal.services provides us with core functionality related to interacting with patient search results in the client.","title":"The PatientSummary service"},{"location":"reference/javascript/patient_summary_service/#constructor","text":"The PatientSummary service is instantiated with the Patient search result data that comes back from the Patient search JSON API. var patient_summary = new PatientSummary(json_data);","title":"Constructor"},{"location":"reference/javascript/search_js_services/","text":"Opal Core Search Javascript Services Filter The Angular Service for saved filters. Maps to the model opal.models.Filter . save(attrs) Save this filter with the attributes passed in. If there is no ID, this is taken to be a create. destroy() Destroy this filter. filtersLoader Loader service that will resolve with instantiated Filter objects for each of the current user's filters. FilterResource Angular $resource for Filter objects.","title":"Search JS Services"},{"location":"reference/javascript/search_js_services/#opal-core-search-javascript-services","text":"","title":"Opal Core Search Javascript Services"},{"location":"reference/javascript/search_js_services/#filter","text":"The Angular Service for saved filters. Maps to the model opal.models.Filter .","title":"Filter"},{"location":"reference/javascript/search_js_services/#saveattrs","text":"Save this filter with the attributes passed in. If there is no ID, this is taken to be a create.","title":"save(attrs)"},{"location":"reference/javascript/search_js_services/#destroy","text":"Destroy this filter.","title":"destroy()"},{"location":"reference/javascript/search_js_services/#filtersloader","text":"Loader service that will resolve with instantiated Filter objects for each of the current user's filters.","title":"filtersLoader"},{"location":"reference/javascript/search_js_services/#filterresource","text":"Angular $resource for Filter objects.","title":"FilterResource"},{"location":"reference/javascript/test_helper/","text":"The Test Helper Service Opal provides a utility to help you test javascript unit tests. To bring it in, import the module and inject the service. var testHelper; beforeEach(function(){ module('opal.controllers'); inject(function($injector){ testHelper = $injector.get('testHelper'); }); }); The helper has the following functions. newEpisode provides a new episode. It needs to passed in rootScope as part of getting a new episode we update the rootSchema to have the schema information about subrecords. One can pass in an optional dictionary as the second argument as the args to make the episode. Otherwise it will be created with the data from getEpisodeData . getEpisodeData provides the raw data as pull in from the episode api. newPatient provides a new patient. It needs to be passed in rootScope. As it will update the rootScope.fields as part of making a new patient. getPatientData provides the raw data as pulled in from the patient api. Data Loaders getRecordLoader provides a mocked up version of the recordloader that behaves like the normal recordloader. It comes with the load function already spied on. getRecordLoaderData provides example raw data as pulled from /api/v0.1/record/ getMetaDataLoader provides a mocked up version of the Metadata that behaves like the normal Metadata. It comes with the load function already spied on. getMetaDataLoader provides example raw data as pulled from /api/v0.1/metadata/ getReferenceDataLoader provides a mocked up version of the Referencedata that behaves like the normal Referencedata. It comes with the load function already spied on. getReferenceData provides example raw data as pulled from /api/v0.1/referencedata/ getUserProfileLoader provides a mocked up version of the UserProfile that behaves like the normal UserProfile. It comes with the load function already spied on. getUserProfile provides example raw data as pulled from /api/v0.1/userprofile/","title":"Test helper"},{"location":"reference/javascript/test_helper/#the-test-helper-service","text":"Opal provides a utility to help you test javascript unit tests. To bring it in, import the module and inject the service. var testHelper; beforeEach(function(){ module('opal.controllers'); inject(function($injector){ testHelper = $injector.get('testHelper'); }); }); The helper has the following functions. newEpisode provides a new episode. It needs to passed in rootScope as part of getting a new episode we update the rootSchema to have the schema information about subrecords. One can pass in an optional dictionary as the second argument as the args to make the episode. Otherwise it will be created with the data from getEpisodeData . getEpisodeData provides the raw data as pull in from the episode api. newPatient provides a new patient. It needs to be passed in rootScope. As it will update the rootScope.fields as part of making a new patient. getPatientData provides the raw data as pulled in from the patient api.","title":"The Test Helper Service"},{"location":"reference/javascript/test_helper/#data-loaders","text":"getRecordLoader provides a mocked up version of the recordloader that behaves like the normal recordloader. It comes with the load function already spied on. getRecordLoaderData provides example raw data as pulled from /api/v0.1/record/ getMetaDataLoader provides a mocked up version of the Metadata that behaves like the normal Metadata. It comes with the load function already spied on. getMetaDataLoader provides example raw data as pulled from /api/v0.1/metadata/ getReferenceDataLoader provides a mocked up version of the Referencedata that behaves like the normal Referencedata. It comes with the load function already spied on. getReferenceData provides example raw data as pulled from /api/v0.1/referencedata/ getUserProfileLoader provides a mocked up version of the UserProfile that behaves like the normal UserProfile. It comes with the load function already spied on. getUserProfile provides example raw data as pulled from /api/v0.1/userprofile/","title":"Data Loaders"},{"location":"reference/javascript/user_service/","text":"The User service The User Service in opal.services provides us a way to get information about users of an application. Methods User.all() Fetches all users of the application as a list. User.all().then(function(users){ console.log(users[0]); // - The first user }) User.get(id) Fetch one specific user by ID. User.get(1).then(function(user){ console.log(user); // - The user with ID 1 });","title":"The User service"},{"location":"reference/javascript/user_service/#the-user-service","text":"The User Service in opal.services provides us a way to get information about users of an application.","title":"The User service"},{"location":"reference/javascript/user_service/#methods","text":"","title":"Methods"},{"location":"reference/javascript/user_service/#userall","text":"Fetches all users of the application as a list. User.all().then(function(users){ console.log(users[0]); // - The first user })","title":"User.all()"},{"location":"reference/javascript/user_service/#usergetid","text":"Fetch one specific user by ID. User.get(1).then(function(user){ console.log(user); // - The user with ID 1 });","title":"User.get(id)"},{"location":"tutorials/pathway_tutorial/","text":"Tutorial: Creating forms with Opal In this section we walk you through creating a simple Pathway. Your First Pathway Pathways are an Opal Discoverable feature - this means that Opal will automatically load any Pathways defined in a python module named pathways.py inside a Django App. Individual pathways are defined by subclassing a Pathway class. You must set at least the display name, and will often want to also set a slug. Out of the box, pathways ships with two types of pathways. A page pathway, a whole bunch of model forms on the same page, and a wizard pathway, a bunch of steps where the next step is only revealed after the step before it has been completed. Let's look at a page pathway definition. # yourapp/pathways.py from opal.core import pathway class MyPathway(pathway.PagePathway): display_name = 'My Awesome Pathway' slug = 'awesomest_pathway' Taking Our First Steps A Pathway should have at least one Step - a section within the form. Steps are defined on the pathway class using the Pathway.steps tuple. from opal.core import pathway from myapp import models class SimplePathway(pathway.PagePathway): display_name = 'A simple pathway' steps = ( pathways.Step(model=models.PastMedicalHistory) ) Model Steps A common case is for steps to be simply a single Opal Subrecord using the subrecord form template. In fact we can simply add Opal Subrecords to the steps tuple to achieve the same effect. For instance, to create a pathway with three steps to record a patient's allergies, treatment and past medical history, we could use the following: from opal.core import pathway from myapp import models class SimplePathway(pathway.PagePathway): display_name = 'A simple pathway' slug = 'simples' steps = ( models.Allergies, models.Treatment, models.PastMedicalHistory ) Pathways is smart enough to provide a single form step pathway if the model is a singleton model , or a pathway that allows a user to edit/add/remove multiple models if its not a singleton model. Viewing The Pathway This pathway is then available from e.g. http://localhost:8000/pathway/#/simples .","title":"Tutorial: Creating forms with Opal"},{"location":"tutorials/pathway_tutorial/#tutorial-creating-forms-with-opal","text":"In this section we walk you through creating a simple Pathway.","title":"Tutorial: Creating forms with Opal"},{"location":"tutorials/pathway_tutorial/#your-first-pathway","text":"Pathways are an Opal Discoverable feature - this means that Opal will automatically load any Pathways defined in a python module named pathways.py inside a Django App. Individual pathways are defined by subclassing a Pathway class. You must set at least the display name, and will often want to also set a slug. Out of the box, pathways ships with two types of pathways. A page pathway, a whole bunch of model forms on the same page, and a wizard pathway, a bunch of steps where the next step is only revealed after the step before it has been completed. Let's look at a page pathway definition. # yourapp/pathways.py from opal.core import pathway class MyPathway(pathway.PagePathway): display_name = 'My Awesome Pathway' slug = 'awesomest_pathway'","title":"Your First Pathway"},{"location":"tutorials/pathway_tutorial/#taking-our-first-steps","text":"A Pathway should have at least one Step - a section within the form. Steps are defined on the pathway class using the Pathway.steps tuple. from opal.core import pathway from myapp import models class SimplePathway(pathway.PagePathway): display_name = 'A simple pathway' steps = ( pathways.Step(model=models.PastMedicalHistory) )","title":"Taking Our First Steps"},{"location":"tutorials/pathway_tutorial/#model-steps","text":"A common case is for steps to be simply a single Opal Subrecord using the subrecord form template. In fact we can simply add Opal Subrecords to the steps tuple to achieve the same effect. For instance, to create a pathway with three steps to record a patient's allergies, treatment and past medical history, we could use the following: from opal.core import pathway from myapp import models class SimplePathway(pathway.PagePathway): display_name = 'A simple pathway' slug = 'simples' steps = ( models.Allergies, models.Treatment, models.PastMedicalHistory ) Pathways is smart enough to provide a single form step pathway if the model is a singleton model , or a pathway that allows a user to edit/add/remove multiple models if its not a singleton model.","title":"Model Steps"},{"location":"tutorials/pathway_tutorial/#viewing-the-pathway","text":"This pathway is then available from e.g. http://localhost:8000/pathway/#/simples .","title":"Viewing The Pathway"},{"location":"tutorials/theming_tutorial/","text":"Customising the design of your application Tutorial WIP Changing the default logo and favicon We can change the logo and favicon of our application by changing settings. Create a logo and a favicon, place them in ./yourapp/static/img/ and then update the following settings: # ./yourapp/settings.py OPAL_FAVICON_PATH = 'img/yourapp.favicon.ico' OPAL_LOGO_PATH = 'img/yourapp.logo.png' Some platforms require favicons to be .ico format, however .png also works Adding your own CSS file to change the default colours, fonts, layouts and more To change the CSS used for the Opal interface, first create a CSS file with your custom application styling: /* ./yourapp/static/yourapp.css */ body { /*main text style*/ font-family: 'Franklin Gothic Book', Arial; } .bg-primary { background-color: #25408F; } .bg-secondary { background-color: #0084FF; } Then include this CSS file in your Application definition: # ./yourapp/__init__.py class Application(application.OpalApplication): styles = [ css/yourapp.css ] Many of the classes are standard Bootstrap CSS classes, which can be identified in the Bootstrap documentation, or via the inspector in your browser's developer tools. Key overrides and a .sass template to reset key colours WIP Changing the layout of the application WIP Bundling as a standalone theme WIP","title":"Customising the design of your application"},{"location":"tutorials/theming_tutorial/#customising-the-design-of-your-application","text":"Tutorial WIP","title":"Customising the design of your application"},{"location":"tutorials/theming_tutorial/#changing-the-default-logo-and-favicon","text":"We can change the logo and favicon of our application by changing settings. Create a logo and a favicon, place them in ./yourapp/static/img/ and then update the following settings: # ./yourapp/settings.py OPAL_FAVICON_PATH = 'img/yourapp.favicon.ico' OPAL_LOGO_PATH = 'img/yourapp.logo.png' Some platforms require favicons to be .ico format, however .png also works","title":"Changing the default logo and favicon"},{"location":"tutorials/theming_tutorial/#adding-your-own-css-file-to-change-the-default-colours-fonts-layouts-and-more","text":"To change the CSS used for the Opal interface, first create a CSS file with your custom application styling: /* ./yourapp/static/yourapp.css */ body { /*main text style*/ font-family: 'Franklin Gothic Book', Arial; } .bg-primary { background-color: #25408F; } .bg-secondary { background-color: #0084FF; } Then include this CSS file in your Application definition: # ./yourapp/__init__.py class Application(application.OpalApplication): styles = [ css/yourapp.css ] Many of the classes are standard Bootstrap CSS classes, which can be identified in the Bootstrap documentation, or via the inspector in your browser's developer tools.","title":"Adding your own CSS file to change the default colours, fonts, layouts and more"},{"location":"tutorials/theming_tutorial/#key-overrides-and-a-sass-template-to-reset-key-colours","text":"WIP","title":"Key overrides and a .sass template to reset key colours"},{"location":"tutorials/theming_tutorial/#changing-the-layout-of-the-application","text":"WIP","title":"Changing the layout of the application"},{"location":"tutorials/theming_tutorial/#bundling-as-a-standalone-theme","text":"WIP","title":"Bundling as a standalone theme"}]}