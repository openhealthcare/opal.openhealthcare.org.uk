{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OPAL Documentation OPAL is a full stack framework that makes building digital tools for health care easy. OPAL builds deep clinical domain specific functionality on top of Django , Angular and Bootstrap to help developers quickly build easy to maintain, robust clinical applications. This is the developer documentation . OPAL is an entirely Open Source , Open Governance product, as are the wide library of plugins. First Steps If you're new to OPAL, then you'll want to take a look at the Installation instructions , and then maybe take the tutorial . Full documentation While Topic guides are available for many key areas of OPAL, the Detailed reference material is a work in progress. If you find any issues or missing areas of this documentation, please do raise it with the team on the Github issue tracker .","title":"Home"},{"location":"#opal-documentation","text":"","title":"OPAL Documentation"},{"location":"#opal-is-a-full-stack-framework-that-makes-building-digital-tools-for-health-care-easy","text":"OPAL builds deep clinical domain specific functionality on top of Django , Angular and Bootstrap to help developers quickly build easy to maintain, robust clinical applications. This is the developer documentation . OPAL is an entirely Open Source , Open Governance product, as are the wide library of plugins.","title":"OPAL is a full stack framework that makes building digital tools for health care easy."},{"location":"#first-steps","text":"If you're new to OPAL, then you'll want to take a look at the Installation instructions , and then maybe take the tutorial .","title":"First Steps"},{"location":"#full-documentation","text":"While Topic guides are available for many key areas of OPAL, the Detailed reference material is a work in progress. If you find any issues or missing areas of this documentation, please do raise it with the team on the Github issue tracker .","title":"Full documentation"},{"location":"installation/","text":"Installing OPAL Installation should be simple. Step 1: The Prerequisites Before you install OPAL, you'll need to make sure that you have Python and pip installed on your system. Let's just check that you do: $ python --version Python 2.7.5 $ pip --version pip 1.5.6 Step 2: Use Pip Now we can install OPAL using pip: $ pip install opal You should now have the opal commandline tools installed. Let's just check that you do: $ opal --version OPAL 0.6.0 Step 3: There is no step 3. Maybe make yourself some tea then try the Tutorial instead ?","title":"Installation"},{"location":"installation/#installing-opal","text":"Installation should be simple.","title":"Installing OPAL"},{"location":"installation/#step-1-the-prerequisites","text":"Before you install OPAL, you'll need to make sure that you have Python and pip installed on your system. Let's just check that you do: $ python --version Python 2.7.5 $ pip --version pip 1.5.6","title":"Step 1: The Prerequisites"},{"location":"installation/#step-2-use-pip","text":"Now we can install OPAL using pip: $ pip install opal You should now have the opal commandline tools installed. Let's just check that you do: $ opal --version OPAL 0.6.0","title":"Step 2: Use Pip"},{"location":"installation/#step-3-there-is-no-step-3","text":"Maybe make yourself some tea then try the Tutorial instead ?","title":"Step 3: There is no step 3."},{"location":"overview/","text":"","title":"Overview"},{"location":"tutorial/","text":"Writing a clinical service with OPAL This tutorial will walk you through the creation of a new OPAL service. The application we're going to be building will help clinical users to manage the patients on a ward in a hospital. As a Doctor I want to know what's going on with the patients under my care So that I can treat them effectively and safely. Bootstrapping a new project We assume that you've already Installed OPAL . You can tell which version of opal is installed by running this command $ opal --version At the start a new project, OPAL will bootstrap the initial project structure, including a Djano project, some core datamodels (complete with JSON APIs) and a general application structure. From the commandline: $ opal startproject mynewapp This will create a mynewap directory where your new project lives. Let's have a look at what that created for you: mynewapp/ # Your project directory LICENSE # A dummy LICENSE file Procfile # A procfile ready for deployment to e.g. Heroku README.md manage.py # Django's manage.py script requirements.txt # Requirements file ready for your project data/ # A dummy directory for fixtures lookuplists/ # A dummy directory for reference data mynewapp/ # The actual python package for your application __init__.py models.py # Data models for your application settings.py # Helpfully tweaked Django settings tests.py # Dummy unittests urls.py # Django Urlconf wsgi.py assets/ # Your static files directory templates/ # Your template directory migrations/ # Your Database migrations directory opal.sqlite # The Sqlite development database Test it out The scaffolding step has generated you a working project - so let's check that out cd mynewapp python manage.py runserver If you now visit http://localhost:8000 in your browser, you should see the standard login screen: The scaffolding step created you a superuser, so try logging in with the credentials: Username: super Password: super1 When you log in you should be presented with a welcome screen that shows you the three areas that are enabled by default - team lists, search and the admin area. OPAL applications are a collection of single page Angular apps that talk to the Django server-side layer via JSON APIs. The Team Lists and Search options here are two examples of front-end Angular single page apps. Team lists Most clinical services will need at some stage to generate a list of patients - so OPAL provides this functionality enabled by default. The list view is a spreadhseet-style list of patients - try navigating to the list view and adding a patient with the add patient button. Each column contains a different type of information about a patient, while each row represents one patient. Strictly speaking each row is an episode of care for a patient - but we'll come to that in a second. The columns you see initially are just a few of the standard clinical models that come with OPAL - for instance the Diagnosis model in your new application inherits from a model that looks a lot like this: class Diagnosis(EpisodeSubrecord): condition = ForeignKeyOrFreeText(Condition) provisional = models.BooleanField(default=False) details = models.CharField(max_length=255, blank=True) date_of_diagnosis = models.DateField(blank=True, null=True) class Meta: abstract = True Lookup Lists You will notice that the condition field has a custom field type - ForeignKeyOrFreeText . This is a custom field type that we use with OPAL when we want to use a Lookup List . Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. That means that we can ensure that we record high quality coded data, while allowing users an easy way to enter unusual edge cases. You'll need to import the data for a terminology before you can start to take advantage of that. For now, let's use the reference data from elCID (An OPAL application maintained by Open Health Care): wget https://raw.githubusercontent.com/openhealthcare/elcid/master/data/lookuplists/lookuplists.json -P data/lookuplists By convention, we store data in the ./data/lookuplists directory of our project. Now let's import the data: python manage.py load_lookup_lists -f data/lookuplists/lookuplists.json Now refresh your application and try adding a new diagnosis to your patient. As you start to type in the condition field, you'l see that the conditions we just imported appear as suggestions: Add your own data models So far we've begun to get a sense of the batteries-included parts of OPAL, but before long, you're going to need to create models for your own needs. Most OPAL models are Subrecords - they relate to either a patient, or an episode (an episode is for example, an admission to hospital). Let's see how that works by creating a TODO list model that is assigned to episodes of care. In your mynewapp/models.py : class TODOItem(models.EpisodeSubrecord): job = fields.CharField(max_length=200) due_date = fields.DateField(blank=True, null=True) details = fields.TextField(blank=True, null=True) completed = fields.BooleanField(default=False) This is simply a Django model, apart from the parent class models.EpisodeSubrecord which provides us with some extra functionality: A relationship to an episode, linked to a patient JSON APIs for creating, retrieving and updating it Ensuring that the OPAL Angular layer knows it exists Some metadata fields, like created, updated, created_by, updated_by Next, we're going to let OPAL take care of the boilerplate that we'll need to use this model in our application. From the commandline: $ opal scaffold mynewapp Let's take a look at what that did: It created a Django migration It ran that migration for you It created a detail template mynewapp/templates/records/todo_item.html It created a form template mynewapp/templates/forms/todo_item_forml.html Detail template The default detail template simply displays each field on a new line: span ng-show=\"item.job\" [[ item.job ]] br / /span span ng-show=\"item.due_date\" [[ item.due_date | shortDate ]] br / /span span ng-show=\"item.details\" [[ item.details ]] br / /span span ng-show=\"item.completed\" [[ item.completed ]] br / /span Form template The default form template will display each field on a new line, with some basic appropriate form field types set. It uses the OPAL form helpers templatetag library. {% load forms %} {% input field= TODOItem.job %} {% datepicker field= TODOItem.due_date %} {% textarea field= TODOItem.details %} {% checkbox field= TODOItem.completed %} Adding TODOs to our Team Lists Now let's add our TODO list model as a column in the Spreadsheet-like list view. Patient Lists in OPAL are subclasses of opal.core.patient_lists.PatientList , and they live in patient_lists.py files of our Django apps. Technically these can live anywhere you like - although if you put them in other places you're responsible for making sure that they're imported at startup. OPAL guarantees to autodiscover lists in `app.patient_list` modules. You can see the basic list that the OPAL application scaffold created for you in yournewapp/patient_lists.py . class AllPatientsList(core.patient_lists.PatientList): display_name = 'All Patients' schema = [ models.Demographics, models.Diagnosis, models.Treatment ] def get_queryset(self): return Episode.objects.all() The columns for lists are set in the schema property of the PatientList class. To add our TODO model to the list, just add the model to the schema: schema = [ models.Demographics, models.Diagnosis, models.Treatment, models.TODOItem ] Refresh the lists page in your browser, and you'll see your new column on the end - add a TODO item, noting how we automatically get appropriate form types like datepickers and checkboxes. You can edit any entry in the list view by double clicking on it. Tweaking the default scaffolding The scaffolding templates are only really supposed to get you started - you'll often need to tweak the templates they generate with whatever logic makes sense for your application. For us, you'll notice that the value of TODOItem.completed simply displays as false - which is not particularly useful. So let's update that using the OPAL Boxed filter . In mynewapp/templates/records/todo_item.html change the last line to look like this: span ng-show=\"item.completed\" [[ item.completed | boxed ]] br / /span Set an Icon for your model You'll notice that your new column is the only one without an icon - we set the icon by adding the following property to your TODOItem class: _icon = 'fa fa-th-list' Some other batteries included Let's take a look at some of the other core functionality that we now have out of the box: Search By default, we also enable the search module, which allows you to search by patient name or unique identifier: Detail views We also have a detail view for our patients, which you can access via search results. This view will typically allow for a more detailed display and editing of all the events comprising a patient's care than is available on the list page. JSON APIs OPAL automatically creates self-documenting JSON APIs for your interacting with the data in your application. You can inspect these APIs interactively at the url: http://localhost:8000/api/v0.1/ What next? This is just a glimpse at the full range of functionality that comes with OPAL - there is much more to discover in the Topic Guides .","title":"Tutorial"},{"location":"tutorial/#writing-a-clinical-service-with-opal","text":"This tutorial will walk you through the creation of a new OPAL service. The application we're going to be building will help clinical users to manage the patients on a ward in a hospital. As a Doctor I want to know what's going on with the patients under my care So that I can treat them effectively and safely.","title":"Writing a clinical service with OPAL"},{"location":"tutorial/#bootstrapping-a-new-project","text":"We assume that you've already Installed OPAL . You can tell which version of opal is installed by running this command $ opal --version At the start a new project, OPAL will bootstrap the initial project structure, including a Djano project, some core datamodels (complete with JSON APIs) and a general application structure. From the commandline: $ opal startproject mynewapp This will create a mynewap directory where your new project lives. Let's have a look at what that created for you: mynewapp/ # Your project directory LICENSE # A dummy LICENSE file Procfile # A procfile ready for deployment to e.g. Heroku README.md manage.py # Django's manage.py script requirements.txt # Requirements file ready for your project data/ # A dummy directory for fixtures lookuplists/ # A dummy directory for reference data mynewapp/ # The actual python package for your application __init__.py models.py # Data models for your application settings.py # Helpfully tweaked Django settings tests.py # Dummy unittests urls.py # Django Urlconf wsgi.py assets/ # Your static files directory templates/ # Your template directory migrations/ # Your Database migrations directory opal.sqlite # The Sqlite development database","title":"Bootstrapping a new project"},{"location":"tutorial/#test-it-out","text":"The scaffolding step has generated you a working project - so let's check that out cd mynewapp python manage.py runserver If you now visit http://localhost:8000 in your browser, you should see the standard login screen: The scaffolding step created you a superuser, so try logging in with the credentials: Username: super Password: super1 When you log in you should be presented with a welcome screen that shows you the three areas that are enabled by default - team lists, search and the admin area. OPAL applications are a collection of single page Angular apps that talk to the Django server-side layer via JSON APIs. The Team Lists and Search options here are two examples of front-end Angular single page apps.","title":"Test it out"},{"location":"tutorial/#team-lists","text":"Most clinical services will need at some stage to generate a list of patients - so OPAL provides this functionality enabled by default. The list view is a spreadhseet-style list of patients - try navigating to the list view and adding a patient with the add patient button. Each column contains a different type of information about a patient, while each row represents one patient. Strictly speaking each row is an episode of care for a patient - but we'll come to that in a second. The columns you see initially are just a few of the standard clinical models that come with OPAL - for instance the Diagnosis model in your new application inherits from a model that looks a lot like this: class Diagnosis(EpisodeSubrecord): condition = ForeignKeyOrFreeText(Condition) provisional = models.BooleanField(default=False) details = models.CharField(max_length=255, blank=True) date_of_diagnosis = models.DateField(blank=True, null=True) class Meta: abstract = True","title":"Team lists"},{"location":"tutorial/#lookup-lists","text":"You will notice that the condition field has a custom field type - ForeignKeyOrFreeText . This is a custom field type that we use with OPAL when we want to use a Lookup List . Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. That means that we can ensure that we record high quality coded data, while allowing users an easy way to enter unusual edge cases. You'll need to import the data for a terminology before you can start to take advantage of that. For now, let's use the reference data from elCID (An OPAL application maintained by Open Health Care): wget https://raw.githubusercontent.com/openhealthcare/elcid/master/data/lookuplists/lookuplists.json -P data/lookuplists By convention, we store data in the ./data/lookuplists directory of our project. Now let's import the data: python manage.py load_lookup_lists -f data/lookuplists/lookuplists.json Now refresh your application and try adding a new diagnosis to your patient. As you start to type in the condition field, you'l see that the conditions we just imported appear as suggestions:","title":"Lookup Lists"},{"location":"tutorial/#add-your-own-data-models","text":"So far we've begun to get a sense of the batteries-included parts of OPAL, but before long, you're going to need to create models for your own needs. Most OPAL models are Subrecords - they relate to either a patient, or an episode (an episode is for example, an admission to hospital). Let's see how that works by creating a TODO list model that is assigned to episodes of care. In your mynewapp/models.py : class TODOItem(models.EpisodeSubrecord): job = fields.CharField(max_length=200) due_date = fields.DateField(blank=True, null=True) details = fields.TextField(blank=True, null=True) completed = fields.BooleanField(default=False) This is simply a Django model, apart from the parent class models.EpisodeSubrecord which provides us with some extra functionality: A relationship to an episode, linked to a patient JSON APIs for creating, retrieving and updating it Ensuring that the OPAL Angular layer knows it exists Some metadata fields, like created, updated, created_by, updated_by Next, we're going to let OPAL take care of the boilerplate that we'll need to use this model in our application. From the commandline: $ opal scaffold mynewapp Let's take a look at what that did: It created a Django migration It ran that migration for you It created a detail template mynewapp/templates/records/todo_item.html It created a form template mynewapp/templates/forms/todo_item_forml.html","title":"Add your own data models"},{"location":"tutorial/#detail-template","text":"The default detail template simply displays each field on a new line: span ng-show=\"item.job\" [[ item.job ]] br / /span span ng-show=\"item.due_date\" [[ item.due_date | shortDate ]] br / /span span ng-show=\"item.details\" [[ item.details ]] br / /span span ng-show=\"item.completed\" [[ item.completed ]] br / /span","title":"Detail template"},{"location":"tutorial/#form-template","text":"The default form template will display each field on a new line, with some basic appropriate form field types set. It uses the OPAL form helpers templatetag library. {% load forms %} {% input field= TODOItem.job %} {% datepicker field= TODOItem.due_date %} {% textarea field= TODOItem.details %} {% checkbox field= TODOItem.completed %}","title":"Form template"},{"location":"tutorial/#adding-todos-to-our-team-lists","text":"Now let's add our TODO list model as a column in the Spreadsheet-like list view. Patient Lists in OPAL are subclasses of opal.core.patient_lists.PatientList , and they live in patient_lists.py files of our Django apps. Technically these can live anywhere you like - although if you put them in other places you're responsible for making sure that they're imported at startup. OPAL guarantees to autodiscover lists in `app.patient_list` modules. You can see the basic list that the OPAL application scaffold created for you in yournewapp/patient_lists.py . class AllPatientsList(core.patient_lists.PatientList): display_name = 'All Patients' schema = [ models.Demographics, models.Diagnosis, models.Treatment ] def get_queryset(self): return Episode.objects.all() The columns for lists are set in the schema property of the PatientList class. To add our TODO model to the list, just add the model to the schema: schema = [ models.Demographics, models.Diagnosis, models.Treatment, models.TODOItem ] Refresh the lists page in your browser, and you'll see your new column on the end - add a TODO item, noting how we automatically get appropriate form types like datepickers and checkboxes. You can edit any entry in the list view by double clicking on it.","title":"Adding TODOs to our Team Lists"},{"location":"tutorial/#tweaking-the-default-scaffolding","text":"The scaffolding templates are only really supposed to get you started - you'll often need to tweak the templates they generate with whatever logic makes sense for your application. For us, you'll notice that the value of TODOItem.completed simply displays as false - which is not particularly useful. So let's update that using the OPAL Boxed filter . In mynewapp/templates/records/todo_item.html change the last line to look like this: span ng-show=\"item.completed\" [[ item.completed | boxed ]] br / /span","title":"Tweaking the default scaffolding"},{"location":"tutorial/#set-an-icon-for-your-model","text":"You'll notice that your new column is the only one without an icon - we set the icon by adding the following property to your TODOItem class: _icon = 'fa fa-th-list'","title":"Set an Icon for your model"},{"location":"tutorial/#some-other-batteries-included","text":"Let's take a look at some of the other core functionality that we now have out of the box:","title":"Some other batteries included"},{"location":"tutorial/#search","text":"By default, we also enable the search module, which allows you to search by patient name or unique identifier:","title":"Search"},{"location":"tutorial/#detail-views","text":"We also have a detail view for our patients, which you can access via search results. This view will typically allow for a more detailed display and editing of all the events comprising a patient's care than is available on the list page.","title":"Detail views"},{"location":"tutorial/#json-apis","text":"OPAL automatically creates self-documenting JSON APIs for your interacting with the data in your application. You can inspect these APIs interactively at the url: http://localhost:8000/api/v0.1/","title":"JSON APIs"},{"location":"tutorial/#what-next","text":"This is just a glimpse at the full range of functionality that comes with OPAL - there is much more to discover in the Topic Guides .","title":"What next?"},{"location":"guides/archetypes/","text":"Core Clinical Archetypes OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Common Metadata fields All subrecords will contain the following fields, which are not repreated individually Field Type Length created_by FK User ID created Date updated_by FK User ID update Date The details of each individual archetype are set out below: Patient Subrecords Demographics Field Type Length hospital_number Char 255 nhs_number Char 255 date_of_birth Date place_of_birth FKorFT(Destination) ethnicity FKorFT(Ethnicity) surname Char 255 first_name Char 255 middle_name Char 255 sex FKorFT(Gender) Allergies Field Type Length drug FKorFT(Drug) provisional Boolean details Char 255 Episode Subrecords Location Field Type Length category Char 255 hospital Char 255 ward Char 255 bed Char 255 Treatment Field Type Length drug FKorFT(Drug) dose Char 255 route FKorFT(Drugroute) start_date Date end_date Date frequency FKorFT(Drugfreq) Diagnosis Field Type Length condition FKorFT(Condition) provisional Boolean details Char 255 date_of_diagnosis Date PastMedicalHistory Field Type Length condition FKorFT(Condition) year Char 4 details Char 255 SymptomComplex Field Type Length symptoms ManyToMany(Symptom) duration Char 255 details Text ReferralRoute Field Type Length internal NullBoolean referral_route FKorFT(ReferralOrganisation) referral_name Char 255 date_of_referral Date referral_team FKorFT(Speciality) referral_reason FKorFT(ReferralReason) PatientConsultation Field Type Length when Datetime initials Char 255 reason_for_interaction FKorFT(Patient_consultation_reason_for_interaction) discussion Text Investigation Field Type Length test Char 255 date_ordered Date details Char 255 microscopy Char 255 organism Char 255 sensitive_antibiotics Char 255 resistant_antibiotics Char 255 result Char 255 igm Char 20 igg Char 20 vca_igm Char 20 vca_igg Char 20 ebna_igg Char 20 hbsag Char 20 anti_hbs Char 20 anti_hbcore_igm Char 20 anti_hbcore_igg Char 20 rpr Char 20 tppa Char 20 viral_load Char 20 parasitaemia Char 20 hsv Char 20 vzv Char 20 syphilis Char 20 c_difficile_antigen Char 20 c_difficile_toxin Char 20 species Char 20 hsv_1 Char 20 hsv_2 Char 20 enterovirus Char 20 cmv Char 20 ebv Char 20 influenza_a Char 20 influenza_b Char 20 parainfluenza Char 20 metapneumovirus Char 20 rsv Char 20 adenovirus Char 20 norovirus Char 20 rotavirus Char 20 giardia Char 20 entamoeba_histolytica Char 20 cryptosporidium Char 20","title":"Archetypes"},{"location":"guides/archetypes/#core-clinical-archetypes","text":"OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application.","title":"Core Clinical Archetypes"},{"location":"guides/archetypes/#common-metadata-fields","text":"All subrecords will contain the following fields, which are not repreated individually Field Type Length created_by FK User ID created Date updated_by FK User ID update Date The details of each individual archetype are set out below:","title":"Common Metadata fields"},{"location":"guides/archetypes/#patient-subrecords","text":"","title":"Patient Subrecords"},{"location":"guides/archetypes/#demographics","text":"Field Type Length hospital_number Char 255 nhs_number Char 255 date_of_birth Date place_of_birth FKorFT(Destination) ethnicity FKorFT(Ethnicity) surname Char 255 first_name Char 255 middle_name Char 255 sex FKorFT(Gender)","title":"Demographics"},{"location":"guides/archetypes/#allergies","text":"Field Type Length drug FKorFT(Drug) provisional Boolean details Char 255","title":"Allergies"},{"location":"guides/archetypes/#episode-subrecords","text":"","title":"Episode Subrecords"},{"location":"guides/archetypes/#location","text":"Field Type Length category Char 255 hospital Char 255 ward Char 255 bed Char 255","title":"Location"},{"location":"guides/archetypes/#treatment","text":"Field Type Length drug FKorFT(Drug) dose Char 255 route FKorFT(Drugroute) start_date Date end_date Date frequency FKorFT(Drugfreq)","title":"Treatment"},{"location":"guides/archetypes/#diagnosis","text":"Field Type Length condition FKorFT(Condition) provisional Boolean details Char 255 date_of_diagnosis Date","title":"Diagnosis"},{"location":"guides/archetypes/#pastmedicalhistory","text":"Field Type Length condition FKorFT(Condition) year Char 4 details Char 255","title":"PastMedicalHistory"},{"location":"guides/archetypes/#symptomcomplex","text":"Field Type Length symptoms ManyToMany(Symptom) duration Char 255 details Text","title":"SymptomComplex"},{"location":"guides/archetypes/#referralroute","text":"Field Type Length internal NullBoolean referral_route FKorFT(ReferralOrganisation) referral_name Char 255 date_of_referral Date referral_team FKorFT(Speciality) referral_reason FKorFT(ReferralReason)","title":"ReferralRoute"},{"location":"guides/archetypes/#patientconsultation","text":"Field Type Length when Datetime initials Char 255 reason_for_interaction FKorFT(Patient_consultation_reason_for_interaction) discussion Text","title":"PatientConsultation"},{"location":"guides/archetypes/#investigation","text":"Field Type Length test Char 255 date_ordered Date details Char 255 microscopy Char 255 organism Char 255 sensitive_antibiotics Char 255 resistant_antibiotics Char 255 result Char 255 igm Char 20 igg Char 20 vca_igm Char 20 vca_igg Char 20 ebna_igg Char 20 hbsag Char 20 anti_hbs Char 20 anti_hbcore_igm Char 20 anti_hbcore_igg Char 20 rpr Char 20 tppa Char 20 viral_load Char 20 parasitaemia Char 20 hsv Char 20 vzv Char 20 syphilis Char 20 c_difficile_antigen Char 20 c_difficile_toxin Char 20 species Char 20 hsv_1 Char 20 hsv_2 Char 20 enterovirus Char 20 cmv Char 20 ebv Char 20 influenza_a Char 20 influenza_b Char 20 parainfluenza Char 20 metapneumovirus Char 20 rsv Char 20 adenovirus Char 20 norovirus Char 20 rotavirus Char 20 giardia Char 20 entamoeba_histolytica Char 20 cryptosporidium Char 20","title":"Investigation"},{"location":"guides/command_line_tool/","text":"The OPAL Command line tool OPAL ships with a helpful command line tool that helps with administrative tasks. The opal script should be on your system path if you installed OPAL via setup.py or pip. You can check whether it is available by running this command: $ opal -v startproject name Creates a new OPAL project. This creates boilerplate and a default configuration for your new project, including creating a new underlying Django project, updating default settings to be compatible with OPAL, creating directories and code boilerplate, and running initial migrations. startplugin name Creates boilerplate code, and directory structures for a new OPAL plugin. scaffold appname Use with new record models. Creates and runs automatic migrations, creates display and form (modal) templates. Running with --dry-run will run makemigrations with --dry-run and print display and form templates that would be generated. test what Run our tests suites. Defaults to running both Python and Javascript tests. If specified, will only run one specific kind of test. $ opal test py $ opal test js When running Python tests, the -t or --test option allows the user to specify a single test module, case or method to run. $ opal test py -t opal.tests.test_models checkout Ensure that all of our application plugins and packages are on the correct branch. This is particularly useful when working on OPAL itself, or when you have multiple projects that use different versions of OPAL or plugins. It will assume that github based requirements will be installed in development via python setup.py develop . This command will parse your project's requirements.txt , and then ensure that any Github sources are checked out loclaly to the branch specified therein.","title":"Command Line tool"},{"location":"guides/command_line_tool/#the-opal-command-line-tool","text":"OPAL ships with a helpful command line tool that helps with administrative tasks. The opal script should be on your system path if you installed OPAL via setup.py or pip. You can check whether it is available by running this command: $ opal -v","title":"The OPAL Command line tool"},{"location":"guides/command_line_tool/#startproject-name","text":"Creates a new OPAL project. This creates boilerplate and a default configuration for your new project, including creating a new underlying Django project, updating default settings to be compatible with OPAL, creating directories and code boilerplate, and running initial migrations.","title":"startproject &lt;name&gt;"},{"location":"guides/command_line_tool/#startplugin-name","text":"Creates boilerplate code, and directory structures for a new OPAL plugin.","title":"startplugin &lt;name&gt;"},{"location":"guides/command_line_tool/#scaffold-appname","text":"Use with new record models. Creates and runs automatic migrations, creates display and form (modal) templates. Running with --dry-run will run makemigrations with --dry-run and print display and form templates that would be generated.","title":"scaffold &lt;appname&gt;"},{"location":"guides/command_line_tool/#test-what","text":"Run our tests suites. Defaults to running both Python and Javascript tests. If specified, will only run one specific kind of test. $ opal test py $ opal test js When running Python tests, the -t or --test option allows the user to specify a single test module, case or method to run. $ opal test py -t opal.tests.test_models","title":"test &lt;what&gt;"},{"location":"guides/command_line_tool/#checkout","text":"Ensure that all of our application plugins and packages are on the correct branch. This is particularly useful when working on OPAL itself, or when you have multiple projects that use different versions of OPAL or plugins. It will assume that github based requirements will be installed in development via python setup.py develop . This command will parse your project's requirements.txt , and then ensure that any Github sources are checked out loclaly to the branch specified therein.","title":"checkout"},{"location":"guides/components_overview/","text":"Components of an OPAL application OPAL applications will typically be made up of several types of components. OPAL The core OPAL framework provides you with a range of commonly required elements of clinical applications. It contains a core data model for persisting clinical information, as well core clinical archetypes out of the box that build on many years of collaboratively modelling clinical concepts by medical domain experts. OPAL also makes it easy to integrate standard clinical reference data into your application - things like medical diagnoses, tests, drugs et cetera. Some common functional components end up in to most clinical applications, and many of these come with OPAL as \"batteries included\" - immediately available modular features that can be simply re-used without having to reinvent the wheel. For example: Patient lists Search Authentication and Permissions Forms for data entry JSON based REST APIs for all of your models ... and many more ... Plugins OPAL plugins are intended to provide high quality generic, composable, re-usable chunks of functionality that can be \"dropped in\" to an application. For example, installing the Dashboards plugin allows you to easily create clinical dashboards within your application. The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. Plugins have a rich plugin API they can hook into to, and many examples can be found by inspecting the source of existing plugins . Applications An application is the collection of configuration and bespoke functionality that would be provided to an individual institution - it's the thing that you would look to deploy. Example applications include elCID - a for managing infection patients, or OPAL-Renal - an MDT handover tool for Renal wards. A hospital might have multiple clinical services running on one application, or multiple applications that integrate with one another. Opinionated but Pluggable OPAL is an opinionated framework. It expects the developer to structure code in a certain way. OPAL expects features to be implemented as single page Angular.js applications, with the server mostly figuring as an API endpoint for reading and writing data. That said, the technology stack of Django, Angular Bootstrap allows the confident user a huge degree of flexibility when writing their own applications and plugins. For instance, there is nothing to stop a developer from implementing a part of the functionality in some other Javascript framework, and simply calling the JSON API . However, by doing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera. While possible, this approach is not likely to be officially supported in the medium term.","title":"Component Overview"},{"location":"guides/components_overview/#components-of-an-opal-application","text":"OPAL applications will typically be made up of several types of components.","title":"Components of an OPAL application"},{"location":"guides/components_overview/#opal","text":"The core OPAL framework provides you with a range of commonly required elements of clinical applications. It contains a core data model for persisting clinical information, as well core clinical archetypes out of the box that build on many years of collaboratively modelling clinical concepts by medical domain experts. OPAL also makes it easy to integrate standard clinical reference data into your application - things like medical diagnoses, tests, drugs et cetera. Some common functional components end up in to most clinical applications, and many of these come with OPAL as \"batteries included\" - immediately available modular features that can be simply re-used without having to reinvent the wheel. For example: Patient lists Search Authentication and Permissions Forms for data entry JSON based REST APIs for all of your models ... and many more ...","title":"OPAL"},{"location":"guides/components_overview/#plugins","text":"OPAL plugins are intended to provide high quality generic, composable, re-usable chunks of functionality that can be \"dropped in\" to an application. For example, installing the Dashboards plugin allows you to easily create clinical dashboards within your application. The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. Plugins have a rich plugin API they can hook into to, and many examples can be found by inspecting the source of existing plugins .","title":"Plugins"},{"location":"guides/components_overview/#applications","text":"An application is the collection of configuration and bespoke functionality that would be provided to an individual institution - it's the thing that you would look to deploy. Example applications include elCID - a for managing infection patients, or OPAL-Renal - an MDT handover tool for Renal wards. A hospital might have multiple clinical services running on one application, or multiple applications that integrate with one another.","title":"Applications"},{"location":"guides/components_overview/#opinionated-but-pluggable","text":"OPAL is an opinionated framework. It expects the developer to structure code in a certain way. OPAL expects features to be implemented as single page Angular.js applications, with the server mostly figuring as an API endpoint for reading and writing data. That said, the technology stack of Django, Angular Bootstrap allows the confident user a huge degree of flexibility when writing their own applications and plugins. For instance, there is nothing to stop a developer from implementing a part of the functionality in some other Javascript framework, and simply calling the JSON API . However, by doing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera. While possible, this approach is not likely to be officially supported in the medium term.","title":"Opinionated but Pluggable"},{"location":"guides/context_processors/","text":"Default context Processors settings all settings are copied into the context of the template models all subrecords are copied into the context of the template under the namespace models, e.g. the allergies subrecord can be referred to by models.Allergy","title":"Context Processors"},{"location":"guides/context_processors/#default-context-processors","text":"","title":"Default context Processors"},{"location":"guides/context_processors/#settings","text":"all settings are copied into the context of the template","title":"settings"},{"location":"guides/context_processors/#models","text":"all subrecords are copied into the context of the template under the namespace models, e.g. the allergies subrecord can be referred to by models.Allergy","title":"models"},{"location":"guides/datamodel/","text":"The OPAL Data model The OPAL data model allows for patients to have multiple sequential or concurrent Episodes of care . Some information is linked to an Episode , some is linked to a Patient . Patients A Patient may have many Episodes . An Episode is something like an Inpatient admission, a telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic. Applications or plugins may define their own Episode categories, and a common pattern is to alter the display or available functionality by episode type. (e.g. You may associate templates for discharge summaries with particular episode types) A Patient will have Subrecords (such as e.g. Demographics) which follow them across multiple episodes. These are information linked to a particular person, and should be implemented as Django models that inherit from the opal.models.PatientSubrecord base class. Episodes An Episode is linked to a Patient , and will contain some metadata about the type and date of the episode. The field Episode.category_name stores a string representing the relevant EpisodeCategory e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned from the episode.category field. The start and end dates of an Episode may be retrieved from the start and end properties. An Episode will have Subrecords (such as e.g. Diagnosis) which are linked to this episode of care. These should be implemented as Django models that inherit from the opal.models.EpisodeSubRecord base class. Records A Subrecord consists of a collection of fields that constitute a record. For example, one could implement a Demograpics Subrecord as follows: class Demographics(PatientSubrecord): name = models.CharField(max_length=255, blank=True) hospital_number = models.CharField(max_length=255, blank=True) date_of_birth = models.DateField(null=True, blank=True) ethnicity = models.CharField(max_length=255, blank=True, null=True) gender = models.CharField(max_length=255, blank=True, null=True) Subrecords also define various properties that will provide metadata about their display or structure, which are documented in the Subrecord reference material Core Clinical Data Model OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Full documentation of these models is available in the Archetypes documentation. Reference Data OPAL comes with a set of clinical terminology data models out of the box. - we often want to link our records to one of these - for example to record a type of condition a patient might have, or a drug they are taking. Full documentation of these is available in the Lookup lists documentation.","title":"Data Model"},{"location":"guides/datamodel/#the-opal-data-model","text":"The OPAL data model allows for patients to have multiple sequential or concurrent Episodes of care . Some information is linked to an Episode , some is linked to a Patient .","title":"The OPAL Data model"},{"location":"guides/datamodel/#patients","text":"A Patient may have many Episodes . An Episode is something like an Inpatient admission, a telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic. Applications or plugins may define their own Episode categories, and a common pattern is to alter the display or available functionality by episode type. (e.g. You may associate templates for discharge summaries with particular episode types) A Patient will have Subrecords (such as e.g. Demographics) which follow them across multiple episodes. These are information linked to a particular person, and should be implemented as Django models that inherit from the opal.models.PatientSubrecord base class.","title":"Patients"},{"location":"guides/datamodel/#episodes","text":"An Episode is linked to a Patient , and will contain some metadata about the type and date of the episode. The field Episode.category_name stores a string representing the relevant EpisodeCategory e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned from the episode.category field. The start and end dates of an Episode may be retrieved from the start and end properties. An Episode will have Subrecords (such as e.g. Diagnosis) which are linked to this episode of care. These should be implemented as Django models that inherit from the opal.models.EpisodeSubRecord base class.","title":"Episodes"},{"location":"guides/datamodel/#records","text":"A Subrecord consists of a collection of fields that constitute a record. For example, one could implement a Demograpics Subrecord as follows: class Demographics(PatientSubrecord): name = models.CharField(max_length=255, blank=True) hospital_number = models.CharField(max_length=255, blank=True) date_of_birth = models.DateField(null=True, blank=True) ethnicity = models.CharField(max_length=255, blank=True, null=True) gender = models.CharField(max_length=255, blank=True, null=True) Subrecords also define various properties that will provide metadata about their display or structure, which are documented in the Subrecord reference material","title":"Records"},{"location":"guides/datamodel/#core-clinical-data-model","text":"OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords. Applications that are generated via the $ opal startproject command will automatically contain concrete implementations of these models in the application. Full documentation of these models is available in the Archetypes documentation.","title":"Core Clinical Data Model"},{"location":"guides/datamodel/#reference-data","text":"OPAL comes with a set of clinical terminology data models out of the box. - we often want to link our records to one of these - for example to record a type of condition a patient might have, or a drug they are taking. Full documentation of these is available in the Lookup lists documentation.","title":"Reference Data"},{"location":"guides/discoverable/","text":"OPAL Discoverable Features OPAL makes extensive use of the case of discoverable features. These are pieces of composable functionality that can be implemented by any plugin or application, simply by declaring a class with the appropriate fields and methods implemented. (Details of exactly which fields and methods vary by feature.) Defining Discoverable Features The only thing required for a discoverable feature, is that it defines the name of the module in which it should expect to find instances. from opal.core import discoverable class MyFeature(discoverable.DiscoverableFeature): module_name = 'myfeature' This now gives us acces to various interfaces which come with the library. We can access all subclasses of MyFeature by calling MyFeature.list() - which will look through all Django apps in our application, and look for a module named myfeature.py . The list() method then returns any subclasses of MyFeature . Slugs and Display Names We often want to define human and machine readable strings to name our features. Display names are intended for people - feel free to include spaces, numbers and puctuation. Slugs are intended for machines - so no spaces, numbers, hypens, periods or other punctuation. By default, if there is a display name and no explicit slug, we wil 'slugify' the display name. class MyNameFeature(MyFeature): display_name = 'Hello World' print MyNameFeature.get_slug() # 'hello_world' class MySlugFeature(MyFeature): slug = 'this_is_a_slug' print MySlugFeature.get_slug() # 'this_is_a_slug' Retrieving Subclasses Once we define a display_name or slug for sublasses of our feature, we can then fetch them via the get() api. class RedFeature(MyFeature): slug = 'red_feature' MyFeature.get('red_feature') # - RedFeature Sortable Features We can make our feature sortable via an order property by including discoverable.SortableFeature as a parent class. This will ensure that MyFeature.list() respects the .order number of any subclass. class MyFeature(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name = 'myfeature' class ThirdFeature(MyFeature): order = 3 class FirstFeature(MyFeature): order = 1 class SecondFeature(MyFeature): order = 2 for f in MyFeature.list(): print f.order, f # class '*.*.FirstFeature' , 1 # class '*.*.SecondFeature' , 2 # class '*.*.ThirdFeature' , 3 Restrictable Features We can ensure that only particular users can access a feature by including discoverable.RestrictableFeature as a parent class, and implementing the visible_to classmethod on any restricted subclasses. class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name = 'myfeature' For instance, a feature that was only visible to superusers could be implemented like this: class SuperuserFeature(MyFeature): @classmethod def visible_to(klass, user): return user.is_superuser Validating Features Sometimes we wish to validate features so that we don't cause unintended consequences when we implement subclasses of them. This is available via the is_valid classmethod. For instance, if we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was true, we could to this as follows: class BombFeature(discoverable.DiscoverableFeature): module_name = 'bombs' blow_up = False @classmethod def is_valid(klass): if klass.blow_up == True: from opal.core.exceptions import InvalidDiscoverableFeatureError raise InvalidDiscoverableFeatureError('BLOWING UP') class Threat(BombFeature): pass # That's fine. class Detonate(BombFeature): blow_up = True # InvalidDiscoverableFeatureError: BLOWING UP Abstract Features Sometimes we want to declare an abstract feature - something with reusable functionality that isn't itself a new feature. We would rather not have our abstract feature show up when we list() our base feature - because it's simply a programming convenience. This is made simple by using opal.utils.AbstractBase . class A(discoverable.DiscoverableFeature): module_name = 'a' class AA(A, AbstractBase): pass class B(A): pass class C(AA): pass class D(AA): pass A.list() # [B, C, D]","title":"Discoverable Features"},{"location":"guides/discoverable/#opal-discoverable-features","text":"OPAL makes extensive use of the case of discoverable features. These are pieces of composable functionality that can be implemented by any plugin or application, simply by declaring a class with the appropriate fields and methods implemented. (Details of exactly which fields and methods vary by feature.)","title":"OPAL Discoverable Features"},{"location":"guides/discoverable/#defining-discoverable-features","text":"The only thing required for a discoverable feature, is that it defines the name of the module in which it should expect to find instances. from opal.core import discoverable class MyFeature(discoverable.DiscoverableFeature): module_name = 'myfeature' This now gives us acces to various interfaces which come with the library. We can access all subclasses of MyFeature by calling MyFeature.list() - which will look through all Django apps in our application, and look for a module named myfeature.py . The list() method then returns any subclasses of MyFeature .","title":"Defining Discoverable Features"},{"location":"guides/discoverable/#slugs-and-display-names","text":"We often want to define human and machine readable strings to name our features. Display names are intended for people - feel free to include spaces, numbers and puctuation. Slugs are intended for machines - so no spaces, numbers, hypens, periods or other punctuation. By default, if there is a display name and no explicit slug, we wil 'slugify' the display name. class MyNameFeature(MyFeature): display_name = 'Hello World' print MyNameFeature.get_slug() # 'hello_world' class MySlugFeature(MyFeature): slug = 'this_is_a_slug' print MySlugFeature.get_slug() # 'this_is_a_slug'","title":"Slugs and Display Names"},{"location":"guides/discoverable/#retrieving-subclasses","text":"Once we define a display_name or slug for sublasses of our feature, we can then fetch them via the get() api. class RedFeature(MyFeature): slug = 'red_feature' MyFeature.get('red_feature') # - RedFeature","title":"Retrieving Subclasses"},{"location":"guides/discoverable/#sortable-features","text":"We can make our feature sortable via an order property by including discoverable.SortableFeature as a parent class. This will ensure that MyFeature.list() respects the .order number of any subclass. class MyFeature(discoverable.DiscoverableFeature, discoverable.SortableFeature): module_name = 'myfeature' class ThirdFeature(MyFeature): order = 3 class FirstFeature(MyFeature): order = 1 class SecondFeature(MyFeature): order = 2 for f in MyFeature.list(): print f.order, f # class '*.*.FirstFeature' , 1 # class '*.*.SecondFeature' , 2 # class '*.*.ThirdFeature' , 3","title":"Sortable Features"},{"location":"guides/discoverable/#restrictable-features","text":"We can ensure that only particular users can access a feature by including discoverable.RestrictableFeature as a parent class, and implementing the visible_to classmethod on any restricted subclasses. class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature): module_name = 'myfeature' For instance, a feature that was only visible to superusers could be implemented like this: class SuperuserFeature(MyFeature): @classmethod def visible_to(klass, user): return user.is_superuser","title":"Restrictable Features"},{"location":"guides/discoverable/#validating-features","text":"Sometimes we wish to validate features so that we don't cause unintended consequences when we implement subclasses of them. This is available via the is_valid classmethod. For instance, if we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was true, we could to this as follows: class BombFeature(discoverable.DiscoverableFeature): module_name = 'bombs' blow_up = False @classmethod def is_valid(klass): if klass.blow_up == True: from opal.core.exceptions import InvalidDiscoverableFeatureError raise InvalidDiscoverableFeatureError('BLOWING UP') class Threat(BombFeature): pass # That's fine. class Detonate(BombFeature): blow_up = True # InvalidDiscoverableFeatureError: BLOWING UP","title":"Validating Features"},{"location":"guides/discoverable/#abstract-features","text":"Sometimes we want to declare an abstract feature - something with reusable functionality that isn't itself a new feature. We would rather not have our abstract feature show up when we list() our base feature - because it's simply a programming convenience. This is made simple by using opal.utils.AbstractBase . class A(discoverable.DiscoverableFeature): module_name = 'a' class AA(A, AbstractBase): pass class B(A): pass class C(AA): pass class D(AA): pass A.list() # [B, C, D]","title":"Abstract Features"},{"location":"guides/dump/","text":"Your implementation Your implementation is a Django project with some extras. OPAL settings OPAL_LOG_OUT_DURATION = The number of milliseconds after which to log out our user OPAL_BRAND_NAME = The branding to be displayed as the masthead OPAL_EXTRA_APPLICATION = A template to include in the HEAD OPAL_EXTRA_HEADER = A template to include above the main nav Defining Models Models should be defined in your project. They should subclass opal.models.EpisodeSubrecord or opal.models.PatientSubrecord as appropriate. Subrecords have some extra entrypoints that are used by OPAL. _is_singleton _is_singleton is a boolean property that ensures that there is only one of this subrecord per patient/episode. Effectively this defaults to False. _title _title sets the column headings in list view. Effectively this defaults to camel_case_to_underscore() on the class name. _sort _sort names a field by which we would like to sorth the display of subrecords. _read_only Marks a field as read only if True _batch_template Allow the list/detail template access to the complete row, not just an item. Template is then responsible for registering click handlers. Will get cix as a variable representing the column index, column_name as the column name. Adding a controller Create the controller file in static/js/opal/controllers. Use the angular module opal.controllers Include this file in templates/opal.html Create a template url in the django layer Creating a Heroku test server $ heroku create $YOUR_APP_NAME (Edit .git/config to give the remote a meaningful name) $ heroku addons:create heroku-postgresql --app $YOUR_APP_NAME $ git push $YOUR_REMOTE_NAME $YOUR_BRANCH:master $ heroku run python manage.py syncdb --migrate --app $YOUR_APP_NAME $ heroku run python manage.py load_lookup_lists -f data/lookuplists/lookuplists.json --app $YOUR_APP_NAME $ heroku run python manage.py createinitialrevisions --app $YOUR_APP_NAME","title":"Your implementation"},{"location":"guides/dump/#your-implementation","text":"Your implementation is a Django project with some extras.","title":"Your implementation"},{"location":"guides/dump/#opal-settings","text":"OPAL_LOG_OUT_DURATION = The number of milliseconds after which to log out our user OPAL_BRAND_NAME = The branding to be displayed as the masthead OPAL_EXTRA_APPLICATION = A template to include in the HEAD OPAL_EXTRA_HEADER = A template to include above the main nav","title":"OPAL settings"},{"location":"guides/dump/#defining-models","text":"Models should be defined in your project. They should subclass opal.models.EpisodeSubrecord or opal.models.PatientSubrecord as appropriate. Subrecords have some extra entrypoints that are used by OPAL.","title":"Defining Models"},{"location":"guides/dump/#_is_singleton","text":"_is_singleton is a boolean property that ensures that there is only one of this subrecord per patient/episode. Effectively this defaults to False.","title":"_is_singleton"},{"location":"guides/dump/#_title","text":"_title sets the column headings in list view. Effectively this defaults to camel_case_to_underscore() on the class name.","title":"_title"},{"location":"guides/dump/#_sort","text":"_sort names a field by which we would like to sorth the display of subrecords.","title":"_sort"},{"location":"guides/dump/#_read_only","text":"Marks a field as read only if True","title":"_read_only"},{"location":"guides/dump/#_batch_template","text":"Allow the list/detail template access to the complete row, not just an item. Template is then responsible for registering click handlers. Will get cix as a variable representing the column index, column_name as the column name.","title":"_batch_template"},{"location":"guides/dump/#adding-a-controller","text":"Create the controller file in static/js/opal/controllers. Use the angular module opal.controllers Include this file in templates/opal.html Create a template url in the django layer","title":"Adding a controller"},{"location":"guides/dump/#creating-a-heroku-test-server","text":"$ heroku create $YOUR_APP_NAME (Edit .git/config to give the remote a meaningful name) $ heroku addons:create heroku-postgresql --app $YOUR_APP_NAME $ git push $YOUR_REMOTE_NAME $YOUR_BRANCH:master $ heroku run python manage.py syncdb --migrate --app $YOUR_APP_NAME $ heroku run python manage.py load_lookup_lists -f data/lookuplists/lookuplists.json --app $YOUR_APP_NAME $ heroku run python manage.py createinitialrevisions --app $YOUR_APP_NAME","title":"Creating a Heroku test server"},{"location":"guides/flow/","text":"Flow hooks in OPAL OPAL provides various hooks that developers can use to customise behaviour at certain key points in a patient's journey through a clinical service - for example when a patient is discharged. These hooks are associated with verbs enter , exit . The Flow service Your application scaffold will have created a file at ./yourapp/assets/js/yourapp/services/flow.js . This file will declare an angular service that your application will use to determine how to move to the correct next step for a patient. To enable this, we must set the following setting: # settings.py OPAL_FLOW_SERVICE = 'MyAppFlow' Flow services must define an enter and an exit method, which both return the appropriate angular controller and template to use. Although OPAL provides sensible default controllers and templates for these common actions, applications with custom flows may customise these methods as required. The enter verb The enter verb is called when a patient is added to a service - for instance by adding a patient to a team list. Implementations of enter are expected to return a dictionary of the controller and template they wish to be called. enter: function(){ return { 'controller': 'HospitalNumberCtrl', 'template' : '/templates/modals/hospital_number.html/' } } A common strategy is to examine angular $route or $routeParams to determine where the user is in the application. For instance you may wish to have custom controllers for a particular patient list, or the search results page. The exit verb The exit verb is called when a patient is moving through a service - for instance when we discharge a patient, or end one phase of a clinical pathway. Implementations of exit are expected to return a dictionary of the controller and template they wish to be called. The enter verb will receive the episode that we are acting on - for instance a controller that acts differently for deceased patients might look as follows exit: function(episode){ if(episode.demographics[0].deceased){ return { 'controller': 'DeceasedDischargeEpisodeCtrl', 'template' : '/templates/modals/deceased_discharge.html/' } } return { 'controller': 'DischargeEpisodeCtrl', 'template' : '/templates/modals/discharge_episode.html/' } }","title":"Flow"},{"location":"guides/flow/#flow-hooks-in-opal","text":"OPAL provides various hooks that developers can use to customise behaviour at certain key points in a patient's journey through a clinical service - for example when a patient is discharged. These hooks are associated with verbs enter , exit .","title":"Flow hooks in OPAL"},{"location":"guides/flow/#the-flow-service","text":"Your application scaffold will have created a file at ./yourapp/assets/js/yourapp/services/flow.js . This file will declare an angular service that your application will use to determine how to move to the correct next step for a patient. To enable this, we must set the following setting: # settings.py OPAL_FLOW_SERVICE = 'MyAppFlow' Flow services must define an enter and an exit method, which both return the appropriate angular controller and template to use. Although OPAL provides sensible default controllers and templates for these common actions, applications with custom flows may customise these methods as required.","title":"The Flow service"},{"location":"guides/flow/#the-enter-verb","text":"The enter verb is called when a patient is added to a service - for instance by adding a patient to a team list. Implementations of enter are expected to return a dictionary of the controller and template they wish to be called. enter: function(){ return { 'controller': 'HospitalNumberCtrl', 'template' : '/templates/modals/hospital_number.html/' } } A common strategy is to examine angular $route or $routeParams to determine where the user is in the application. For instance you may wish to have custom controllers for a particular patient list, or the search results page.","title":"The enter verb"},{"location":"guides/flow/#the-exit-verb","text":"The exit verb is called when a patient is moving through a service - for instance when we discharge a patient, or end one phase of a clinical pathway. Implementations of exit are expected to return a dictionary of the controller and template they wish to be called. The enter verb will receive the episode that we are acting on - for instance a controller that acts differently for deceased patients might look as follows exit: function(episode){ if(episode.demographics[0].deceased){ return { 'controller': 'DeceasedDischargeEpisodeCtrl', 'template' : '/templates/modals/deceased_discharge.html/' } } return { 'controller': 'DischargeEpisodeCtrl', 'template' : '/templates/modals/discharge_episode.html/' } }","title":"The exit verb"},{"location":"guides/forms/","text":"Forms Editing Records The editing of records is a key component of any OPAL application. A key pattern is to edit or create an individual record in a modal containing the form for just that record. OPAL provides the Angular Controller opal.controllers.EditItemCtrl for doing just this Customising the Angular Controller OPAL uses the formController attribute of an Item to determine which Angular Controller to use. This defaults to opal.controllers.EditItemCtrl . Individual Subrecords may customise this by implementing an Angualar record Service and overriding the formController attribute. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ record.formController = 'MyCustomDiagnosisFormController'; return record; } }); Custom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved Form and modal templates Subrecords have get_form_template() and get_modal_template() methods, which are used for figuring out how to render forms for interacting with them. These use the following template paths based on the context in which they are called: # Forms forms/{episode_type}/{list slug}/{record_name}_form.html forms/{list_slug}/{record_name}_form.html forms/{episode_type}/{record_name}_form.html forms/{record_name}_form.html # Modals modals/{episode_type}/{list slug}/{record_name}_modal.html modals/{list_slug}/{record_name}_modal.html modals/{episode_type}/{record_name}_modal.html modals/{record_name}_modal.html Autogenerating forms The opal commandline tool has a scaffold command, which will autogenerate missing form templates for subrecord models. Simply run the following command to generate. $ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE (Note this will also generate and run migrations for any unmigrated models.xb) Client side Validation Client side validation for forms requires a pattern and a help block uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input) Helpers OPAL contains a number of helpers for developing forms and input modals. Many of these are located in the forms template tag library, which is a Django templatetag library that understands the context of common patterns with OPAL for creating forms and modals. It provides helpers for various input types that will allow you to render consistent forms, with less verbose templates. {% load forms %} form class=\"form-horizontal\" {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %} {% datepicker label=\"Date\" model=\"editing.date\" %} {% checkbox label=\"Alone?\" model=\"editing.alone\" %} /form For full documentation of the options, please see the Form templatetags reference material","title":"Forms"},{"location":"guides/forms/#forms","text":"","title":"Forms"},{"location":"guides/forms/#editing-records","text":"The editing of records is a key component of any OPAL application. A key pattern is to edit or create an individual record in a modal containing the form for just that record. OPAL provides the Angular Controller opal.controllers.EditItemCtrl for doing just this","title":"Editing Records"},{"location":"guides/forms/#customising-the-angular-controller","text":"OPAL uses the formController attribute of an Item to determine which Angular Controller to use. This defaults to opal.controllers.EditItemCtrl . Individual Subrecords may customise this by implementing an Angualar record Service and overriding the formController attribute. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ record.formController = 'MyCustomDiagnosisFormController'; return record; } }); Custom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved","title":"Customising the Angular Controller"},{"location":"guides/forms/#form-and-modal-templates","text":"Subrecords have get_form_template() and get_modal_template() methods, which are used for figuring out how to render forms for interacting with them. These use the following template paths based on the context in which they are called: # Forms forms/{episode_type}/{list slug}/{record_name}_form.html forms/{list_slug}/{record_name}_form.html forms/{episode_type}/{record_name}_form.html forms/{record_name}_form.html # Modals modals/{episode_type}/{list slug}/{record_name}_modal.html modals/{list_slug}/{record_name}_modal.html modals/{episode_type}/{record_name}_modal.html modals/{record_name}_modal.html","title":"Form and modal templates"},{"location":"guides/forms/#autogenerating-forms","text":"The opal commandline tool has a scaffold command, which will autogenerate missing form templates for subrecord models. Simply run the following command to generate. $ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE (Note this will also generate and run migrations for any unmigrated models.xb)","title":"Autogenerating forms"},{"location":"guides/forms/#client-side-validation","text":"Client side validation for forms requires a pattern and a help block uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input)","title":"Client side Validation"},{"location":"guides/forms/#helpers","text":"OPAL contains a number of helpers for developing forms and input modals. Many of these are located in the forms template tag library, which is a Django templatetag library that understands the context of common patterns with OPAL for creating forms and modals. It provides helpers for various input types that will allow you to render consistent forms, with less verbose templates. {% load forms %} form class=\"form-horizontal\" {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %} {% datepicker label=\"Date\" model=\"editing.date\" %} {% checkbox label=\"Alone?\" model=\"editing.alone\" %} /form For full documentation of the options, please see the Form templatetags reference material","title":"Helpers"},{"location":"guides/json_api/","text":"The OPAL JSON API OPAL features a rich, self documenting set of open JSON APIs. OPAL applications are generally simply a collection of Browser-based clients for these APIs. OPAL uses Django Rest Framework to provide it's APIs. You may examine the API of any running OPAL application by navigating to the url /api/v0.1/ Adding your own APIs You can add your own APIs to the OPAL API namespae from plugins or by registering them directly with the router. from rest_framework.viewsets import ViewSet from rest_framework.response import Response from opal.core.api import router class PingViewSet(ViewSet): def list(self, request): return Response('pong') router.register('ping', PingViewSet)","title":"JSON API"},{"location":"guides/json_api/#the-opal-json-api","text":"OPAL features a rich, self documenting set of open JSON APIs. OPAL applications are generally simply a collection of Browser-based clients for these APIs. OPAL uses Django Rest Framework to provide it's APIs. You may examine the API of any running OPAL application by navigating to the url /api/v0.1/","title":"The OPAL JSON API"},{"location":"guides/json_api/#adding-your-own-apis","text":"You can add your own APIs to the OPAL API namespae from plugins or by registering them directly with the router. from rest_framework.viewsets import ViewSet from rest_framework.response import Response from opal.core.api import router class PingViewSet(ViewSet): def list(self, request): return Response('pong') router.register('ping', PingViewSet)","title":"Adding your own APIs"},{"location":"guides/list_views/","text":"OPAL Patient List views OPAL provides support for displaying lists of patients, both via a spreadsheet like view, and with a card based view. Defining lists OPAL patient lists are subclasses of opal.core.patient_lists.PatientList . Typically these are found in a patient_lists.py module of your application or plugin. (Lists can be defined elsewhere, but may not be autodiscovered.) A basic list needs only define it's display_name a queryset of episodes to display, and a schema of subrecords to show for each episode. # patient_lists.py from opal.models import Episore from opal.core import patient_lists from myapplication import models class AlphabetListA(patient_lists.PatientList): display_name = 'A Patients' queryset = Episode.objects.filter(demographics__name__istartswith='a') schema = [ models.Demographics, models.Location, models.Diagnosis, models.Treatment ] The display_name property is the human readable name for our list - which is displayed as link text to our list. Schemas Schemas are lists of Subrecords that we would like to display in our list. By default we render the subrecord display_template, and allow editing and addition of each subrecord in place. Template selection The list view is constructed by rendering a column for each record, in the order defined in the schema, and a row for each episode in the list. The template for each cell should live in ./templates/records/* . In order to select the appropriate template for a given episode, OPAL looks in the following locations: records/{episode_type}/{list slug}/{record_name}.html records/{list_slug}/{record_name}.html records/{episode_type}/{record_name}.html records/{record_name}.html Querysets The queryset property of your list should contain all of the episodes for this particular list. On occasion we require a more dynamic queryset, in which case we can ovreride the get_queryset method. # patient_lists.py import datetime from opal.models import Episode from opal.core import patient_lists class MyWeeklyList(patient_lists.PatientList): def get_queryset(self): one_week_ago = datetime.date.today() - datetime.timedelta(days=1) return Episode.objects.filter(date_of_admission__gte=one_week_ago) Ordering Lists As a discoverable.SortableFeature lists may be ordered by setting the order property to an integer. Lists will display in drop-downs, tables et cetera, in this order. Slug As a discoverable feature, the slug for each list is determined by either setting the slug property, or returning a string from the get_slug classmethod. Templates Tagged Patient Lists A common model for working with lists is to use lists based on the tags assigned to an episode. This allows users to add and remove patients from lists as they see fit, rather than attempting to infer it from other properties of the patient (e.g. their current location for instance.) which can be particularly challenging for some clinical services. OPAL provides a specific subclass for working with Tagged Patient Lists: # patient_lists.py from opal.core import patient_lists class MyTagList(patient_lists.TaggedPatientList): display_name = 'Tagged blue' tag = 'blue' Tagged lists will automatically fetch the appropriate queryset for patients tagged with the tag you specify. Invalid Tagged Patient Lists Tag names may not have hyphens in them - OPAL uses hyphens to distinguish between tags and subtags in the urls for lists, so attempting to define one will raise an exception. class MyList(TaggedPatientList): tag = 'foo-bar' # This will raise InvalidDiscoverableFeatureError ! Direct Add Sometimes, we want to control the flow of patients onto, off, or between lists a little more closely. For instance, we might need to ensure additional data collection at points in a patient journey. In order to accomplish this, we often implement custom patient flows that wil programatically tag episodes to tagged lists. In those cases we will want to prevent users from manually adding or removing the tags themselves. This can be easily accomplished via the direct_add property. When set to false, users will not be able to add the tag for this list. class MyLockedDownList(TaggedPatientList): tag = 'liaisonpatients' direct_add = False Access Control As PatientLists are a RestrictableFeature , Access control for lists is set by overriding the visible_to classmethod. Your list will only be visible to those users for whom this method returns True . For instance, we could define a Patient List that was only available to Django Superusers: class SuperuserPatientList(PatientList): @classmethod def visible_to(klass, user): return user.is_superuser","title":"Patient List Views"},{"location":"guides/list_views/#opal-patient-list-views","text":"OPAL provides support for displaying lists of patients, both via a spreadsheet like view, and with a card based view.","title":"OPAL Patient List views"},{"location":"guides/list_views/#defining-lists","text":"OPAL patient lists are subclasses of opal.core.patient_lists.PatientList . Typically these are found in a patient_lists.py module of your application or plugin. (Lists can be defined elsewhere, but may not be autodiscovered.) A basic list needs only define it's display_name a queryset of episodes to display, and a schema of subrecords to show for each episode. # patient_lists.py from opal.models import Episore from opal.core import patient_lists from myapplication import models class AlphabetListA(patient_lists.PatientList): display_name = 'A Patients' queryset = Episode.objects.filter(demographics__name__istartswith='a') schema = [ models.Demographics, models.Location, models.Diagnosis, models.Treatment ] The display_name property is the human readable name for our list - which is displayed as link text to our list.","title":"Defining lists"},{"location":"guides/list_views/#schemas","text":"Schemas are lists of Subrecords that we would like to display in our list. By default we render the subrecord display_template, and allow editing and addition of each subrecord in place.","title":"Schemas"},{"location":"guides/list_views/#template-selection","text":"The list view is constructed by rendering a column for each record, in the order defined in the schema, and a row for each episode in the list. The template for each cell should live in ./templates/records/* . In order to select the appropriate template for a given episode, OPAL looks in the following locations: records/{episode_type}/{list slug}/{record_name}.html records/{list_slug}/{record_name}.html records/{episode_type}/{record_name}.html records/{record_name}.html","title":"Template selection"},{"location":"guides/list_views/#querysets","text":"The queryset property of your list should contain all of the episodes for this particular list. On occasion we require a more dynamic queryset, in which case we can ovreride the get_queryset method. # patient_lists.py import datetime from opal.models import Episode from opal.core import patient_lists class MyWeeklyList(patient_lists.PatientList): def get_queryset(self): one_week_ago = datetime.date.today() - datetime.timedelta(days=1) return Episode.objects.filter(date_of_admission__gte=one_week_ago)","title":"Querysets"},{"location":"guides/list_views/#ordering-lists","text":"As a discoverable.SortableFeature lists may be ordered by setting the order property to an integer. Lists will display in drop-downs, tables et cetera, in this order.","title":"Ordering Lists"},{"location":"guides/list_views/#slug","text":"As a discoverable feature, the slug for each list is determined by either setting the slug property, or returning a string from the get_slug classmethod.","title":"Slug"},{"location":"guides/list_views/#templates","text":"","title":"Templates"},{"location":"guides/list_views/#tagged-patient-lists","text":"A common model for working with lists is to use lists based on the tags assigned to an episode. This allows users to add and remove patients from lists as they see fit, rather than attempting to infer it from other properties of the patient (e.g. their current location for instance.) which can be particularly challenging for some clinical services. OPAL provides a specific subclass for working with Tagged Patient Lists: # patient_lists.py from opal.core import patient_lists class MyTagList(patient_lists.TaggedPatientList): display_name = 'Tagged blue' tag = 'blue' Tagged lists will automatically fetch the appropriate queryset for patients tagged with the tag you specify.","title":"Tagged Patient Lists"},{"location":"guides/list_views/#invalid-tagged-patient-lists","text":"Tag names may not have hyphens in them - OPAL uses hyphens to distinguish between tags and subtags in the urls for lists, so attempting to define one will raise an exception. class MyList(TaggedPatientList): tag = 'foo-bar' # This will raise InvalidDiscoverableFeatureError !","title":"Invalid Tagged Patient Lists"},{"location":"guides/list_views/#direct-add","text":"Sometimes, we want to control the flow of patients onto, off, or between lists a little more closely. For instance, we might need to ensure additional data collection at points in a patient journey. In order to accomplish this, we often implement custom patient flows that wil programatically tag episodes to tagged lists. In those cases we will want to prevent users from manually adding or removing the tags themselves. This can be easily accomplished via the direct_add property. When set to false, users will not be able to add the tag for this list. class MyLockedDownList(TaggedPatientList): tag = 'liaisonpatients' direct_add = False","title":"Direct Add"},{"location":"guides/list_views/#access-control","text":"As PatientLists are a RestrictableFeature , Access control for lists is set by overriding the visible_to classmethod. Your list will only be visible to those users for whom this method returns True . For instance, we could define a Patient List that was only available to Django Superusers: class SuperuserPatientList(PatientList): @classmethod def visible_to(klass, user): return user.is_superuser","title":"Access Control"},{"location":"guides/lookup_lists/","text":"OPAL Lookup Lists Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override. Adding a lookup list Lookup lists are subclasses of opal.core.lookuplists.LookupList . Typically, a specific named lookup list will not need to do anything other than define a class that inherits from the base class. The custom field type opal.core.fields.ForeignKeyOrFreeText allows you to build interfaces that cater for synonyms, and also allow the user to enter a free text string that is not in the lookup list. # yourapp.models from django.db import models from opal.core import lookuplists from opal.core.fields import ForeignKeyOrFreeText from opal.models import EpisodeSubrecord class TreatmentType(lookuplists.LookupList): pass class Treatment(EpisodeSubrecord): treatment = ForeignKeyOrFreeText(TreatmentType) notes = models.CharField(max_length=200) # yourapp.models When you create your lookup list, you are creating a new model, so you will need a new migration to accompany it. $ python manage.py schemamigration --atuo yourapp $ python manage.py migrate yourapp The lookup list will automatically be added to the admin. Management commands OPAL ships with some managemnent commands for importing and exporting lookup lists dump_lookup_lists Prints all lookuplists as JSON to stdout. load_lookup_lists -f [filename] Loads lookup lists in the OPAL JSON format. delete_all_lookuplists Deletes all currently lookuplist values and related synonyms","title":"Lookup Lists"},{"location":"guides/lookup_lists/#opal-lookup-lists","text":"Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while also allowing synonymous terms, and a free text override.","title":"OPAL Lookup Lists"},{"location":"guides/lookup_lists/#adding-a-lookup-list","text":"Lookup lists are subclasses of opal.core.lookuplists.LookupList . Typically, a specific named lookup list will not need to do anything other than define a class that inherits from the base class. The custom field type opal.core.fields.ForeignKeyOrFreeText allows you to build interfaces that cater for synonyms, and also allow the user to enter a free text string that is not in the lookup list. # yourapp.models from django.db import models from opal.core import lookuplists from opal.core.fields import ForeignKeyOrFreeText from opal.models import EpisodeSubrecord class TreatmentType(lookuplists.LookupList): pass class Treatment(EpisodeSubrecord): treatment = ForeignKeyOrFreeText(TreatmentType) notes = models.CharField(max_length=200) # yourapp.models When you create your lookup list, you are creating a new model, so you will need a new migration to accompany it. $ python manage.py schemamigration --atuo yourapp $ python manage.py migrate yourapp The lookup list will automatically be added to the admin.","title":"Adding a lookup list"},{"location":"guides/lookup_lists/#management-commands","text":"OPAL ships with some managemnent commands for importing and exporting lookup lists","title":"Management commands"},{"location":"guides/lookup_lists/#dump_lookup_lists","text":"Prints all lookuplists as JSON to stdout.","title":"dump_lookup_lists"},{"location":"guides/lookup_lists/#load_lookup_lists-f-filename","text":"Loads lookup lists in the OPAL JSON format.","title":"load_lookup_lists -f [filename]"},{"location":"guides/lookup_lists/#delete_all_lookuplists","text":"Deletes all currently lookuplist values and related synonyms","title":"delete_all_lookuplists"},{"location":"guides/patient_detail_views/","text":"OPAL Patient Detail Views OPAL provides all patients with a detail view. The default detail view will allow the user to switch between all of a patient's episodes , as well as editing patient information linked to the patient rather than an episode. (Allergies for example.) Template selection The base template for a patient detail view is ./opal/templates/patient_detail_base.html , although you can override or customise that for your application most easily by implementing a ./templates/patient_detail.html and customising specific blocks, as the OPAL implementation simply includes the base template. Each episode will display using the template appropriate for it's EpisodeCategory - for instance an InpatientEpisode will use ./templates/detail/inpatient.html . You may define your own episode types should you require. Record Panels A frequent pattern when constructing detail views is to render a panel for a particular Subrecord type. The panels templatetag library contains some useful helpers for rendering panels based on models. {% load panels %} {% record_panel Diagnosis %} The above code will render a panel for your episode, including the Subrecord detail template for each instance, and allowing editing, deletion and creation of instances of your Subrecord . You may also consult the Detailed reference documentation for Record Panels. Custom Patient Detail Views Sometimes we also need to display information about a patient across multiple episodes, or simlply a particular view of one episode. For instance, you might like to have a specific view for showing all of the lab results for a patient, which would be overwhelming were they all displayed in the episode detail view. OPAL's PatientDetailView allows you to do just this. To add an additional view to a patient you simply declare a PatientDetailView class: # detail.py from opal.core import detail class MyCustomView(detail.PatientDetailView): name = 'my_custom_view' title = 'Special View' template = 'detail/my_custom_view.html' This will then be available in the Patient Detail view in the episode switcher menu. You can find details of all the various options for PatientDetailViews in the reference documentation .","title":"Patient Detail Views"},{"location":"guides/patient_detail_views/#opal-patient-detail-views","text":"OPAL provides all patients with a detail view. The default detail view will allow the user to switch between all of a patient's episodes , as well as editing patient information linked to the patient rather than an episode. (Allergies for example.)","title":"OPAL Patient Detail Views"},{"location":"guides/patient_detail_views/#template-selection","text":"The base template for a patient detail view is ./opal/templates/patient_detail_base.html , although you can override or customise that for your application most easily by implementing a ./templates/patient_detail.html and customising specific blocks, as the OPAL implementation simply includes the base template. Each episode will display using the template appropriate for it's EpisodeCategory - for instance an InpatientEpisode will use ./templates/detail/inpatient.html . You may define your own episode types should you require.","title":"Template selection"},{"location":"guides/patient_detail_views/#record-panels","text":"A frequent pattern when constructing detail views is to render a panel for a particular Subrecord type. The panels templatetag library contains some useful helpers for rendering panels based on models. {% load panels %} {% record_panel Diagnosis %} The above code will render a panel for your episode, including the Subrecord detail template for each instance, and allowing editing, deletion and creation of instances of your Subrecord . You may also consult the Detailed reference documentation for Record Panels.","title":"Record Panels"},{"location":"guides/patient_detail_views/#custom-patient-detail-views","text":"Sometimes we also need to display information about a patient across multiple episodes, or simlply a particular view of one episode. For instance, you might like to have a specific view for showing all of the lab results for a patient, which would be overwhelming were they all displayed in the episode detail view. OPAL's PatientDetailView allows you to do just this. To add an additional view to a patient you simply declare a PatientDetailView class: # detail.py from opal.core import detail class MyCustomView(detail.PatientDetailView): name = 'my_custom_view' title = 'Special View' template = 'detail/my_custom_view.html' This will then be available in the Patient Detail view in the episode switcher menu. You can find details of all the various options for PatientDetailViews in the reference documentation .","title":"Custom Patient Detail Views"},{"location":"guides/plugins/","text":"Writing Plugins OPAL Plugins are Django apps on the server side, and collections of angular.js models for the client. Getting started with your plugin The OPAL commandline tool will bootstrap your plugin for you - just run: $ opal startplugin yourcoolplugin Adding Discoverable Functionality A common pattern for plugins is to add functionality that other plugins or applications can use by inheriting a base class that you define in a file with a magic name. (In much the same way that Django provides models.) For example, if you're creating an appointments plugin that helps people to book and schedule appointments in clinics, you would create a base Clinic class that can be subclassed to create specific clinics. class Clinic(opal.core.discoverable.DiscoverableFeature): module_name = 'clinics' We can then create clinics in any installed app, and they will be available from Clinic.list() class OutpatientsClinic(Clinic): name = 'Outpatients' # Add your custom clnic functionality here e.g. def book_appointment(self, date, patient): pass Clinic.list() # - Generator including OutPatientsClinic Clinic.get('outpatients) # - OutpatientsClinic Defining new flows Plugins can define flows. They should return a dictionary of flows from the flows() method of the plugin class. Adding URLS Add an urls.py, then add to your plugin class as YourPlugin.urls Naturally, these can point to views in your plugin! Adding Javascript add to static, then add to your plugin class as YourPlugin.javascripts There are some restricted namespaces for these... Adding APIs OPAL uses Django Rest Framweork to provide APIs, and you may add to these from your plugin. By convention, APIs live in yourplugin/api.py . You are expected to provide a rest_framework.viewsets.ViewSet subclass, which you then detail as the .apis attribute of your plugin. # yourplugin/api.py from rest_framework.viewsets import ViewSet from rest_framework.response import Response class PingViewSet(ViewSet): def list(self, request): return Response('pong') # yourplugin/__init__.py from opal.core.plugins import OpalPlugin from yourplugin import api class YourPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ] These APIs will then be available and self-documenting fom the standard OPAL url /api/v0.1/ Adding Actions to the sidebar Actions can be added to the sidebar by setting the actions attribute of your plugin. Actions is expected to be an iterable of strings which are templates to be included in the sidebar. By convention, actions will live in ./templates/actions/ . # __init__.py: class Plugin(OpalPlugin): actions = ('actions/javascript_alert.html', 'actions/dummy_button.html') And then in the template: p ng-show=\"episode.category == 'YourEpisodeCategory'\" button class=\"btn btn-primary\" ng-click=\"alert('Boom!')\" i href=\"fa fa-warning\" /i ALERT ME /button /p Adding dependencies globally to our angular modules Dependencies listed in angular_module_deps will be added to all Angular modules (as long as they use the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we won't for now. Installing plugins Add to installed apps Add to requirements if appropriate Adding extra markup to the tag Any templates you define in the property .head_extra will be included in the","title":"Plugins"},{"location":"guides/plugins/#writing-plugins","text":"OPAL Plugins are Django apps on the server side, and collections of angular.js models for the client.","title":"Writing Plugins"},{"location":"guides/plugins/#getting-started-with-your-plugin","text":"The OPAL commandline tool will bootstrap your plugin for you - just run: $ opal startplugin yourcoolplugin","title":"Getting started with your plugin"},{"location":"guides/plugins/#adding-discoverable-functionality","text":"A common pattern for plugins is to add functionality that other plugins or applications can use by inheriting a base class that you define in a file with a magic name. (In much the same way that Django provides models.) For example, if you're creating an appointments plugin that helps people to book and schedule appointments in clinics, you would create a base Clinic class that can be subclassed to create specific clinics. class Clinic(opal.core.discoverable.DiscoverableFeature): module_name = 'clinics' We can then create clinics in any installed app, and they will be available from Clinic.list() class OutpatientsClinic(Clinic): name = 'Outpatients' # Add your custom clnic functionality here e.g. def book_appointment(self, date, patient): pass Clinic.list() # - Generator including OutPatientsClinic Clinic.get('outpatients) # - OutpatientsClinic","title":"Adding Discoverable Functionality"},{"location":"guides/plugins/#defining-new-flows","text":"Plugins can define flows. They should return a dictionary of flows from the flows() method of the plugin class.","title":"Defining new flows"},{"location":"guides/plugins/#adding-urls","text":"Add an urls.py, then add to your plugin class as YourPlugin.urls Naturally, these can point to views in your plugin!","title":"Adding URLS"},{"location":"guides/plugins/#adding-javascript","text":"add to static, then add to your plugin class as YourPlugin.javascripts There are some restricted namespaces for these...","title":"Adding Javascript"},{"location":"guides/plugins/#adding-apis","text":"OPAL uses Django Rest Framweork to provide APIs, and you may add to these from your plugin. By convention, APIs live in yourplugin/api.py . You are expected to provide a rest_framework.viewsets.ViewSet subclass, which you then detail as the .apis attribute of your plugin. # yourplugin/api.py from rest_framework.viewsets import ViewSet from rest_framework.response import Response class PingViewSet(ViewSet): def list(self, request): return Response('pong') # yourplugin/__init__.py from opal.core.plugins import OpalPlugin from yourplugin import api class YourPlugin(OpalPlugin): apis = [ ('ping', api.PingViewSet) ] These APIs will then be available and self-documenting fom the standard OPAL url /api/v0.1/","title":"Adding APIs"},{"location":"guides/plugins/#adding-actions-to-the-sidebar","text":"Actions can be added to the sidebar by setting the actions attribute of your plugin. Actions is expected to be an iterable of strings which are templates to be included in the sidebar. By convention, actions will live in ./templates/actions/ . # __init__.py: class Plugin(OpalPlugin): actions = ('actions/javascript_alert.html', 'actions/dummy_button.html') And then in the template: p ng-show=\"episode.category == 'YourEpisodeCategory'\" button class=\"btn btn-primary\" ng-click=\"alert('Boom!')\" i href=\"fa fa-warning\" /i ALERT ME /button /p","title":"Adding Actions to the sidebar"},{"location":"guides/plugins/#adding-dependencies-globally-to-our-angular-modules","text":"Dependencies listed in angular_module_deps will be added to all Angular modules (as long as they use the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we won't for now.","title":"Adding dependencies globally to our angular modules"},{"location":"guides/plugins/#installing-plugins","text":"Add to installed apps Add to requirements if appropriate","title":"Installing plugins"},{"location":"guides/plugins/#adding-extra-markup-to-the-tag","text":"Any templates you define in the property .head_extra will be included in the","title":"Adding extra markup to the  tag"},{"location":"guides/plugins_list/","text":"OPAL Plugins list The OPAL ecosystem has a rich array of re-usable Open Source plugins that can be used as composable units of functionality to build your application. This page lists some of the best available: opal.core.search The Search plugin bundled with OPAL core provides a default database based search implementation for your application, and is scheduled to provide hooks for e.g. using Elastic Search as your serach backend. opal.core.collaborative The Collaborative plugin bundled with OPAL core provides a mechanism for providing realtime collaborative editing of patient data within lists, by providing a streaming websocket link of updates from other open sessions. (Requires Glossolalia ). opal-opat The OPAT plugin provides a set of teams, flows and record types for running a BSAC OPAT clinic. opal-research The Research plugin allows an OPAL application to be used as the data collection method for multiple concurrent research studies, including researcher blinding, a structured role permission framework. opal-walk-in The Walk In plugin supports the operation of drop in services within your institution, including registration, triage, escalation discharge summaries. opal-wardround The Wardround plugin provides structured virtual ward rounds - sequential subsets of patients matching arbitrary criteria that the user may step through in order. opal-dischargesummary The Discharge Summary plugin allows the user to generate templated letters from the data concerning an episode already held in the Application. opal-referral The Referral plugin provides the plumbing for building complex inter-team referrals within an institution. opal-dashboard The Dashboard plugin allows for realtime clinical dashboards featuring arbitrary metrics, displayed within your application. opal-observations The Observations plugin caters for the recording and display of electronic observations data. opal-analytics The Analytics plugin allows you to integrate your application with Google or Piwik Analytics with a minimum of fuss. opal-guidelines The Guidelines plugin presents contextual links to clinical guidelines in use at your institution when viewing records of patients whose condition matches those guidelines. Can be used with national or local guidelines. opal-iframe-api The Iframe Api plugin allows you to set up an api key. With this Api key you can create templates to view subrecords for embedding in for example iframes.","title":"Plugin List"},{"location":"guides/plugins_list/#opal-plugins-list","text":"The OPAL ecosystem has a rich array of re-usable Open Source plugins that can be used as composable units of functionality to build your application. This page lists some of the best available:","title":"OPAL Plugins list"},{"location":"guides/plugins_list/#opalcoresearch","text":"The Search plugin bundled with OPAL core provides a default database based search implementation for your application, and is scheduled to provide hooks for e.g. using Elastic Search as your serach backend.","title":"opal.core.search"},{"location":"guides/plugins_list/#opalcorecollaborative","text":"The Collaborative plugin bundled with OPAL core provides a mechanism for providing realtime collaborative editing of patient data within lists, by providing a streaming websocket link of updates from other open sessions. (Requires Glossolalia ).","title":"opal.core.collaborative"},{"location":"guides/plugins_list/#opal-opat","text":"The OPAT plugin provides a set of teams, flows and record types for running a BSAC OPAT clinic.","title":"opal-opat"},{"location":"guides/plugins_list/#opal-research","text":"The Research plugin allows an OPAL application to be used as the data collection method for multiple concurrent research studies, including researcher blinding, a structured role permission framework.","title":"opal-research"},{"location":"guides/plugins_list/#opal-walk-in","text":"The Walk In plugin supports the operation of drop in services within your institution, including registration, triage, escalation discharge summaries.","title":"opal-walk-in"},{"location":"guides/plugins_list/#opal-wardround","text":"The Wardround plugin provides structured virtual ward rounds - sequential subsets of patients matching arbitrary criteria that the user may step through in order.","title":"opal-wardround"},{"location":"guides/plugins_list/#opal-dischargesummary","text":"The Discharge Summary plugin allows the user to generate templated letters from the data concerning an episode already held in the Application.","title":"opal-dischargesummary"},{"location":"guides/plugins_list/#opal-referral","text":"The Referral plugin provides the plumbing for building complex inter-team referrals within an institution.","title":"opal-referral"},{"location":"guides/plugins_list/#opal-dashboard","text":"The Dashboard plugin allows for realtime clinical dashboards featuring arbitrary metrics, displayed within your application.","title":"opal-dashboard"},{"location":"guides/plugins_list/#opal-observations","text":"The Observations plugin caters for the recording and display of electronic observations data.","title":"opal-observations"},{"location":"guides/plugins_list/#opal-analytics","text":"The Analytics plugin allows you to integrate your application with Google or Piwik Analytics with a minimum of fuss.","title":"opal-analytics"},{"location":"guides/plugins_list/#opal-guidelines","text":"The Guidelines plugin presents contextual links to clinical guidelines in use at your institution when viewing records of patients whose condition matches those guidelines. Can be used with national or local guidelines.","title":"opal-guidelines"},{"location":"guides/plugins_list/#opal-iframe-api","text":"The Iframe Api plugin allows you to set up an api key. With this Api key you can create templates to view subrecords for embedding in for example iframes.","title":"opal-iframe-api"},{"location":"guides/referencedata/","text":"Clinical Reference data","title":"Clinical Reference data"},{"location":"guides/referencedata/#clinical-reference-data","text":"","title":"Clinical Reference data"},{"location":"guides/roles_and_permissions/","text":"Roles Permissions in OPAL OPAL provides some global per-user flags, which are set in the UserProfile model, as well as more detailed permissions available via roles. The UserProfile model Some global properties about Users are set in the opal.models.UserProfile model. UserProflie._can_extract Boolean flag to determine whether this user is allowed to download data extracts from the system UserProflie._force_password_change Boolean flag to determine whether we would like to force this user to change their password on their next login. This defaults to True when the User is first created. UserProfile._readonly Boolean flag to determine whether this user has readonly access. UserProfile._restricted_only Boolean flag to determine whether this user should be only shown teams for which they have explicitly been given permission to view or whether they should also see the list of general access teams. UserProfile.get_roles() Return a dictionary of roles in various contexts for our user profile.get_roles() # - { 'default': ['doctor'], 'some_research_study': ['Clinical Lead'] } UserProfile.get_teams() Return a list of Team objects that this user should be allowed to see. Roles A user may be given a particular role. These can be either global - in which case they are returned in the 'default' section of the roles dict from get_roles() , or specific to a team.","title":"Roles & Permissions"},{"location":"guides/roles_and_permissions/#roles-permissions-in-opal","text":"OPAL provides some global per-user flags, which are set in the UserProfile model, as well as more detailed permissions available via roles.","title":"Roles &amp; Permissions in OPAL"},{"location":"guides/roles_and_permissions/#the-userprofile-model","text":"Some global properties about Users are set in the opal.models.UserProfile model.","title":"The UserProfile model"},{"location":"guides/roles_and_permissions/#userproflie_can_extract","text":"Boolean flag to determine whether this user is allowed to download data extracts from the system","title":"UserProflie._can_extract"},{"location":"guides/roles_and_permissions/#userproflie_force_password_change","text":"Boolean flag to determine whether we would like to force this user to change their password on their next login. This defaults to True when the User is first created.","title":"UserProflie._force_password_change"},{"location":"guides/roles_and_permissions/#userprofile_readonly","text":"Boolean flag to determine whether this user has readonly access.","title":"UserProfile._readonly"},{"location":"guides/roles_and_permissions/#userprofile_restricted_only","text":"Boolean flag to determine whether this user should be only shown teams for which they have explicitly been given permission to view or whether they should also see the list of general access teams.","title":"UserProfile._restricted_only"},{"location":"guides/roles_and_permissions/#userprofileget_roles","text":"Return a dictionary of roles in various contexts for our user profile.get_roles() # - { 'default': ['doctor'], 'some_research_study': ['Clinical Lead'] }","title":"UserProfile.get_roles()"},{"location":"guides/roles_and_permissions/#userprofileget_teams","text":"Return a list of Team objects that this user should be allowed to see.","title":"UserProfile.get_teams()"},{"location":"guides/roles_and_permissions/#roles","text":"A user may be given a particular role. These can be either global - in which case they are returned in the 'default' section of the roles dict from get_roles() , or specific to a team.","title":"Roles"},{"location":"guides/search/","text":"OPAL Search overview The OPAL Search backend is switchable using the settings value OPAL_SEARCH_BACKEND. By default it will do a database query. The backend takes in a dictionary with the following fields { \"queryType\": either \"Equals\" or \"Contains\", \"field\": the label of the column that will be queried, e.g. Hospital Number, \"query\": the value to be queried, e.g. \"1111\", 'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries 'column': the model to be queried e.g. 'demographics' }","title":"Search Overview"},{"location":"guides/search/#opal-search-overview","text":"The OPAL Search backend is switchable using the settings value OPAL_SEARCH_BACKEND. By default it will do a database query. The backend takes in a dictionary with the following fields { \"queryType\": either \"Equals\" or \"Contains\", \"field\": the label of the column that will be queried, e.g. Hospital Number, \"query\": the value to be queried, e.g. \"1111\", 'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries 'column': the model to be queried e.g. 'demographics' }","title":"OPAL Search overview"},{"location":"guides/static_files/","text":"Static Files in OPAL As with any Javascript heavy application, OPAL apps can quickly accumulate large numbers of static files. OPAL ships with the Django Compressor library out of the box, and uses it to manage the Javascript asset pipeline. Do consult the excellent Django Compresor documentation for more details on exactly how this process works.","title":"Static Files"},{"location":"guides/static_files/#static-files-in-opal","text":"As with any Javascript heavy application, OPAL apps can quickly accumulate large numbers of static files. OPAL ships with the Django Compressor library out of the box, and uses it to manage the Javascript asset pipeline. Do consult the excellent Django Compresor documentation for more details on exactly how this process works.","title":"Static Files in OPAL"},{"location":"guides/tagging/","text":"Tagging Episodes in OPAL may be tagged. This is commonly used as a mechanism to record that a particular team is looking after a patient - via TaggedPatientList , but also to group patients. For instance, we might like to 'tag' episodes with a particular string when some particular event occurrs so that we can run reports or analyse these groups later. The \"Teams\" modal in list and detail views, is actually an interface over updating the tagging of the episode in question. Metadata concerning tags can be found via the Options API.","title":"Tagging"},{"location":"guides/tagging/#tagging","text":"Episodes in OPAL may be tagged. This is commonly used as a mechanism to record that a particular team is looking after a patient - via TaggedPatientList , but also to group patients. For instance, we might like to 'tag' episodes with a particular string when some particular event occurrs so that we can run reports or analyse these groups later. The \"Teams\" modal in list and detail views, is actually an interface over updating the tagging of the episode in question. Metadata concerning tags can be found via the Options API.","title":"Tagging"},{"location":"guides/templates/","text":"Templates in OPAL OPAL uses a mixture of Django and Angular templates. Angular templates In order to be compatible with Django templating, we use the [[ ... ]] notation for Angular interpolation, which allows us to mix Django template interpolation in templates designed to be rendered by Angular on the client side. !-- app_details_snippet.html -- {{ OPAL_BRAND_NAME }} [[ OPAL_VERSION ]] Generic Template URL On many occasions we simply want to fetch a template from the server in our Angular code without any further processing. OPAL provides a default catchall HTML template url which will render .html files direct from disk. # opal.urls url(r'templates/(?P template_name [a-z_/]+.html)', views.RawTemplateView.as_view()) So if our template is at ./myapp/templates/foo/bar.html , then the url /templates/foo/bar.html will return it.","title":"Templates"},{"location":"guides/templates/#templates-in-opal","text":"OPAL uses a mixture of Django and Angular templates.","title":"Templates in OPAL"},{"location":"guides/templates/#angular-templates","text":"In order to be compatible with Django templating, we use the [[ ... ]] notation for Angular interpolation, which allows us to mix Django template interpolation in templates designed to be rendered by Angular on the client side. !-- app_details_snippet.html -- {{ OPAL_BRAND_NAME }} [[ OPAL_VERSION ]]","title":"Angular templates"},{"location":"guides/templates/#generic-template-url","text":"On many occasions we simply want to fetch a template from the server in our Angular code without any further processing. OPAL provides a default catchall HTML template url which will render .html files direct from disk. # opal.urls url(r'templates/(?P template_name [a-z_/]+.html)', views.RawTemplateView.as_view()) So if our template is at ./myapp/templates/foo/bar.html , then the url /templates/foo/bar.html will return it.","title":"Generic Template URL"},{"location":"guides/topic-guides/","text":"OPAL Guides A list of all available topic guides. OPAL OPAL - Applications, Plugins How OPAL components hang together Command line tool running admin tasks from the command line Discoverable design patterns and library for creating easily reusable features Plugins Available interfaces for OPAL plugins List of Plugins A list of available high quality plugins Data and Business Logic Data Model How OPAL models clinical reality Core Clinical Model The core clinical data model available to OPAL applications Flow Hooks to customise key moments in a patient's flow through a clinical service Angular models Working with Clinical data in Angular Roles Permissions How we handle authorization in OPAL Tagging Tagging episodes in OPAL JSON API The OPAL JSON API Lookup Lists Canonical coded terms and ontologies Presentation and templating Templates Server and client side templating Default Context Processors OPAL Django context processors Static Files How OPAL handles static files Forms Forms for entering or editing data Patient Detail Views Detailed views of a Patient Patient List Views Lists of patients Optional Components Search Default search implementation","title":"Guides"},{"location":"guides/topic-guides/#opal-guides","text":"A list of all available topic guides.","title":"OPAL Guides"},{"location":"guides/topic-guides/#opal","text":"OPAL - Applications, Plugins How OPAL components hang together Command line tool running admin tasks from the command line Discoverable design patterns and library for creating easily reusable features Plugins Available interfaces for OPAL plugins List of Plugins A list of available high quality plugins","title":"OPAL"},{"location":"guides/topic-guides/#data-and-business-logic","text":"Data Model How OPAL models clinical reality Core Clinical Model The core clinical data model available to OPAL applications Flow Hooks to customise key moments in a patient's flow through a clinical service Angular models Working with Clinical data in Angular Roles Permissions How we handle authorization in OPAL Tagging Tagging episodes in OPAL JSON API The OPAL JSON API Lookup Lists Canonical coded terms and ontologies","title":"Data and Business Logic"},{"location":"guides/topic-guides/#presentation-and-templating","text":"Templates Server and client side templating Default Context Processors OPAL Django context processors Static Files How OPAL handles static files Forms Forms for entering or editing data Patient Detail Views Detailed views of a Patient Patient List Views Lists of patients","title":"Presentation and templating"},{"location":"guides/topic-guides/#optional-components","text":"Search Default search implementation","title":"Optional Components"},{"location":"guides/working_with_data_in_angular/","text":"Working with Clinical Data in Angular OPAL provides a range of Angular services for working with clinical data on the front end. The Episode Service The Episode Service will return an Episode object that represents an individual episode of care, and provides various methods for interacting with both episodes and subrecords. var episode = new Episode(my_episode_data); var editing = episode.makeCopy(); editing.start_date = new Date(); episode.save(editing); The Item Service The Item Service returns Item objects that represent individual instances of subrecords. They must be initialised with an episode and a schema representing the available data fields for this subrecord type. var diagnosis = new Item({}, episode, $rootScope.fields.diagnosis); var editing = diagnosis.makeCopy(); editing.date_of_diagnosis = new Date(); diagnosis.save(editing); Subrecord CRUD modals The Episode service has a convenient API that allows you to open a modal to edit a new or existing subrecord. epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis Customising Subrecords Sometimes our application will wish to customise a subrecord of a particular type - for instance to set default values. We do this by setting a custom record service. First, we set the name of the service to use as a constructor for this record type as a property on the model. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' Next we must include the file with our new service in our application. # yourapp/__init__.py class YourApp(application.OpalApplication): javascripts = [..., 'js/diagnosis.js', ...] Finally we define an Angular service which expects to be passed the record in order to set defaults. // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()} return record; } });","title":"Angular Models"},{"location":"guides/working_with_data_in_angular/#working-with-clinical-data-in-angular","text":"OPAL provides a range of Angular services for working with clinical data on the front end.","title":"Working with Clinical Data in Angular"},{"location":"guides/working_with_data_in_angular/#the-episode-service","text":"The Episode Service will return an Episode object that represents an individual episode of care, and provides various methods for interacting with both episodes and subrecords. var episode = new Episode(my_episode_data); var editing = episode.makeCopy(); editing.start_date = new Date(); episode.save(editing);","title":"The Episode Service"},{"location":"guides/working_with_data_in_angular/#the-item-service","text":"The Item Service returns Item objects that represent individual instances of subrecords. They must be initialised with an episode and a schema representing the available data fields for this subrecord type. var diagnosis = new Item({}, episode, $rootScope.fields.diagnosis); var editing = diagnosis.makeCopy(); editing.date_of_diagnosis = new Date(); diagnosis.save(editing);","title":"The Item Service"},{"location":"guides/working_with_data_in_angular/#subrecord-crud-modals","text":"The Episode service has a convenient API that allows you to open a modal to edit a new or existing subrecord. epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis","title":"Subrecord CRUD modals"},{"location":"guides/working_with_data_in_angular/#customising-subrecords","text":"Sometimes our application will wish to customise a subrecord of a particular type - for instance to set default values. We do this by setting a custom record service. First, we set the name of the service to use as a constructor for this record type as a property on the model. # yourapp/models.py class Diagnosis(models.Diagnosis): _angular_service = 'Diagnosis' Next we must include the file with our new service in our application. # yourapp/__init__.py class YourApp(application.OpalApplication): javascripts = [..., 'js/diagnosis.js', ...] Finally we define an Angular service which expects to be passed the record in order to set defaults. // yourapp/static/js/diagnosis.js angular.module('opal.records').factory('Diagnosis', function(){ return function(record){ if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()} return record; } });","title":"Customising Subrecords"},{"location":"reference/CHANGELOG/","text":"0.7.0 (Major Release) Episode Categories Refactors EpisodeCategory to be a discoverable feature. Renames Episode.category - Episode.category_name . Episode JSON API The Restful Episode JSON API previously available at /episode/:pk/ is now moved into /api/v0.1/episode/:pk/ for consistency with the rest of our JSON APIs. The OPAL Angular layer has been updated to reflect this, and should handle the transition seamlessly, but code calling the API directly should update to reflect the new URL. Defaults for records on the client side Establishes a new way to define defaults for records initialized in Javascript without requiring that we hard-code API names to defaults in a global namespace. Update to Javascript Signatures Flow.enter() and Flow.exit() now no longer take options positional arguments - instead the controllers they initialize have Metadata and Referencedata as optional resolves arguments. AddEpisodeCtrl now no longer requires options as a resolves() option, but requires Referencedata instead. MaxLength for form helpers The input form helper will now infer the max length of char fields from the max length of the database field, and render relevant Angular directives. EpisodeDetail removed The EpisodeDetailCtrl and EpisodeDetailMixin controller and service have been removed - these were not used anywhere other than in the Wardround plugin, and redundant after enhancements to Patient Detail and Custom DetailViews in 0.6. Additional utilities Adds a datetimepicker templatetag that will render widgets for a Datetime field including time. Adds a date_of_birth_field templatetag that renders a date of birth field complete with inteligent validation. (Note this change also includes removing the old _partial/ template) Updates dependency graph: Django - 1.8.13 0.6.0 (Major Release) Detail views Moves from episode oriented detail to patient oriented detail. (All episodes plus x-episode views are available from a patient detail screen) Tagging As a performance optimisation for the frequent access of historic tags, untagging an episode simply renders the tag inactive rather than deleting it and relying on Django-Reversion for access to historical data. Date Formatting We now expect 'd/m/y' date formatting by default. Patient lists Lists are now declarative, and separate from teams. They are implemented as subclasses of opal.core.patient_lists.PatientList. Forms vs. Modals Introduces a distinction between a form and a modal. By default, we now use forms for subrecords, only overriding the modal if there is something we want to do differently specifically in the modal. Command line tools Adds $opal checkout for switching between applications or application versions. Models ContextProcessor The 'opal.context_processors.models' Context Processor will allow you to access your subrecords from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include models.Demographics.get_detail_template %} Upgrade instructions: Full upgrade instructions to work through any backwards incompatible changes are provided in the OPAL docs. 0.5.5 (Minor Release) Changes the way old tags are handled. Tags are no longer deleted episodes, rather they're marked as archived. 0.5.4 (Minor Release) Include local storage 0.5.3 (Minor Release) Speed up loading of the lookup lists Fix pagination issues in search Speed up loading of many to many fields Increase test coverage Add some extra help fields to {% forms %} helpers Fixes bug with $rootScope.open_modal() where keystrokes were being intercepted 0.5.2 (Minor Release) Speed improvements on page load allow us to only show record panels if a record of that type exists disable modal buttons while saving 0.5.1 (Minor Release) Minor bug fixes 0.5 (Major release) Search Complete re-design of Search interface to provide a single search box on every page and pagination for resulta. Puts in place a pluggable interface that could be swapped out for e.g. ElasticSearch. New Service for PatientSummary() Analytics Moves Analytics integration into OPAL core with the ability to blacklist pages that should never be reported List view Removed old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row. Updated scrolling and loading behaviour to snap to viewport and not display the page build. Subrecord metadata Added four new utility fields to Patient and Episode subrecords: created_by, updated_by, created, updated Select2 and list fields Added support for select2 as an input widget and Subrecord fields that can be lists of things. Also Numerous small bugfixes. Refactoring of the models package into a models module. Updated Underscore.js - 1.8.3 Updated Angular.js - 1.3.11 0.4.3 (Minor release) Refactors opal.models to be a models.py file rather than a package. Adds several improvements to forms helpers - Help argument, other argument to select. Updates dependency graph: Angular-strap - 2.3.1 0.4.2 (Minor release) Upgrades dependency graph: Django - 1.8.3 Django-reversion - 1.8.7 jQuery - 1.11.3 D3 - 3.5.6 C4 - 0.4.10 South has been removed, now using django migrations 0.4.1 (Bugfix release) Fixes some search results appearing duplicated. 0.4 (Major release) New Design Completely re-designed UI following extensive user research and multiple iterations. Managementcommands and scaffolding Features the opal command line tool for common administrative tasks http://opal.openhealthcare.org.uk/docs/guides/command_line_tool/ Form helpers templatetag library New template library for consistent form controls in line with our new interface guidelines http://opal.openhealthcare.org.uk/docs/reference/form_templatetags/ API Documentation OPAL JSON APIs are now fully self-documenting for all updated instances http://opal.openhealthcare.org.uk/docs/guides/json_api/ 0.3 (Major release) Bugfixes, significant flexibility in template customisability. Minor UI updates. 0.2.2 (Bugfix release) Numerous small bugfixes. Adds the concept of undischarging patients. 0.2.1 Numerous small bugfixes. 0.2.0 Search overhaul - introduces advanced searches. 0.1.1 Initial public release","title":"CHANGELOG"},{"location":"reference/CHANGELOG/#070-major-release","text":"","title":"0.7.0 (Major Release)"},{"location":"reference/CHANGELOG/#episode-categories","text":"Refactors EpisodeCategory to be a discoverable feature. Renames Episode.category - Episode.category_name .","title":"Episode Categories"},{"location":"reference/CHANGELOG/#episode-json-api","text":"The Restful Episode JSON API previously available at /episode/:pk/ is now moved into /api/v0.1/episode/:pk/ for consistency with the rest of our JSON APIs. The OPAL Angular layer has been updated to reflect this, and should handle the transition seamlessly, but code calling the API directly should update to reflect the new URL.","title":"Episode JSON API"},{"location":"reference/CHANGELOG/#defaults-for-records-on-the-client-side","text":"Establishes a new way to define defaults for records initialized in Javascript without requiring that we hard-code API names to defaults in a global namespace.","title":"Defaults for records on the client side"},{"location":"reference/CHANGELOG/#update-to-javascript-signatures","text":"Flow.enter() and Flow.exit() now no longer take options positional arguments - instead the controllers they initialize have Metadata and Referencedata as optional resolves arguments. AddEpisodeCtrl now no longer requires options as a resolves() option, but requires Referencedata instead.","title":"Update to Javascript Signatures"},{"location":"reference/CHANGELOG/#maxlength-for-form-helpers","text":"The input form helper will now infer the max length of char fields from the max length of the database field, and render relevant Angular directives.","title":"MaxLength for form helpers"},{"location":"reference/CHANGELOG/#episodedetail-removed","text":"The EpisodeDetailCtrl and EpisodeDetailMixin controller and service have been removed - these were not used anywhere other than in the Wardround plugin, and redundant after enhancements to Patient Detail and Custom DetailViews in 0.6.","title":"EpisodeDetail removed"},{"location":"reference/CHANGELOG/#additional-utilities","text":"Adds a datetimepicker templatetag that will render widgets for a Datetime field including time. Adds a date_of_birth_field templatetag that renders a date of birth field complete with inteligent validation. (Note this change also includes removing the old _partial/ template) Updates dependency graph: Django - 1.8.13","title":"Additional utilities"},{"location":"reference/CHANGELOG/#060-major-release","text":"Detail views Moves from episode oriented detail to patient oriented detail. (All episodes plus x-episode views are available from a patient detail screen) Tagging As a performance optimisation for the frequent access of historic tags, untagging an episode simply renders the tag inactive rather than deleting it and relying on Django-Reversion for access to historical data. Date Formatting We now expect 'd/m/y' date formatting by default. Patient lists Lists are now declarative, and separate from teams. They are implemented as subclasses of opal.core.patient_lists.PatientList. Forms vs. Modals Introduces a distinction between a form and a modal. By default, we now use forms for subrecords, only overriding the modal if there is something we want to do differently specifically in the modal. Command line tools Adds $opal checkout for switching between applications or application versions.","title":"0.6.0 (Major Release)"},{"location":"reference/CHANGELOG/#models-contextprocessor","text":"The 'opal.context_processors.models' Context Processor will allow you to access your subrecords from templates without having to explicitly load them in a view. In turn, this allows patterns like: {% include models.Demographics.get_detail_template %}","title":"Models ContextProcessor"},{"location":"reference/CHANGELOG/#upgrade-instructions","text":"Full upgrade instructions to work through any backwards incompatible changes are provided in the OPAL docs.","title":"Upgrade instructions:"},{"location":"reference/CHANGELOG/#055-minor-release","text":"Changes the way old tags are handled. Tags are no longer deleted episodes, rather they're marked as archived.","title":"0.5.5 (Minor Release)"},{"location":"reference/CHANGELOG/#054-minor-release","text":"Include local storage","title":"0.5.4 (Minor Release)"},{"location":"reference/CHANGELOG/#053-minor-release","text":"Speed up loading of the lookup lists Fix pagination issues in search Speed up loading of many to many fields Increase test coverage Add some extra help fields to {% forms %} helpers Fixes bug with $rootScope.open_modal() where keystrokes were being intercepted","title":"0.5.3 (Minor Release)"},{"location":"reference/CHANGELOG/#052-minor-release","text":"Speed improvements on page load allow us to only show record panels if a record of that type exists disable modal buttons while saving","title":"0.5.2 (Minor Release)"},{"location":"reference/CHANGELOG/#051-minor-release","text":"Minor bug fixes","title":"0.5.1 (Minor Release)"},{"location":"reference/CHANGELOG/#05-major-release","text":"Search Complete re-design of Search interface to provide a single search box on every page and pagination for resulta. Puts in place a pluggable interface that could be swapped out for e.g. ElasticSearch. New Service for PatientSummary() Analytics Moves Analytics integration into OPAL core with the ability to blacklist pages that should never be reported List view Removed old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row. Updated scrolling and loading behaviour to snap to viewport and not display the page build. Subrecord metadata Added four new utility fields to Patient and Episode subrecords: created_by, updated_by, created, updated Select2 and list fields Added support for select2 as an input widget and Subrecord fields that can be lists of things. Also Numerous small bugfixes. Refactoring of the models package into a models module. Updated Underscore.js - 1.8.3 Updated Angular.js - 1.3.11","title":"0.5 (Major release)"},{"location":"reference/CHANGELOG/#043-minor-release","text":"Refactors opal.models to be a models.py file rather than a package. Adds several improvements to forms helpers - Help argument, other argument to select. Updates dependency graph: Angular-strap - 2.3.1","title":"0.4.3 (Minor release)"},{"location":"reference/CHANGELOG/#042-minor-release","text":"Upgrades dependency graph: Django - 1.8.3 Django-reversion - 1.8.7 jQuery - 1.11.3 D3 - 3.5.6 C4 - 0.4.10 South has been removed, now using django migrations","title":"0.4.2 (Minor release)"},{"location":"reference/CHANGELOG/#041-bugfix-release","text":"Fixes some search results appearing duplicated.","title":"0.4.1 (Bugfix release)"},{"location":"reference/CHANGELOG/#04-major-release","text":"New Design Completely re-designed UI following extensive user research and multiple iterations. Managementcommands and scaffolding Features the opal command line tool for common administrative tasks http://opal.openhealthcare.org.uk/docs/guides/command_line_tool/ Form helpers templatetag library New template library for consistent form controls in line with our new interface guidelines http://opal.openhealthcare.org.uk/docs/reference/form_templatetags/ API Documentation OPAL JSON APIs are now fully self-documenting for all updated instances http://opal.openhealthcare.org.uk/docs/guides/json_api/","title":"0.4 (Major release)"},{"location":"reference/CHANGELOG/#03-major-release","text":"Bugfixes, significant flexibility in template customisability. Minor UI updates.","title":"0.3 (Major release)"},{"location":"reference/CHANGELOG/#022-bugfix-release","text":"Numerous small bugfixes. Adds the concept of undischarging patients.","title":"0.2.2 (Bugfix release)"},{"location":"reference/CHANGELOG/#021","text":"Numerous small bugfixes.","title":"0.2.1"},{"location":"reference/CHANGELOG/#020","text":"Search overhaul - introduces advanced searches.","title":"0.2.0"},{"location":"reference/CHANGELOG/#011","text":"Initial public release","title":"0.1.1"},{"location":"reference/detail_views/","text":"opal.core.PatientDetailView PatientDetailViews allow us to define a custom view over either one or many episodes, available from the main Patient Detail view. PatientDetailView inherits from the discoverable features DiscoverableFeature , SortableFeature , RestrictableFeature . Fields PatientDetailView.name The machine readable name for this view. Should be lower case, and have no spaces. PatientDetailView.title The display name for this view. This is what will display in links to it. PatientDetailView.template The template we should use to render the view when it's active. PatientDetailView.order An integer controlling the order of PatientDetailViews in the episode switcher menu on the Patient Detail screen is determined by this property. Lower numbers mean higher up. Classmethods PatientDetailView.visible_to Overriding this method will restrict who the view is available to. For instance, we would implement a superuser only view: @classmethod def to_user(klass, user): return user.is_superuser","title":"Detail Views"},{"location":"reference/detail_views/#opalcorepatientdetailview","text":"PatientDetailViews allow us to define a custom view over either one or many episodes, available from the main Patient Detail view. PatientDetailView inherits from the discoverable features DiscoverableFeature , SortableFeature , RestrictableFeature .","title":"opal.core.PatientDetailView"},{"location":"reference/detail_views/#fields","text":"","title":"Fields"},{"location":"reference/detail_views/#patientdetailviewname","text":"The machine readable name for this view. Should be lower case, and have no spaces.","title":"PatientDetailView.name"},{"location":"reference/detail_views/#patientdetailviewtitle","text":"The display name for this view. This is what will display in links to it.","title":"PatientDetailView.title"},{"location":"reference/detail_views/#patientdetailviewtemplate","text":"The template we should use to render the view when it's active.","title":"PatientDetailView.template"},{"location":"reference/detail_views/#patientdetailvieworder","text":"An integer controlling the order of PatientDetailViews in the episode switcher menu on the Patient Detail screen is determined by this property. Lower numbers mean higher up.","title":"PatientDetailView.order"},{"location":"reference/detail_views/#classmethods","text":"","title":"Classmethods"},{"location":"reference/detail_views/#patientdetailviewvisible_to","text":"Overriding this method will restrict who the view is available to. For instance, we would implement a superuser only view: @classmethod def to_user(klass, user): return user.is_superuser","title":"PatientDetailView.visible_to"},{"location":"reference/episode/","text":"opal.models.Episode The opal.models.Episode class represents an episode of care for a patient. This can be either an inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic, or any other arbitrarially defined period of care. Fields Episode.category The category of this episode - e.g. inpatient, outpatient et cetera. This defaults to whatever is set on your application's subclass of opal.core.application.OpalApplication - which itseflf defaults to 'inpatient'. Episode.patient A foreign key relationship to the patient for whom this episode concerns. Episode.active A boolean to provide a quick lookup for whether this is an active or closed episode. Episode.date_of_admission If this is an inpatient episode, the date of admission. Episode.discharge_date If this is an inpatient episode, the date of discharge. Episode.date_of_episode If this is an episode that occurs on one date (like a clinic visit or telephone liaison), the date of that event. Episode.consistency_token A (automatically generated) hash of the above fields. This is used for detecting concurrent edits. Methods The Episode model has the following methods: Episode.to_dict Return a dictionary of field value pairs for this episode episode.to_dict(user) Arguments: user The User for whom we want to serialise this episode Keywords: shallow Boolean to indicate whether we want just this episode, or also a sorted set of previous and subsequent episodes Episode.get_tag_names Arguments: user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.get_tag_names(user) # ['mine', 'infectioncontrol'] Episode.set_tag_names Arguments: tag_names The list of tags that we want to be active for this Episode. user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.set_tag_names(['mine', 'infectioncontrol'], user) Manager The custom manager for Episodes has the following methods: Episode.objects.serialised() Return a set of serialised episodes. Episode.objects.serialised(User, [episode, ...], historic_tags=False) Arguments: user The User for whom we want to serialise this episode episodes An iterable of Episode instances Keywords: historic_tags A boolean to indicate whether the user desires historic or just current tags to be serialised Episode.objects.search As a useful utility, the episode manager has a search method that will search on first name, last name and/or hospital number, under the hood it uses Patient search","title":"The Episode model"},{"location":"reference/episode/#opalmodelsepisode","text":"The opal.models.Episode class represents an episode of care for a patient. This can be either an inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic, or any other arbitrarially defined period of care.","title":"opal.models.Episode"},{"location":"reference/episode/#fields","text":"","title":"Fields"},{"location":"reference/episode/#episodecategory","text":"The category of this episode - e.g. inpatient, outpatient et cetera. This defaults to whatever is set on your application's subclass of opal.core.application.OpalApplication - which itseflf defaults to 'inpatient'.","title":"Episode.category"},{"location":"reference/episode/#episodepatient","text":"A foreign key relationship to the patient for whom this episode concerns.","title":"Episode.patient"},{"location":"reference/episode/#episodeactive","text":"A boolean to provide a quick lookup for whether this is an active or closed episode.","title":"Episode.active"},{"location":"reference/episode/#episodedate_of_admission","text":"If this is an inpatient episode, the date of admission.","title":"Episode.date_of_admission"},{"location":"reference/episode/#episodedischarge_date","text":"If this is an inpatient episode, the date of discharge.","title":"Episode.discharge_date"},{"location":"reference/episode/#episodedate_of_episode","text":"If this is an episode that occurs on one date (like a clinic visit or telephone liaison), the date of that event.","title":"Episode.date_of_episode"},{"location":"reference/episode/#episodeconsistency_token","text":"A (automatically generated) hash of the above fields. This is used for detecting concurrent edits.","title":"Episode.consistency_token"},{"location":"reference/episode/#methods","text":"The Episode model has the following methods:","title":"Methods"},{"location":"reference/episode/#episodeto_dict","text":"Return a dictionary of field value pairs for this episode episode.to_dict(user) Arguments: user The User for whom we want to serialise this episode Keywords: shallow Boolean to indicate whether we want just this episode, or also a sorted set of previous and subsequent episodes","title":"Episode.to_dict"},{"location":"reference/episode/#episodeget_tag_names","text":"Arguments: user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.get_tag_names(user) # ['mine', 'infectioncontrol']","title":"Episode.get_tag_names"},{"location":"reference/episode/#episodeset_tag_names","text":"Arguments: tag_names The list of tags that we want to be active for this Episode. user The user for whom we want the tag names. Return the current active tag names for this Episode as strings. episode.set_tag_names(['mine', 'infectioncontrol'], user)","title":"Episode.set_tag_names"},{"location":"reference/episode/#manager","text":"The custom manager for Episodes has the following methods:","title":"Manager"},{"location":"reference/episode/#episodeobjectsserialised","text":"Return a set of serialised episodes. Episode.objects.serialised(User, [episode, ...], historic_tags=False) Arguments: user The User for whom we want to serialise this episode episodes An iterable of Episode instances Keywords: historic_tags A boolean to indicate whether the user desires historic or just current tags to be serialised","title":"Episode.objects.serialised()"},{"location":"reference/episode/#episodeobjectssearch","text":"As a useful utility, the episode manager has a search method that will search on first name, last name and/or hospital number, under the hood it uses Patient search","title":"Episode.objects.search"},{"location":"reference/episode_categories/","text":"opal.core.episodes EpisodeCategory OPAL Episodes have an associated category. These categories are implemented as subclasses of opal.core.episodes.EpisodeCategory . This class is an OPAL DiscoverableFeature and thus inherits all of the core Discoverable API. The category of any episode can be accessed as the .category property of any Episode instance. Properties EpisodeCategory.detail_template This is the template used within the Patient Detail View to display information about episodes of this category. EpisodeCategory.start Returns the Start date of this episode type. EpisodeCategory.stop Returns the Stop date of this episode type InpatientEpisode This is the defualt EpisodeCategory imlpementation - applications started with OPAL's scaffolding scripts will use this as the OpalApplication.default_episode_category . It sets the detail template to detail/inpatient.html","title":"Episode Categories"},{"location":"reference/episode_categories/#opalcoreepisodes","text":"","title":"opal.core.episodes"},{"location":"reference/episode_categories/#episodecategory","text":"OPAL Episodes have an associated category. These categories are implemented as subclasses of opal.core.episodes.EpisodeCategory . This class is an OPAL DiscoverableFeature and thus inherits all of the core Discoverable API. The category of any episode can be accessed as the .category property of any Episode instance.","title":"EpisodeCategory"},{"location":"reference/episode_categories/#properties","text":"","title":"Properties"},{"location":"reference/episode_categories/#episodecategorydetail_template","text":"This is the template used within the Patient Detail View to display information about episodes of this category.","title":"EpisodeCategory.detail_template"},{"location":"reference/episode_categories/#episodecategorystart","text":"Returns the Start date of this episode type.","title":"EpisodeCategory.start"},{"location":"reference/episode_categories/#episodecategorystop","text":"Returns the Stop date of this episode type","title":"EpisodeCategory.stop"},{"location":"reference/episode_categories/#inpatientepisode","text":"This is the defualt EpisodeCategory imlpementation - applications started with OPAL's scaffolding scripts will use this as the OpalApplication.default_episode_category . It sets the detail template to detail/inpatient.html","title":"InpatientEpisode"},{"location":"reference/episode_service/","text":"The Episode service The Episode service in opal.services provides us with core functionality related to interacting with episodes in the client. Constructor The Episode service is instantiated with the Episode data that comes back from the Episode JSON API. var episode = new Episode(json_data); Methods Episode.getTags Return a list of the current tags this episode has as strings. episode.getTags(); // ['mine', 'infectioncontrol'] Episode.hasTag Predicate function that determines whether the episode is tagged with a given tag. Arguments: tag : The tag you are interested in. Episode.newItem Instantiate a new subrecord for this episode of a given type. Arguments: recordName : The name of the type of record you want to instantiate. Example usage: episode.newItem('diagnosis'); // item (an Item() instance. Episode.recordEditor.newItem(name) Takes a string, opens a modal from which the user can create a new subrecord of type name . epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save Episode.recordEditor.deleteItem(name, index) Delete the index-th item of type name . Prompt the user to confirm this with a dialog. episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis Episode.recordEditor.editItem(name, index) Open a modal from which the user may edit the index-th item of type name . episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis","title":"Episode service"},{"location":"reference/episode_service/#the-episode-service","text":"The Episode service in opal.services provides us with core functionality related to interacting with episodes in the client.","title":"The Episode service"},{"location":"reference/episode_service/#constructor","text":"The Episode service is instantiated with the Episode data that comes back from the Episode JSON API. var episode = new Episode(json_data);","title":"Constructor"},{"location":"reference/episode_service/#methods","text":"","title":"Methods"},{"location":"reference/episode_service/#episodegettags","text":"Return a list of the current tags this episode has as strings. episode.getTags(); // ['mine', 'infectioncontrol']","title":"Episode.getTags"},{"location":"reference/episode_service/#episodehastag","text":"Predicate function that determines whether the episode is tagged with a given tag. Arguments: tag : The tag you are interested in.","title":"Episode.hasTag"},{"location":"reference/episode_service/#episodenewitem","text":"Instantiate a new subrecord for this episode of a given type. Arguments: recordName : The name of the type of record you want to instantiate. Example usage: episode.newItem('diagnosis'); // item (an Item() instance.","title":"Episode.newItem"},{"location":"reference/episode_service/#episoderecordeditornewitemname","text":"Takes a string, opens a modal from which the user can create a new subrecord of type name . epiode.recordEditor.newItem('diagnosis'): // - Opens a modal with the diagnosis form and will create a new diagnosis on save","title":"Episode.recordEditor.newItem(name)"},{"location":"reference/episode_service/#episoderecordeditordeleteitemname-index","text":"Delete the index-th item of type name . Prompt the user to confirm this with a dialog. episode.recordEditor.deleteItem('diagnosis', 0); // - Prompts the user to confirm the deletion of the first diagnosis","title":"Episode.recordEditor.deleteItem(name, index)"},{"location":"reference/episode_service/#episoderecordeditoredititemname-index","text":"Open a modal from which the user may edit the index-th item of type name . episode.recordEditor.editItem('diagnosis', 0); // - Opens a modal that allows the user to edit the first diagnosis","title":"Episode.recordEditor.editItem(name, index)"},{"location":"reference/form_templatetags/","text":"Form Helpers OPAL comes with a selection of templatetags that can help you with the repetitive task of generating Bootstrap and OPAL compatible markup for your forms. {% checkbox ... %} Generates a checkbox Keywords: field a string of the model name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% checkbox field=\"DogOwner.dog\" %} label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) disabled If this exists, we use this as the expression for the ng-disabled directive {% datepicker ... %} Generates a datepicker Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% datepicker field=\"DogOwner.dog\" %} label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive required Label to show when we're required mindate Expression to use to set the minimum possible date {% datepicker ... %} Generates a date time fields, a date field on one line and a time field on another Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% datetimepicker field=\"DogOwner.vet_appointment\" %} date_label The Label with which to describe the date field (defaults to 'Date') time_label The Label with which to describe the date field (defaults to 'Time') model The model which we are editing (This is a string that references an in-scope Angular variable) change an angular directive that fires on change {% input ... %} The input template tag generates you a form input that will play nicely with OPAL's styling. Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% input field=\"DogOwner.dog\" %} label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the lookuplist values required Label to show when we're required enter expression to evaluate if the user presses return when in this input maxlength maximum number of characters for this input. Will render the form invalid and display help text if exceeded. static an Angular expression that will swap the display to be a static input if it evaluates to true Inputs for subrecord fields A very common pattern is to render form fields that relate to fields of Subrecords . The input templatetag accepts a field argument, from which it will infer the label, model and lookuplist by introspecting the relevant subrecord model. {% input field=\"allergies.drug\" %} Inputs with units We also often want to display the unit of a particular field to help our users - consistent styling for this is available by using the unit argument e.g. {% input label= Weight model= editing.weight unit= kg %} {% radio ... %} Generates an inline radio input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values {% select ... %} Generates an inline select input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values other A boolean parameter that if true, provides a free text option when 'Other' is selected help a template to use as the contents of a help popover static an Angular expression that will swap the display to be a static input if it evaluates to true * {% textarea ... %} Generates an inline textarea input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive {% static ... %} Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles). Takes one positional argument, a string representing the subrecord field path. {% static \"Demographics.name\" %} !-- Renders as -- div class=\"form-group\" label class=\"control-label col-sm-3\" Name /label p class=\"form-control-static col-sm-8\" [[ editing.demographics.name ]] /p /div {% icon \"icon-name\" %} Renders a Bootstrap style Icon tag. If the icon starts with fa or glyphicon then we will insert the preceding fa . {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i {% icon \"cusom-icon\"} i class=\"custom-icon\" /i","title":"Form helpers"},{"location":"reference/form_templatetags/#form-helpers","text":"OPAL comes with a selection of templatetags that can help you with the repetitive task of generating Bootstrap and OPAL compatible markup for your forms.","title":"Form Helpers"},{"location":"reference/form_templatetags/#checkbox","text":"Generates a checkbox Keywords: field a string of the model name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% checkbox field=\"DogOwner.dog\" %} label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) disabled If this exists, we use this as the expression for the ng-disabled directive","title":"{% checkbox ... %}"},{"location":"reference/form_templatetags/#datepicker","text":"Generates a datepicker Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% datepicker field=\"DogOwner.dog\" %} label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive required Label to show when we're required mindate Expression to use to set the minimum possible date","title":"{% datepicker ... %}"},{"location":"reference/form_templatetags/#datepicker_1","text":"Generates a date time fields, a date field on one line and a time field on another Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% datetimepicker field=\"DogOwner.vet_appointment\" %} date_label The Label with which to describe the date field (defaults to 'Date') time_label The Label with which to describe the date field (defaults to 'Time') model The model which we are editing (This is a string that references an in-scope Angular variable) change an angular directive that fires on change","title":"{% datepicker ... %}"},{"location":"reference/form_templatetags/#input","text":"The input template tag generates you a form input that will play nicely with OPAL's styling. Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% input field=\"DogOwner.dog\" %} label The Label with which to describe this field model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the lookuplist values required Label to show when we're required enter expression to evaluate if the user presses return when in this input maxlength maximum number of characters for this input. Will render the form invalid and display help text if exceeded. static an Angular expression that will swap the display to be a static input if it evaluates to true","title":"{% input ... %}"},{"location":"reference/form_templatetags/#inputs-for-subrecord-fields","text":"A very common pattern is to render form fields that relate to fields of Subrecords . The input templatetag accepts a field argument, from which it will infer the label, model and lookuplist by introspecting the relevant subrecord model. {% input field=\"allergies.drug\" %}","title":"Inputs for subrecord fields"},{"location":"reference/form_templatetags/#inputs-with-units","text":"We also often want to display the unit of a particular field to help our users - consistent styling for this is available by using the unit argument e.g. {% input label= Weight model= editing.weight unit= kg %}","title":"Inputs with units"},{"location":"reference/form_templatetags/#radio","text":"Generates an inline radio input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values","title":"{% radio ... %}"},{"location":"reference/form_templatetags/#select","text":"Generates an inline select input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive lookuplist an Angular expression that evaluates to an array containing the radio values other A boolean parameter that if true, provides a free text option when 'Other' is selected help a template to use as the contents of a help popover static an Angular expression that will swap the display to be a static input if it evaluates to true *","title":"{% select ... %}"},{"location":"reference/form_templatetags/#textarea","text":"Generates an inline textarea input Keywords: field a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %} label The Label with which to describe this input model The model which we are editing (This is a string that references an in-scope Angular variable) show A string that contains an Angular expression for the ng-show directive hide A string that contains an Angular expression for the ng-hide directive","title":"{% textarea ... %}"},{"location":"reference/form_templatetags/#static","text":"Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles). Takes one positional argument, a string representing the subrecord field path. {% static \"Demographics.name\" %} !-- Renders as -- div class=\"form-group\" label class=\"control-label col-sm-3\" Name /label p class=\"form-control-static col-sm-8\" [[ editing.demographics.name ]] /p /div","title":"{% static ... %}"},{"location":"reference/form_templatetags/#icon-icon-name","text":"Renders a Bootstrap style Icon tag. If the icon starts with fa or glyphicon then we will insert the preceding fa . {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i {% icon \"cusom-icon\"} i class=\"custom-icon\" /i","title":"{% icon \"icon-name\" %}"},{"location":"reference/item_service/","text":"The Item service The Item service in opal.services provides us with core functionality related to interacting with subrecord in the client. Methods Item.makeCopy Returns a clone of the editable fields + consistency token so that we can then update them in isolation elsewhere. Item.save Saves attributes to the server. item.save(data_to_save); Item.formController The Angular controller used by the modal that is opened when you edit this item to allow custom logic. Defaults to 'EditItemCtrl';","title":"Item service"},{"location":"reference/item_service/#the-item-service","text":"The Item service in opal.services provides us with core functionality related to interacting with subrecord in the client.","title":"The Item service"},{"location":"reference/item_service/#methods","text":"","title":"Methods"},{"location":"reference/item_service/#itemmakecopy","text":"Returns a clone of the editable fields + consistency token so that we can then update them in isolation elsewhere.","title":"Item.makeCopy"},{"location":"reference/item_service/#itemsave","text":"Saves attributes to the server. item.save(data_to_save);","title":"Item.save"},{"location":"reference/item_service/#itemformcontroller","text":"The Angular controller used by the modal that is opened when you edit this item to allow custom logic. Defaults to 'EditItemCtrl';","title":"Item.formController"},{"location":"reference/javascript_dependencies/","text":"OPAL Javscript Dependencies OPAL makes use of a number of upstream dependencies which are available for devleopers to use in building applications. | -|- Modernizr | Opal has a custom modernizr build that detects touch events Jquery | 1.11.3 Angular | 1.2.20 Underscore.js | 1.8.3 D3 | 3.5.6 C3 | 0.4.10","title":"Javascript dependencies"},{"location":"reference/javascript_dependencies/#opal-javscript-dependencies","text":"OPAL makes use of a number of upstream dependencies which are available for devleopers to use in building applications. | -|- Modernizr | Opal has a custom modernizr build that detects touch events Jquery | 1.11.3 Angular | 1.2.20 Underscore.js | 1.8.3 D3 | 3.5.6 C3 | 0.4.10","title":"OPAL Javscript Dependencies"},{"location":"reference/javascript_helpers/","text":"OPAL Javascript Helpers $rootScope methods OPAL provides some methods on the Angular $rootScope object. open_modal $rootScope.open_modal(controller, template, size, {episode: episode}) Open an arbitrary controller in a modal, passing in the name of the controller, the url for the template, the size of the modal window (either 'sm' or 'lg'). You may also pass through a dictionary of items to resolve. Angular Directives OPAL provides some built-in Angular directives for your project to use. date-of-birth Creates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old. one-click-only A directive that if set with no arguments, or set to true, will only allow a button to be clicked on once and then it'll be disabled. Useful for example to make sure that multiple save requests aren't accidentally triggered. scroll-top Adds a click handler to the element that when click will animate the body of the element to scroll to the top go-to-top Similar to scroll-top, this moves the scroll bar to the top of the page but doesn't animate the transition. Angular Filters OPAL provides some built-in Angular filters for your project to use. short-date Displays a date as DD/MM if it's this year, else DD/MM/YYYY hhmm Displays the hours minutes portion of a javascript Date object as HH:MM short-date-time Displays a date time, short date as above and time as in hhmm above moment-date-filter Allows a us to use moment.js formatters in the template exactly like you would use moment.format title Converts a string to title case upper Converts a string to upper case plural takes a word, a count, and an optional plural term. if count != 1 and there is a plural term it will return the plural term otherwise it will just suffix an 's' if count == 1 then it will return the word age calculates a persons current age from their date of birth boxed Displays Boolean fields as a checkbox (e.g. either [ ] or [X]) [[ item.boolean_field | boxed]]","title":"Javascript helpers"},{"location":"reference/javascript_helpers/#opal-javascript-helpers","text":"","title":"OPAL Javascript Helpers"},{"location":"reference/javascript_helpers/#rootscope-methods","text":"OPAL provides some methods on the Angular $rootScope object.","title":"$rootScope methods"},{"location":"reference/javascript_helpers/#open_modal","text":"$rootScope.open_modal(controller, template, size, {episode: episode}) Open an arbitrary controller in a modal, passing in the name of the controller, the url for the template, the size of the modal window (either 'sm' or 'lg'). You may also pass through a dictionary of items to resolve.","title":"open_modal"},{"location":"reference/javascript_helpers/#angular-directives","text":"OPAL provides some built-in Angular directives for your project to use.","title":"Angular Directives"},{"location":"reference/javascript_helpers/#date-of-birth","text":"Creates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old.","title":"date-of-birth"},{"location":"reference/javascript_helpers/#one-click-only","text":"A directive that if set with no arguments, or set to true, will only allow a button to be clicked on once and then it'll be disabled. Useful for example to make sure that multiple save requests aren't accidentally triggered.","title":"one-click-only"},{"location":"reference/javascript_helpers/#scroll-top","text":"Adds a click handler to the element that when click will animate the body of the element to scroll to the top","title":"scroll-top"},{"location":"reference/javascript_helpers/#go-to-top","text":"Similar to scroll-top, this moves the scroll bar to the top of the page but doesn't animate the transition.","title":"go-to-top"},{"location":"reference/javascript_helpers/#angular-filters","text":"OPAL provides some built-in Angular filters for your project to use.","title":"Angular Filters"},{"location":"reference/javascript_helpers/#short-date","text":"Displays a date as DD/MM if it's this year, else DD/MM/YYYY","title":"short-date"},{"location":"reference/javascript_helpers/#hhmm","text":"Displays the hours minutes portion of a javascript Date object as HH:MM","title":"hhmm"},{"location":"reference/javascript_helpers/#short-date-time","text":"Displays a date time, short date as above and time as in hhmm above","title":"short-date-time"},{"location":"reference/javascript_helpers/#moment-date-filter","text":"Allows a us to use moment.js formatters in the template exactly like you would use moment.format","title":"moment-date-filter"},{"location":"reference/javascript_helpers/#title","text":"Converts a string to title case","title":"title"},{"location":"reference/javascript_helpers/#upper","text":"Converts a string to upper case","title":"upper"},{"location":"reference/javascript_helpers/#plural","text":"takes a word, a count, and an optional plural term. if count != 1 and there is a plural term it will return the plural term otherwise it will just suffix an 's' if count == 1 then it will return the word","title":"plural"},{"location":"reference/javascript_helpers/#age","text":"calculates a persons current age from their date of birth","title":"age"},{"location":"reference/javascript_helpers/#boxed","text":"Displays Boolean fields as a checkbox (e.g. either [ ] or [X]) [[ item.boolean_field | boxed]]","title":"boxed"},{"location":"reference/opal_application/","text":"opal.core.application OpalApplication The base class for your main application entrypoints is opal.core.application.OpalApplication. You must subclass this in order for OPAL to discover your application. If you started your OPAL project via $ opal startproject yourproject then this will have been generated for you, and located in yourproject/yourproject/__init__.py Properties Properties available on an OpalApplication: OpalApplication.actions OpalApplication.default_episode_category The default category is 'Inpatient', but can be overridden in the OpalApplication subclass for your implementation. OpalApplication.javascripts A list of javascripts that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . class MyApplication(OpalApplication): javascripts = ['js/one.js'] OpalApplication.menuitems A list of items to add to the top level menu OpalApplication.styles A list of stylesheets that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . These styles are included after the default OPAL styles. class MyApplication(OpalApplication): styles = ['css/app.css'] Classmethods Classmethod API for OpalApplication instances: OpalApplication.get_core_javascripts(namespace) Return a list of the core javascript files specified within a given namespace. These wil be relative paths ready for staticfiles. application.get_core_javascripts('opal.utils') # - ['js/opal/utils.js', ...] OpalApplication.get_javascripts() Return a list of the application's javasctipts as paths to them ready for staticfiles. Defaults to returning the OpalApplication.javascripts property. application.get_javascripts() # - ['js/one.js', 'js/two.js', ...] OpalApplication.get_menu_items() OpalApplication.get_styles() Return a list of the application's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalApplication.styles . application.get_styles() # - ['css/app.css', ...]","title":"OpalApplication"},{"location":"reference/opal_application/#opalcoreapplication","text":"","title":"opal.core.application"},{"location":"reference/opal_application/#opalapplication","text":"The base class for your main application entrypoints is opal.core.application.OpalApplication. You must subclass this in order for OPAL to discover your application. If you started your OPAL project via $ opal startproject yourproject then this will have been generated for you, and located in yourproject/yourproject/__init__.py","title":"OpalApplication"},{"location":"reference/opal_application/#properties","text":"Properties available on an OpalApplication:","title":"Properties"},{"location":"reference/opal_application/#opalapplicationactions","text":"","title":"OpalApplication.actions"},{"location":"reference/opal_application/#opalapplicationdefault_episode_category","text":"The default category is 'Inpatient', but can be overridden in the OpalApplication subclass for your implementation.","title":"OpalApplication.default_episode_category"},{"location":"reference/opal_application/#opalapplicationjavascripts","text":"A list of javascripts that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . class MyApplication(OpalApplication): javascripts = ['js/one.js']","title":"OpalApplication.javascripts"},{"location":"reference/opal_application/#opalapplicationmenuitems","text":"A list of items to add to the top level menu","title":"OpalApplication.menuitems"},{"location":"reference/opal_application/#opalapplicationstyles","text":"A list of stylesheets that our application would like to include. These should be strings representing paths ready for staticfiles. Defaults to [] . These styles are included after the default OPAL styles. class MyApplication(OpalApplication): styles = ['css/app.css']","title":"OpalApplication.styles"},{"location":"reference/opal_application/#classmethods","text":"Classmethod API for OpalApplication instances:","title":"Classmethods"},{"location":"reference/opal_application/#opalapplicationget_core_javascriptsnamespace","text":"Return a list of the core javascript files specified within a given namespace. These wil be relative paths ready for staticfiles. application.get_core_javascripts('opal.utils') # - ['js/opal/utils.js', ...]","title":"OpalApplication.get_core_javascripts(namespace)"},{"location":"reference/opal_application/#opalapplicationget_javascripts","text":"Return a list of the application's javasctipts as paths to them ready for staticfiles. Defaults to returning the OpalApplication.javascripts property. application.get_javascripts() # - ['js/one.js', 'js/two.js', ...]","title":"OpalApplication.get_javascripts()"},{"location":"reference/opal_application/#opalapplicationget_menu_items","text":"","title":"OpalApplication.get_menu_items()"},{"location":"reference/opal_application/#opalapplicationget_styles","text":"Return a list of the application's stylesheets as paths to them ready for staticfiles. Defaults to returning the contents of OpalApplication.styles . application.get_styles() # - ['css/app.css', ...]","title":"OpalApplication.get_styles()"},{"location":"reference/panels_templatetags/","text":"Panel helpers OPAL comes with a selection of templatetags for rendering OPAL panels for a given subrecord. These panels also allow the user to see instances of the model against the current value of episode in Angular $scope . The user can also create new instances of the given model, as well as editing any existing ones. {% record_panel ... %} Render a panel for a given record that will allow the user to view, create, update and delete instances. The record panel template expects the relevant Angular $scope to have newNamedItem(name, index) , editNamedItem(name, index) and deleteItem(name, index) methods implemented. Default implementations of these are available from the EpisodeDetailMixin . {% load panels %} {% record_panel Diagnosis %} Keywords: model : The model we want to render our panel for title : The display title for this panel detail_template : The display template to use. Defaults to Subrecord.get_detail_template() editable : Whether this panel should allow editing. Defaults to True. angular_filter : An Angular expression that will be evaluated to decide whether to show each item noentries : A string to render if there are no instances of model for the current episode only_display_if_exists : Boolean defaulting to False. If true, the panel will simply not render if there are no instances of model {% record_timeline ... %} Similar to record_panel , record_timeline renders a penel for a given record as a timeline - particularly useful for subrecord types where the date is a key field. {% load panels %} {% record_panel Diagnosis 'when' %} Arguments: model : The model we want to render our panel for whenfield : String of the field that we're using to sort by.","title":"Panel Template tags"},{"location":"reference/panels_templatetags/#panel-helpers","text":"OPAL comes with a selection of templatetags for rendering OPAL panels for a given subrecord. These panels also allow the user to see instances of the model against the current value of episode in Angular $scope . The user can also create new instances of the given model, as well as editing any existing ones.","title":"Panel helpers"},{"location":"reference/panels_templatetags/#record_panel","text":"Render a panel for a given record that will allow the user to view, create, update and delete instances. The record panel template expects the relevant Angular $scope to have newNamedItem(name, index) , editNamedItem(name, index) and deleteItem(name, index) methods implemented. Default implementations of these are available from the EpisodeDetailMixin . {% load panels %} {% record_panel Diagnosis %} Keywords: model : The model we want to render our panel for title : The display title for this panel detail_template : The display template to use. Defaults to Subrecord.get_detail_template() editable : Whether this panel should allow editing. Defaults to True. angular_filter : An Angular expression that will be evaluated to decide whether to show each item noentries : A string to render if there are no instances of model for the current episode only_display_if_exists : Boolean defaulting to False. If true, the panel will simply not render if there are no instances of model","title":"{% record_panel ... %}"},{"location":"reference/panels_templatetags/#record_timeline","text":"Similar to record_panel , record_timeline renders a penel for a given record as a timeline - particularly useful for subrecord types where the date is a key field. {% load panels %} {% record_panel Diagnosis 'when' %} Arguments: model : The model we want to render our panel for whenfield : String of the field that we're using to sort by.","title":"{% record_timeline ... %}"},{"location":"reference/patient/","text":"opal.models.Patient methods create_episode Returns a new Episode for this patient. to_dict Return the dictionary representation of this patient - suitable for serialization. patient.to_dict(user) bulk_update Create or update many subrecords in one go, from a serialised dictionary of data. Pass in a dictionary of subrecords you want to update, as well as an episode if one exists. This method will create all the subrecords and implicitly create a new episode if required. This API will execute all create/update operations as an atomic transaction. For example the following will create a patient: patient = Patient() patient.bulk_update( { \"demographics\": \"hospital_number\": \"1231212\", \"allergies\": [ {\"drug\": \"penicillin\"}, {\"drug\": \"aspirin\"}, ] }, user ) Manager The custom manager for Patient has the following methods: Patient.objects.search A useful utility the patient manager has a search method that will search on first name last name hospital number. Its splits the string input on space, so if you do \"12 Jane\", you will get all Patients who's name, surname or hospital number contains either 12 or Jane, in this example most probably people who's hospital number contains 12 and who's first name is Jane.","title":"Patient"},{"location":"reference/patient/#opalmodelspatient","text":"","title":"opal.models.Patient"},{"location":"reference/patient/#methods","text":"","title":"methods"},{"location":"reference/patient/#create_episode","text":"Returns a new Episode for this patient.","title":"create_episode"},{"location":"reference/patient/#to_dict","text":"Return the dictionary representation of this patient - suitable for serialization. patient.to_dict(user)","title":"to_dict"},{"location":"reference/patient/#bulk_update","text":"Create or update many subrecords in one go, from a serialised dictionary of data. Pass in a dictionary of subrecords you want to update, as well as an episode if one exists. This method will create all the subrecords and implicitly create a new episode if required. This API will execute all create/update operations as an atomic transaction. For example the following will create a patient: patient = Patient() patient.bulk_update( { \"demographics\": \"hospital_number\": \"1231212\", \"allergies\": [ {\"drug\": \"penicillin\"}, {\"drug\": \"aspirin\"}, ] }, user )","title":"bulk_update"},{"location":"reference/patient/#manager","text":"The custom manager for Patient has the following methods:","title":"Manager"},{"location":"reference/patient/#patientobjectssearch","text":"A useful utility the patient manager has a search method that will search on first name last name hospital number. Its splits the string input on space, so if you do \"12 Jane\", you will get all Patients who's name, surname or hospital number contains either 12 or Jane, in this example most probably people who's hospital number contains 12 and who's first name is Jane.","title":"Patient.objects.search"},{"location":"reference/patient_list/","text":"opal.core.patient_lists The patient_lists module defines a number of classes for working with lists of patients. PatientList ... Properties PatientList.display_name How we want to refer to this list on screen to users. TaggedPatientList Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists. Properties TaggedPatientList.tag The main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK. TaggedPatientList.subtag The child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.","title":"Patient Lists"},{"location":"reference/patient_list/#opalcorepatient_lists","text":"The patient_lists module defines a number of classes for working with lists of patients.","title":"opal.core.patient_lists"},{"location":"reference/patient_list/#patientlist","text":"...","title":"PatientList"},{"location":"reference/patient_list/#properties","text":"","title":"Properties"},{"location":"reference/patient_list/#patientlistdisplay_name","text":"How we want to refer to this list on screen to users.","title":"PatientList.display_name"},{"location":"reference/patient_list/#taggedpatientlist","text":"Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties of Patient Lists.","title":"TaggedPatientList"},{"location":"reference/patient_list/#properties_1","text":"","title":"Properties"},{"location":"reference/patient_list/#taggedpatientlisttag","text":"The main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.","title":"TaggedPatientList.tag"},{"location":"reference/patient_list/#taggedpatientlistsubtag","text":"The child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.","title":"TaggedPatientList.subtag"},{"location":"reference/patient_summary_service/","text":"The PatientSummary service The PatientSummary service in opal.services provides us with core functionality related to interacting with patient search results in the client. Constructor The PatientSummary service is instantiated with the Patient search result data that comes back from the Patient search JSON API. var patient_summary = new PatientSummary(json_data);","title":"Patient summary service"},{"location":"reference/patient_summary_service/#the-patientsummary-service","text":"The PatientSummary service in opal.services provides us with core functionality related to interacting with patient search results in the client.","title":"The PatientSummary service"},{"location":"reference/patient_summary_service/#constructor","text":"The PatientSummary service is instantiated with the Patient search result data that comes back from the Patient search JSON API. var patient_summary = new PatientSummary(json_data);","title":"Constructor"},{"location":"reference/reference_guides/","text":"OPAL Reference material The following reference guides are available: Models | -|- opal.models.Episode model | The central Episode model opal.models.Patient | The Patient model opal.models.Subrecord base class |Base class for subrecords of Episodes or Patients OPAL Core | -|- opal.core.application | OPAL Application objects| opal.core.detail |Detail Views - Custom views over one or many episodes.| opal.core.episodes |Episode Categories - Controlling the behaviour of different types of episode| opal.core.schemas |Schemas - Dynamic columns for the table views| opal.core.patient_lists |Patient Lists - defining different types of list| Angular Services | -|- Episode | Episode objects Item | Subrecord objects PatientSummary | Patient search result summaries Search Services | Services from the Search module| Helper libraries | -|- The forms Templatetag library | The building blocks for OPAL forms The panels Templatetag library | Rendering record panels Javascript Helpers | Angular filters and $rootScope methods OPAL Search module | -|- Making Search Queries | Search query backends and helper functions Miscenlaneous documentation | -|- Changelog | OPAL Changelog Upgrading | Upgrading between OPAL versions Javascript dependencies | External javascript libraries available |","title":"Reference"},{"location":"reference/reference_guides/#opal-reference-material","text":"The following reference guides are available:","title":"OPAL Reference material"},{"location":"reference/reference_guides/#models","text":"| -|- opal.models.Episode model | The central Episode model opal.models.Patient | The Patient model opal.models.Subrecord base class |Base class for subrecords of Episodes or Patients","title":"Models"},{"location":"reference/reference_guides/#opal-core","text":"| -|- opal.core.application | OPAL Application objects| opal.core.detail |Detail Views - Custom views over one or many episodes.| opal.core.episodes |Episode Categories - Controlling the behaviour of different types of episode| opal.core.schemas |Schemas - Dynamic columns for the table views| opal.core.patient_lists |Patient Lists - defining different types of list|","title":"OPAL Core"},{"location":"reference/reference_guides/#angular-services","text":"| -|- Episode | Episode objects Item | Subrecord objects PatientSummary | Patient search result summaries Search Services | Services from the Search module|","title":"Angular Services"},{"location":"reference/reference_guides/#helper-libraries","text":"| -|- The forms Templatetag library | The building blocks for OPAL forms The panels Templatetag library | Rendering record panels Javascript Helpers | Angular filters and $rootScope methods","title":"Helper libraries"},{"location":"reference/reference_guides/#opal-search-module","text":"| -|- Making Search Queries | Search query backends and helper functions","title":"OPAL Search module"},{"location":"reference/reference_guides/#miscenlaneous-documentation","text":"| -|- Changelog | OPAL Changelog Upgrading | Upgrading between OPAL versions Javascript dependencies | External javascript libraries available |","title":"Miscenlaneous documentation"},{"location":"reference/schemas/","text":"OPAL Schemas Opal Schemas allow dynamic representation of columns within a table get_all_list_schema_classes returns a dictionary to a list of classes of all the plugins (the classes are the columns inc column headers)","title":"Schemas"},{"location":"reference/schemas/#opal-schemas","text":"Opal Schemas allow dynamic representation of columns within a table","title":"OPAL Schemas"},{"location":"reference/schemas/#get_all_list_schema_classes","text":"returns a dictionary to a list of classes of all the plugins (the classes are the columns inc column headers)","title":"get_all_list_schema_classes"},{"location":"reference/search_js_services/","text":"OPAL Core Search Javascript Services Filter The Angular Service for saved filters. Maps to the model opal.models.Filter . save(attrs) Save this filter with the attributes passed in. If there is no ID, this is taken to be a create. destroy() Destroy this filter. filtersLoader Loader service that will resolve with instantiated Filter objects for each of the current user's filters. FilterResource Angular $resource for Filter objects.","title":"Search JS Services"},{"location":"reference/search_js_services/#opal-core-search-javascript-services","text":"","title":"OPAL Core Search Javascript Services"},{"location":"reference/search_js_services/#filter","text":"The Angular Service for saved filters. Maps to the model opal.models.Filter .","title":"Filter"},{"location":"reference/search_js_services/#saveattrs","text":"Save this filter with the attributes passed in. If there is no ID, this is taken to be a create.","title":"save(attrs)"},{"location":"reference/search_js_services/#destroy","text":"Destroy this filter.","title":"destroy()"},{"location":"reference/search_js_services/#filtersloader","text":"Loader service that will resolve with instantiated Filter objects for each of the current user's filters.","title":"filtersLoader"},{"location":"reference/search_js_services/#filterresource","text":"Angular $resource for Filter objects.","title":"FilterResource"},{"location":"reference/search_queries/","text":"opal.core.search.queries This module provides our base classes for query backends as well as helper functions. episodes_for_user Given an iterable of EPISODES and a USER, return a filtered list of episodes that this user has the permissions to know about. filtered_episodes = episodes_for_user(episodes, user)","title":"Search Queries"},{"location":"reference/search_queries/#opalcoresearchqueries","text":"This module provides our base classes for query backends as well as helper functions.","title":"opal.core.search.queries"},{"location":"reference/search_queries/#episodes_for_user","text":"Given an iterable of EPISODES and a USER, return a filtered list of episodes that this user has the permissions to know about. filtered_episodes = episodes_for_user(episodes, user)","title":"episodes_for_user"},{"location":"reference/subrecords/","text":"OPAL Subrecords OPAL Subrecords are models that relate to either Patients or Episodes, and inherit from base classes opal.models.PatientSubrecord or opal.models.EpisodeSubrecord Properties Subrecord._angular_service Name of the Angular service you would like to use to customise the initialization of this subrecord in the javascript layer. class Demographics(PatientSubrecord): _angular_service = 'Demographics' Subrecord._icon String that provides the name of the icon to use for forms, column headings etc. class Demographics(PatientSubrecord): _icon = 'fa fa-user' Subrecord._is_singleton Boolean that determines whether this subrecord is a singleton. There may only be one of each singleton Subrecord, which is created whth the parent. class Demographics(PatientSubrecord): _is_singleton = True For this case, when a Patient is created, an empty Demographics instance will automatically be created. Subrecord._list_limit Integer to indicate the maximum number of entries to display in list view for this model. Useful for record types where many entries will accrue, or where display is particularly verbose. class BloodPressureReading(EpisodeSubrecord): _list_limit = 3 Subrecord._modal String to indicate a non-default modal size to be used for editing this Subrecord . Valid options are: 'lg', 'sm'. Typically used for complex forms or the display of additional contextually sensitive information when editing or entering data. class Antimicrobial(EpisodeSubrecord): _modal = 'lg' Subrecord._sort Name of the field by which we want to sort these records when displaying. class Antimicrobial(EpisodeSubrecord): _sort = 'start_date' Subrecord._title String we would like to use for user-facing display of this record type. class Antimicrobial(EpisodeSubrecord): _title = 'Abx' Subrecord._clonable A Boolean that is True by default used by opal.views.EpisodeCopyToCategoryView to determine if instances of this record should be copied across. class Antimicrobial(EpisodeSubrecord): _clonable = 'False' Subrecord._exclude_from_extract Boolean to specify that this subrecord should be excluded from any standard data extract. This implicitly defaults to False. class Antimicrobial(EpisodeSubrecord): _exclude_from_extract = 'Abx' Subrecord.pid_fields An iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID). This is used when creating data extracts to exclude PID from e.g. CSV downloads. Methods Subrecord.get_display_template() Classmethod to locate the active display template for our record. Returns the name of the template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations Subrecord.get_form_template() Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations Subrecord.get_modal_template() Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for modal customisations patient_list Optional patient list slug string to check for modal customisations Subrecord.get_modal_footer_template Classmethod to add a custom footer to a modal, used for example to denote if the data from a model has been sourced from an external source Subrecord.update_from_dict() An instance method that will update a model with a dictionary. This method is used to provides a hook for changing the way a subrecord handles being updated from serialised data. For example on a new allergy allergy.update_from_dict({\"drug\": \"penicillin\"}) will update the allergy to have the correct drug Subrecord.bulk_update_from_dicts() A Classmethod to allow the creation of multiple objects. Takes in the parent model - an episode for EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates over all the subrecords, adds in the parent relationship and calls update_from_dict Subrecord Mixins TrackedModel A Tracked Model automatically has created, created_by, updated, updated_by and these are only updated when used via the api ExternallySourcedModel Often we want data to be sourced from external systems, this mixin adds in the fields external_system and external_identifier to allow us to track where they come from and how they are referenced by that system. These fields are then often used in forms to make the data read only","title":"Subrecords"},{"location":"reference/subrecords/#opal-subrecords","text":"OPAL Subrecords are models that relate to either Patients or Episodes, and inherit from base classes opal.models.PatientSubrecord or opal.models.EpisodeSubrecord","title":"OPAL Subrecords"},{"location":"reference/subrecords/#properties","text":"","title":"Properties"},{"location":"reference/subrecords/#subrecord_angular_service","text":"Name of the Angular service you would like to use to customise the initialization of this subrecord in the javascript layer. class Demographics(PatientSubrecord): _angular_service = 'Demographics'","title":"Subrecord._angular_service"},{"location":"reference/subrecords/#subrecord_icon","text":"String that provides the name of the icon to use for forms, column headings etc. class Demographics(PatientSubrecord): _icon = 'fa fa-user'","title":"Subrecord._icon"},{"location":"reference/subrecords/#subrecord_is_singleton","text":"Boolean that determines whether this subrecord is a singleton. There may only be one of each singleton Subrecord, which is created whth the parent. class Demographics(PatientSubrecord): _is_singleton = True For this case, when a Patient is created, an empty Demographics instance will automatically be created.","title":"Subrecord._is_singleton"},{"location":"reference/subrecords/#subrecord_list_limit","text":"Integer to indicate the maximum number of entries to display in list view for this model. Useful for record types where many entries will accrue, or where display is particularly verbose. class BloodPressureReading(EpisodeSubrecord): _list_limit = 3","title":"Subrecord._list_limit"},{"location":"reference/subrecords/#subrecord_modal","text":"String to indicate a non-default modal size to be used for editing this Subrecord . Valid options are: 'lg', 'sm'. Typically used for complex forms or the display of additional contextually sensitive information when editing or entering data. class Antimicrobial(EpisodeSubrecord): _modal = 'lg'","title":"Subrecord._modal"},{"location":"reference/subrecords/#subrecord_sort","text":"Name of the field by which we want to sort these records when displaying. class Antimicrobial(EpisodeSubrecord): _sort = 'start_date'","title":"Subrecord._sort"},{"location":"reference/subrecords/#subrecord_title","text":"String we would like to use for user-facing display of this record type. class Antimicrobial(EpisodeSubrecord): _title = 'Abx'","title":"Subrecord._title"},{"location":"reference/subrecords/#subrecord_clonable","text":"A Boolean that is True by default used by opal.views.EpisodeCopyToCategoryView to determine if instances of this record should be copied across. class Antimicrobial(EpisodeSubrecord): _clonable = 'False'","title":"Subrecord._clonable"},{"location":"reference/subrecords/#subrecord_exclude_from_extract","text":"Boolean to specify that this subrecord should be excluded from any standard data extract. This implicitly defaults to False. class Antimicrobial(EpisodeSubrecord): _exclude_from_extract = 'Abx'","title":"Subrecord._exclude_from_extract"},{"location":"reference/subrecords/#subrecordpid_fields","text":"An iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID). This is used when creating data extracts to exclude PID from e.g. CSV downloads.","title":"Subrecord.pid_fields"},{"location":"reference/subrecords/#methods","text":"","title":"Methods"},{"location":"reference/subrecords/#subrecordget_display_template","text":"Classmethod to locate the active display template for our record. Returns the name of the template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations","title":"Subrecord.get_display_template()"},{"location":"reference/subrecords/#subrecordget_form_template","text":"Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for form customisations patient_list Optional patient list slug string to check for form customisations","title":"Subrecord.get_form_template()"},{"location":"reference/subrecords/#subrecordget_modal_template","text":"Classmethod to locate the active template for our record. Returns the name of a template or None. Keywords: episode_type Optional episode type string to check for modal customisations patient_list Optional patient list slug string to check for modal customisations","title":"Subrecord.get_modal_template()"},{"location":"reference/subrecords/#subrecordget_modal_footer_template","text":"Classmethod to add a custom footer to a modal, used for example to denote if the data from a model has been sourced from an external source","title":"Subrecord.get_modal_footer_template"},{"location":"reference/subrecords/#subrecordupdate_from_dict","text":"An instance method that will update a model with a dictionary. This method is used to provides a hook for changing the way a subrecord handles being updated from serialised data. For example on a new allergy allergy.update_from_dict({\"drug\": \"penicillin\"}) will update the allergy to have the correct drug","title":"Subrecord.update_from_dict()"},{"location":"reference/subrecords/#subrecordbulk_update_from_dicts","text":"A Classmethod to allow the creation of multiple objects. Takes in the parent model - an episode for EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates over all the subrecords, adds in the parent relationship and calls update_from_dict","title":"Subrecord.bulk_update_from_dicts()"},{"location":"reference/subrecords/#subrecord-mixins","text":"","title":"Subrecord Mixins"},{"location":"reference/subrecords/#trackedmodel","text":"A Tracked Model automatically has created, created_by, updated, updated_by and these are only updated when used via the api","title":"TrackedModel"},{"location":"reference/subrecords/#externallysourcedmodel","text":"Often we want data to be sourced from external systems, this mixin adds in the fields external_system and external_identifier to allow us to track where they come from and how they are referenced by that system. These fields are then often used in forms to make the data read only","title":"ExternallySourcedModel"},{"location":"reference/upgrading/","text":"Upgrading Your OPAL Application This document provides instructions for specific steps required to upgrading your OPAL application to a later version where there are extra steps required. 6.x - 7.x Upgrading OPAL How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.7.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for OPAL 0.6.x $ python manage.py migrate opal If you are inheriting from the abstract models in OPAL e.g. Demographics then you should run a makemigrations command to update to the 0.7.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp Breaking changes OPAL 0.7 contains a number of breaking changes. Name changes opal.models.Episode.category has been re-named category_name . If your application directly sets category, you will be required to update all instances where this happens. The /episode/:pk/ API has moved to /api/v0.1/episode/:pk/ so any code (typically javascript) code that directly saves to this API endpoint rather than using the OPAL JS Episode services should work immediately when re-pointed at the new URL. Moving from options to referencedata and metadata The signature of the EditItemCtrl has been updated - this modal controller no longer takes an options argument, rather it uses the new 0.7.x referencedata and metadata services. Applications that call EditItemCtrl directly should look to update the resolves option they were passing to $modal.open . (Alternatively, developers should consider refactoring to use the new recordEditor API.) The signatures of Flow enter and exit methods has changed to no longer accept options as a positional argument, and enter/exit controllers will no longer be initialized with access to options as a resovled provider. They will have access to either/both of referencedata and metadata so if your application includes custom flow controllers that use options you will need to refactor these to use the new x-data arguments instead. referencedata and metadata between them have all data previously in options, so the refactor here should be relatively painless. Date of birth fields in forms The partial partials/_date_of_birth_field.html has been removed and replaced with the {% date_of_birth_field %} templatetag in the forms library. You should update any forms to use this new tag. 5.x - 6.x Upgrading OPAL How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.6.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for OPAL 0.6.x $ python manage.py migrate opal Changes to abstract models If you are inheriting from the abstract models in OPAL e.g. Demographics then you should run a makemigrations command to update to the 0.6.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp You should note that as of OPAL 0.6.x Demographics now splits names into first, surname, middle name and title. The previous name field will be converted to be first_name . Strategies for updating your data to use the appropriate fields will vary from application to application, but one good such strategy is to use a data migration such as the one done here . Update settings Many of the default OPAL templates now assume that the 'opal.context_processors.models' Context Processor is available - you should add that to the TEMPLATE_CONTEXT_PROCESSORS setting in your application's settings.py The default date formats in OPAL have changed - and so you should update your DATE_X settings to match: DATE_FORMAT = 'd/m/Y' DATE_INPUT_FORMATS = ['%d/%m/%Y'] DATETIME_FORMAT = 'd/m/Y H:i:s' DATETIME_INPUT_FORMATS = ['%d/%m/%Y %H:%M:%S'] Upgrade plugins A number of OPAL plugins have new releases to work with the changes in OPAL 0.6.x opal-referral - Upgrade to 0.1.4 opal-wardround - Upgrade to 0.6.0 opal-observations - Upgrade to 0.1.2 opal-dischargesummary - Upgrade to 0.2.0 opal-dashboard - Upgrade to 0.1.3 Meanwhile the opal-taskrunner plugin has now been deprecated, this functionality now living natively within OPAL core. Update your Teams to be PatientLists Patient Lists are now driven by subclasses of opal.core.PatientList , so we will need to convert your Teams to be PatientLists. You may want to re-enable the Team admin while you do so - this is simple, by updating your application's admin.py : # yourapp/admin.py ... from opal.admin import TeamAdmin from opal.models import Team admin.site.register(Team, TeamAdmin) Patient lists are now declarative. For instance, to replicate the following team: We would convert that to: # yourapp/patient*lists.py from opal.core import patient_lists class RespiratoryList(patient_lists.TaggedPatientList): display_name = 'Respiratory' tag = 'respiratory' order = 4 schema = [models.Demographics, models.Treatment] The schema property will likely be available to you in your application's schema.py file - which is now obsolete. See the full patient list documentation for further details of the options available for Patient Lists. Form and Display templates. We may now be missing some form or display templates, as your application may be relying on templates previously in OPAL. To discover which these are, run $ opal scaffold --dry-run You may either create templates by hand, or have OPAL generate boilerplate templates for you by running $ opal scaffold . Modal templates already in your application will likely be referencing invalid paths to their Angular variables. You should update these to include the record name - for example: !-- Was -- {% input label= Drug model= editing.drug lookuplist= antimicrobial_list %} !-- Becomes -- {% input label= Drug model= editing.treatment.drug lookuplist= antimicrobial_list %} The Inpatient episode category The default Episode Category - Inpatient episodes has updated it's database identifier from inpatient to Inpatient . To update your episodes run : from opal.models import Episode for e in Episode.objects.filter(category='inpatient'): ... e.category='Inpatient' ... e.save() ... Any references to episode category in templates (for e.g. ng-hide) or controllers for logic will also require updates. Flow is now defined in JS Flow is no longer defined on the server side in python, but rather is a javascript service. See the documentation for information about setting up custom flows. At a minimum applications that use custom flows will have to implement their own flow service and reference it in their settings. 4.X - 5.x Migrations Before upgrading from 4.x to 5.x you should ensure that you have upgraded from South to Djangomigrations. $ rm yourapp/migrations/* $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp --fake-initial OPAL Next you will need to upgrade the OPAL version itself. How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. This will also update FFS and Django Axes as well as adding Python Dateutil. -e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal Migrations. OPAL has fresh migrations in 0.5.x, which we should run. There are also changes to the base abstract model classes (to add created/updated timestamps) so you'll need to create fresh migrations for your own application. $ python manage.py migrate $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp At this stage you'll want to commit your new migrations, as well as any changes to your application's requirements file. Tags As of 0.5.5, old tags in OPAL are stored directly on the Tagging model rather than via Djano Reversion. We can import those old tags by doing the following. $ python manage.py shell from opal.models import Tagging Tagging.import_from_reversion() Deployment The first time you deploy your upgraded application you'll need to run the following commands to upgrade your database: $ python manage.py migrate --fake-initial You'll also have to repeat the Tagging step once for each deployment.","title":"Upgrading"},{"location":"reference/upgrading/#upgrading-your-opal-application","text":"This document provides instructions for specific steps required to upgrading your OPAL application to a later version where there are extra steps required.","title":"Upgrading Your OPAL Application"},{"location":"reference/upgrading/#6x-7x","text":"","title":"6.x -&gt; 7.x"},{"location":"reference/upgrading/#upgrading-opal","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.7.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for OPAL 0.6.x $ python manage.py migrate opal If you are inheriting from the abstract models in OPAL e.g. Demographics then you should run a makemigrations command to update to the 0.7.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp","title":"Upgrading OPAL"},{"location":"reference/upgrading/#breaking-changes","text":"OPAL 0.7 contains a number of breaking changes.","title":"Breaking changes"},{"location":"reference/upgrading/#name-changes","text":"opal.models.Episode.category has been re-named category_name . If your application directly sets category, you will be required to update all instances where this happens. The /episode/:pk/ API has moved to /api/v0.1/episode/:pk/ so any code (typically javascript) code that directly saves to this API endpoint rather than using the OPAL JS Episode services should work immediately when re-pointed at the new URL.","title":"Name changes"},{"location":"reference/upgrading/#moving-from-options-to-referencedata-and-metadata","text":"The signature of the EditItemCtrl has been updated - this modal controller no longer takes an options argument, rather it uses the new 0.7.x referencedata and metadata services. Applications that call EditItemCtrl directly should look to update the resolves option they were passing to $modal.open . (Alternatively, developers should consider refactoring to use the new recordEditor API.) The signatures of Flow enter and exit methods has changed to no longer accept options as a positional argument, and enter/exit controllers will no longer be initialized with access to options as a resovled provider. They will have access to either/both of referencedata and metadata so if your application includes custom flow controllers that use options you will need to refactor these to use the new x-data arguments instead. referencedata and metadata between them have all data previously in options, so the refactor here should be relatively painless.","title":"Moving from options to referencedata and metadata"},{"location":"reference/upgrading/#date-of-birth-fields-in-forms","text":"The partial partials/_date_of_birth_field.html has been removed and replaced with the {% date_of_birth_field %} templatetag in the forms library. You should update any forms to use this new tag.","title":"Date of birth fields in forms"},{"location":"reference/upgrading/#5x-6x","text":"","title":"5.x -&gt; 6.x"},{"location":"reference/upgrading/#upgrading-opal_1","text":"How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. # requirements.txt opal==0.6.0 After re-installing (via for instance pip install -r requirements.txt ) you will need to run the migrations for OPAL 0.6.x $ python manage.py migrate opal","title":"Upgrading OPAL"},{"location":"reference/upgrading/#changes-to-abstract-models","text":"If you are inheriting from the abstract models in OPAL e.g. Demographics then you should run a makemigrations command to update to the 0.6.x data model. python manage.py makemigrations yourapp python manage.py migrate yourapp You should note that as of OPAL 0.6.x Demographics now splits names into first, surname, middle name and title. The previous name field will be converted to be first_name . Strategies for updating your data to use the appropriate fields will vary from application to application, but one good such strategy is to use a data migration such as the one done here .","title":"Changes to abstract models"},{"location":"reference/upgrading/#update-settings","text":"Many of the default OPAL templates now assume that the 'opal.context_processors.models' Context Processor is available - you should add that to the TEMPLATE_CONTEXT_PROCESSORS setting in your application's settings.py The default date formats in OPAL have changed - and so you should update your DATE_X settings to match: DATE_FORMAT = 'd/m/Y' DATE_INPUT_FORMATS = ['%d/%m/%Y'] DATETIME_FORMAT = 'd/m/Y H:i:s' DATETIME_INPUT_FORMATS = ['%d/%m/%Y %H:%M:%S']","title":"Update settings"},{"location":"reference/upgrading/#upgrade-plugins","text":"A number of OPAL plugins have new releases to work with the changes in OPAL 0.6.x opal-referral - Upgrade to 0.1.4 opal-wardround - Upgrade to 0.6.0 opal-observations - Upgrade to 0.1.2 opal-dischargesummary - Upgrade to 0.2.0 opal-dashboard - Upgrade to 0.1.3 Meanwhile the opal-taskrunner plugin has now been deprecated, this functionality now living natively within OPAL core.","title":"Upgrade plugins"},{"location":"reference/upgrading/#update-your-teams-to-be-patientlists","text":"Patient Lists are now driven by subclasses of opal.core.PatientList , so we will need to convert your Teams to be PatientLists. You may want to re-enable the Team admin while you do so - this is simple, by updating your application's admin.py : # yourapp/admin.py ... from opal.admin import TeamAdmin from opal.models import Team admin.site.register(Team, TeamAdmin) Patient lists are now declarative. For instance, to replicate the following team: We would convert that to: # yourapp/patient*lists.py from opal.core import patient_lists class RespiratoryList(patient_lists.TaggedPatientList): display_name = 'Respiratory' tag = 'respiratory' order = 4 schema = [models.Demographics, models.Treatment] The schema property will likely be available to you in your application's schema.py file - which is now obsolete. See the full patient list documentation for further details of the options available for Patient Lists.","title":"Update your Teams to be PatientLists"},{"location":"reference/upgrading/#form-and-display-templates","text":"We may now be missing some form or display templates, as your application may be relying on templates previously in OPAL. To discover which these are, run $ opal scaffold --dry-run You may either create templates by hand, or have OPAL generate boilerplate templates for you by running $ opal scaffold . Modal templates already in your application will likely be referencing invalid paths to their Angular variables. You should update these to include the record name - for example: !-- Was -- {% input label= Drug model= editing.drug lookuplist= antimicrobial_list %} !-- Becomes -- {% input label= Drug model= editing.treatment.drug lookuplist= antimicrobial_list %}","title":"Form and Display templates."},{"location":"reference/upgrading/#the-inpatient-episode-category","text":"The default Episode Category - Inpatient episodes has updated it's database identifier from inpatient to Inpatient . To update your episodes run : from opal.models import Episode for e in Episode.objects.filter(category='inpatient'): ... e.category='Inpatient' ... e.save() ... Any references to episode category in templates (for e.g. ng-hide) or controllers for logic will also require updates.","title":"The Inpatient episode category"},{"location":"reference/upgrading/#flow-is-now-defined-in-js","text":"Flow is no longer defined on the server side in python, but rather is a javascript service. See the documentation for information about setting up custom flows. At a minimum applications that use custom flows will have to implement their own flow service and reference it in their settings.","title":"Flow is now defined in JS"},{"location":"reference/upgrading/#4x-5x","text":"","title":"4.X -&gt; 5.x"},{"location":"reference/upgrading/#migrations","text":"Before upgrading from 4.x to 5.x you should ensure that you have upgraded from South to Djangomigrations. $ rm yourapp/migrations/* $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp --fake-initial","title":"Migrations"},{"location":"reference/upgrading/#opal","text":"Next you will need to upgrade the OPAL version itself. How you do this depends on how you have configured your application, but updating your requirements.txt to update the version should work. This will also update FFS and Django Axes as well as adding Python Dateutil. -e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal","title":"OPAL"},{"location":"reference/upgrading/#migrations_1","text":"OPAL has fresh migrations in 0.5.x, which we should run. There are also changes to the base abstract model classes (to add created/updated timestamps) so you'll need to create fresh migrations for your own application. $ python manage.py migrate $ python manage.py makemigrations yourapp $ python manage.py migrate yourapp At this stage you'll want to commit your new migrations, as well as any changes to your application's requirements file.","title":"Migrations."},{"location":"reference/upgrading/#tags","text":"As of 0.5.5, old tags in OPAL are stored directly on the Tagging model rather than via Djano Reversion. We can import those old tags by doing the following. $ python manage.py shell from opal.models import Tagging Tagging.import_from_reversion()","title":"Tags"},{"location":"reference/upgrading/#deployment","text":"The first time you deploy your upgraded application you'll need to run the following commands to upgrade your database: $ python manage.py migrate --fake-initial You'll also have to repeat the Tagging step once for each deployment.","title":"Deployment"}]}