{
    "docs": [
        {
            "location": "/", 
            "text": "OPAL Documentation\n\n\nOPAL is a full stack framework that makes building digital tools for health care easy.\n\n\n\n\nOPAL builds deep clinical domain specific functionality on top of\n\nDjango\n, \nAngular\n\nand \nBootstrap\n to help developers quickly build easy to maintain,\nrobust clinical applications.\n\n\nThis is the \ndeveloper documentation\n.\n\n\n\n\nOPAL is an entirely Open \nSource\n,\nOpen \nGovernance\n product, as are the wide library of plugins.\n\n\nFirst Steps\n\n\nIf you're new to OPAL, then you'll want to take a look at the\n\nInstallation instructions\n, and then maybe take the\n\ntutorial\n.\n\n\nFull documentation\n\n\nWhile \nTopic guides\n are available for many key areas of OPAL,\nthe \nDetailed reference material\n is a work in progress.\n\n\nIf you find any issues or missing areas of this documentation, please do raise it with the\nteam on the \nGithub issue tracker\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#opal-documentation", 
            "text": "OPAL is a full stack framework that makes building digital tools for health care easy.   OPAL builds deep clinical domain specific functionality on top of Django ,  Angular \nand  Bootstrap  to help developers quickly build easy to maintain,\nrobust clinical applications.  This is the  developer documentation .   OPAL is an entirely Open  Source ,\nOpen  Governance  product, as are the wide library of plugins.  First Steps  If you're new to OPAL, then you'll want to take a look at the Installation instructions , and then maybe take the tutorial .  Full documentation  While  Topic guides  are available for many key areas of OPAL,\nthe  Detailed reference material  is a work in progress.  If you find any issues or missing areas of this documentation, please do raise it with the\nteam on the  Github issue tracker .", 
            "title": "OPAL Documentation"
        }, 
        {
            "location": "/installation/", 
            "text": "Installing OPAL\n\n\nInstallation should be simple.\n\n\nStep 1: The Prerequisites\n\n\nBefore you install OPAL, you'll need to make sure that you have \n\nPython\n and \npip\n\ninstalled on your system.\n\n\nLet's just check that you do:\n\n\n$ python --version\nPython 2.7.5\n$ pip --version\npip 1.5.6\n\n\n\nStep 2: Use Pip\n\n\nNow we can install OPAL using pip:\n\n\n$ pip install opal\n\n\n\nYou should now have the \nopal\n commandline tools installed.\n\n\nLet's just check that you do:\n\n\n$ opal --version\nOPAL 0.6.0\n\n\n\nStep 3: There is no step 3.\n\n\nMaybe make yourself somme tea \n then try the \nTutorial\n instead ?", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installing-opal", 
            "text": "Installation should be simple.  Step 1: The Prerequisites  Before you install OPAL, you'll need to make sure that you have  Python  and  pip \ninstalled on your system.  Let's just check that you do:  $ python --version\nPython 2.7.5\n$ pip --version\npip 1.5.6  Step 2: Use Pip  Now we can install OPAL using pip:  $ pip install opal  You should now have the  opal  commandline tools installed.  Let's just check that you do:  $ opal --version\nOPAL 0.6.0  Step 3: There is no step 3.  Maybe make yourself somme tea   then try the  Tutorial  instead ?", 
            "title": "Installing OPAL"
        }, 
        {
            "location": "/tutorial/", 
            "text": "Writing a clinical service with OPAL\n\n\nThis tutorial will walk you through the creation of a new OPAL service.\n\n\nThe application we're going to be building will help clinical users to manage the patients on a ward in a hospital.\n\n\n\nAs a Doctor \n\nI want to know what's going on with the patients under my care\n\nSo that I can treat them effectively and safely.\n\n\n\n\nBootstrapping a new project\n\n\nWe assume that you've already \nInstalled OPAL\n. You can tell which version of opal is installed\nby running this command\n\n\n$ opal --version\n\n\n\nAt the start a new project, OPAL will bootstrap the initial project structure, including\na Djano project, some core datamodels (complete with JSON APIs) and a general application structure.\n\n\nFrom the commandline:\n\n\n$ opal startproject mynewapp\n\n\n\nThis will create a mynewap directory where your new project lives.\n\n\nLet's have a look at what that created for you:\n\n\nmynewapp/                   # Your project directory\n    LICENSE                 # A dummy LICENSE file\n    Procfile                # A procfile ready for deployment to e.g. Heroku\n    README.md\n    manage.py               # Django's manage.py script\n    requirements.txt        # Requirements file ready for your project\n\n    data/                   # A dummy directory for fixtures\n\n    mynewapp/               # The actual python package for your application\n         __init__.py\n        flow.py             # How patients move through your services\n        models.py           # Data models for your application\n        schema.py           # The list schemas for your application\n        settings.py         # Helpfully tweaked Django settings\n        tests.py            # Dummy unittests\n        urls.py             # Django Urlconf\n        wsgi.py\n\n        assets/             # Your static files directory\n        templates/          # Your template directory\n        migrations/         # Your Database migrations directory\n\n        opal.sqlite         # The Sqlite development database\n\n\n\nTest it out\n\n\nThe scaffolding step has generated you a working project - so let's check that out\n\n\ncd mynewapp\npython manage.py runserver\n\n\n\nIf you now visit \nhttp://localhost:8000\n in your browser, you should see the standard login screen:\n\n\n\n\nThe scaffolding step created you a superuser, so try logging in with the credentials:\n\n\n\n\nUsername: \nsuper\n\n\nPassword:  \nsuper1\n\n\n\n\nWhen you log in you should be presented with a welcome screen that shows you the three\nareas that are enabled by default - team lists, search and the admin area.\n\n\n\n\nOPAL applications are a collection of single page Angular apps that talk to the Django\nserver-side layer via JSON APIs. The Team Lists and Search options here are two examples of\nfront-end Angular single page apps.\n\n\nTeam lists\n\n\nMost clinical services will need at some stage to generate a list of patients - so OPAL provides\nthis functionality enabled by default.\n\n\nThe \nlist view\n is a spreadhseet-style list of patients - try navigating\nto the list view and adding a patient with the \nadd patient\n button.\n\n\n\n\nEach column contains a different type of information about a patient, while each\nrow represents one patient.\n\n\n\nStrictly speaking each row is an \nepisode\n\nof care for a patient - but we'll come to that in a second.\n\n\n\n\nThe columns you see initially are just a few of the standard clinical models that come with\nOPAL - for instance the Diagnosis model in your new application inherits from a model that\nlooks a lot like this:\n\n\nclass Diagnosis(EpisodeSubrecord):\n    condition         = ForeignKeyOrFreeText(Condition)\n    provisional       = models.BooleanField(default=False)\n    details           = models.CharField(max_length=255, blank=True)\n    date_of_diagnosis = models.DateField(blank=True, null=True)\n\n    class Meta:\n        abstract = True\n\n\n\nLookup Lists\n\n\nYou will notice that the condition field has a custom field type - \nForeignKeyOrFreeText\n.\nThis is a custom field type that we use with OPAL when we want to use a\n\nLookup List\n.\n\n\nLookup Lists allow us to reference canonical lists of available terminology as a foreign key, while\nalso allowing synonymous terms, and a free text override. That means that we can ensure that\nwe record high quality coded data, while allowing users an easy way to enter unusual edge\ncases.\n\n\nYou'll need to import the data for a terminology before you can start to take advantage of that.\nFor now, let's use the reference data from elCID (An OPAL application maintained by Open Health Care):\n\n\nwget https://raw.githubusercontent.com/openhealthcare/elcid/master/data/lookuplists/lookuplists.json -P data/lookuplists\n\n\n\n\nBy convention, we store data in the \n./data/lookuplists\n directory of our project.\n\n\n\n\nNow let's import the data:\n\n\npython manage.py load_lookup_lists -f data/lookuplists/lookuplists.json\n\n\n\nNow refresh your application and try adding a new diagnosis to your patient. As you start to type in\nthe condition field, you'l see that the conditions we just imported appear as suggestions:\n\n\n\n\nAdd your own data models\n\n\nSo far we've begun to get a sense of the batteries-included parts of OPAL,\nbut before long, you're going to need to create models for your own needs.\n\n\nMost OPAL models are \nSubrecords\n - they relate to either a patient, or\nan episode (an episode is for example, an admission to hospital).\n\n\nLet's see how that works by creating a TODO list model that is assigned to\nepisodes of care. In your \nmynewapp/models.py\n :\n\n\nclass TODOItem(models.EpisodeSubrecord):\n    job       = fields.CharField(max_length=200)\n    due_date  = fields.DateField(blank=True, null=True)\n    details   = fields.TextField(blank=True, null=True)\n    completed = fields.BooleanField(default=False)\n\n\n\nThis is simply a Django model, apart from the parent class \nmodels.EpisodeSubrecord\n\nwhich provides us with some extra functionality:\n\n\n\n\nA relationship to an episode, linked to a patient\n\n\nJSON APIs for creating, retrieving and updating it\n\n\nEnsuring that the OPAL Angular layer knows it exists\n\n\n\n\nNext, we're going to let OPAL take care of the boilerplate that we'll need to use this\nmodel in our application. From the commandline:\n\n\n$ opal scaffold mynewapp\n\n\n\nLet's take a look at what that did:\n\n\n\n\nIt created a Django migration\n\n\nIt created a detail template \nmynewapp/templates/records/todo_item.html\n\n\nIt created a form template \nmynewapp/templates/modals/todo_item_modal.html\n\n\n\n\nDetail template\n\n\nThe default detail template simply displays each field on a new line:\n\n\nspan ng-show=\"item.job\"\n[[ item.job ]] \nbr /\n/span\n\n\nspan ng-show=\"item.due_date\"\n[[ item.due_date  | shortDate ]] \nbr /\n/span\n\n\nspan ng-show=\"item.details\"\n[[ item.details ]] \nbr /\n/span\n\n\nspan ng-show=\"item.completed\"\n[[ item.completed ]] \nbr /\n/span\n\n\n\n\nForm template\n\n\nThe default form template will display each field on a new line, with some basic\nappropriate form field types set.\nIt uses the OPAL form helpers templatetag library.\n\n\n{% extends 'modal_base.html' %}\n{% load forms %}\n{% block modal_body %}\n  \nform class=\"form-horizontal\"\n\n   {% input  label=\"Job\" model=\"editing.job\"  %}\n   {% datepicker  label=\"Due Date\" model=\"editing.due_date\"  %}\n   {% textarea  label=\"Details\" model=\"editing.details\"  %}\n   {% checkbox  label=\"Completed\" model=\"editing.completed\"  %}\n  \n/form\n\n{% endblock %}\n\n\n\nAdding TODOs to our Team Lists\n\n\nNow let's add our TODO list model as a column in the Spreadsheet-like list view.\n\n\nThe columns for team lists are set in \nmynewapp/schema.py\n as a list of models.\n\n\nOpen mynewapp/schemas.py and edit the \nlist_columns\n variable to add \nmodels.TODOItem\n as\nthe final item:\n\n\nlist_columns = [\n    models.Demographics,\n    models.Location,\n    models.Allergies,\n    models.Diagnosis,\n    models.PastMedicalHistory,\n    models.Treatment,\n    models.Investigation,\n    models.TODOItem\n]\n\n\n\nRefresh the lists page in your browser, and you'll see your new column on the end - add a\nTODO item, noting how we automatically get appropriate form types like datepickers and\ncheckboxes.\n\n\nYou can edit any entry in the list view by double clicking on it.\n\n\nTweaking the default scaffolding\n\n\nThe scaffolding templates are only really supposed to get you started - you'll often\nneed to tweak the templates they generate with whatever logic makes sense for your\napplication.\n\n\nFor us, you'll notice that the value of \nTODOItem.completed\n simply displays as false -\nwhich is not particularly useful. So let's update that using the OPAL\n\nBoxed filter\n. In \nmynewapp/templates/records/todo_item.html\n\nchange the last line to look like this:\n\n\nspan ng-show=\"item.completed\"\n[[ item.completed | boxed ]] \nbr /\n/span\n\n\n\n\nSet an Icon for your model\n\n\nYou'll notice that your new column is the only one without an icon - we set the icon by\nadding the following property to your \nTODOItem\n class:\n\n\n    _icon = 'fa fa-th-list'\n\n\n\nSome other batteries included\n\n\nLet's take a look at some of the other core functionality that we now have out of the box:\n\n\nSearch\n\n\nBy default, we also enable the search module, which allows you to search by patient name\nor unique identifier:\n\n\n\n\nDetail views\n\n\nWe also have a detail view for our patients, which you can access via search results. This\nview will typically allow for a more detailed display and editing of all the events\ncomprising an activity of care than is available on the list page.\n\n\n\n\nJSON APIs\n\n\nOPAL automatically creates self-documenting JSON APIs for your interacting with the data\nin your application. You can inspect these APIs interactively at the url:\n\n\nhttp://localhost:8000/api/v0.1/\n\n\n\n\n\nWhat next?\n\n\nThis is just a glimpse at the full range of functionality that comes with OPAL - there is\nmuch more to discover in the \nTopic Guides\n.", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/#writing-a-clinical-service-with-opal", 
            "text": "This tutorial will walk you through the creation of a new OPAL service.  The application we're going to be building will help clinical users to manage the patients on a ward in a hospital.  \nAs a Doctor  \nI want to know what's going on with the patients under my care \nSo that I can treat them effectively and safely.  Bootstrapping a new project  We assume that you've already  Installed OPAL . You can tell which version of opal is installed\nby running this command  $ opal --version  At the start a new project, OPAL will bootstrap the initial project structure, including\na Djano project, some core datamodels (complete with JSON APIs) and a general application structure.  From the commandline:  $ opal startproject mynewapp  This will create a mynewap directory where your new project lives.  Let's have a look at what that created for you:  mynewapp/                   # Your project directory\n    LICENSE                 # A dummy LICENSE file\n    Procfile                # A procfile ready for deployment to e.g. Heroku\n    README.md\n    manage.py               # Django's manage.py script\n    requirements.txt        # Requirements file ready for your project\n\n    data/                   # A dummy directory for fixtures\n\n    mynewapp/               # The actual python package for your application\n         __init__.py\n        flow.py             # How patients move through your services\n        models.py           # Data models for your application\n        schema.py           # The list schemas for your application\n        settings.py         # Helpfully tweaked Django settings\n        tests.py            # Dummy unittests\n        urls.py             # Django Urlconf\n        wsgi.py\n\n        assets/             # Your static files directory\n        templates/          # Your template directory\n        migrations/         # Your Database migrations directory\n\n        opal.sqlite         # The Sqlite development database  Test it out  The scaffolding step has generated you a working project - so let's check that out  cd mynewapp\npython manage.py runserver  If you now visit  http://localhost:8000  in your browser, you should see the standard login screen:   The scaffolding step created you a superuser, so try logging in with the credentials:   Username:  super  Password:   super1   When you log in you should be presented with a welcome screen that shows you the three\nareas that are enabled by default - team lists, search and the admin area.   OPAL applications are a collection of single page Angular apps that talk to the Django\nserver-side layer via JSON APIs. The Team Lists and Search options here are two examples of\nfront-end Angular single page apps.  Team lists  Most clinical services will need at some stage to generate a list of patients - so OPAL provides\nthis functionality enabled by default.  The  list view  is a spreadhseet-style list of patients - try navigating\nto the list view and adding a patient with the  add patient  button.   Each column contains a different type of information about a patient, while each\nrow represents one patient.  \nStrictly speaking each row is an  episode \nof care for a patient - but we'll come to that in a second.  The columns you see initially are just a few of the standard clinical models that come with\nOPAL - for instance the Diagnosis model in your new application inherits from a model that\nlooks a lot like this:  class Diagnosis(EpisodeSubrecord):\n    condition         = ForeignKeyOrFreeText(Condition)\n    provisional       = models.BooleanField(default=False)\n    details           = models.CharField(max_length=255, blank=True)\n    date_of_diagnosis = models.DateField(blank=True, null=True)\n\n    class Meta:\n        abstract = True  Lookup Lists  You will notice that the condition field has a custom field type -  ForeignKeyOrFreeText .\nThis is a custom field type that we use with OPAL when we want to use a Lookup List .  Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while\nalso allowing synonymous terms, and a free text override. That means that we can ensure that\nwe record high quality coded data, while allowing users an easy way to enter unusual edge\ncases.  You'll need to import the data for a terminology before you can start to take advantage of that.\nFor now, let's use the reference data from elCID (An OPAL application maintained by Open Health Care):  wget https://raw.githubusercontent.com/openhealthcare/elcid/master/data/lookuplists/lookuplists.json -P data/lookuplists  \nBy convention, we store data in the  ./data/lookuplists  directory of our project.  Now let's import the data:  python manage.py load_lookup_lists -f data/lookuplists/lookuplists.json  Now refresh your application and try adding a new diagnosis to your patient. As you start to type in\nthe condition field, you'l see that the conditions we just imported appear as suggestions:   Add your own data models  So far we've begun to get a sense of the batteries-included parts of OPAL,\nbut before long, you're going to need to create models for your own needs.  Most OPAL models are  Subrecords  - they relate to either a patient, or\nan episode (an episode is for example, an admission to hospital).  Let's see how that works by creating a TODO list model that is assigned to\nepisodes of care. In your  mynewapp/models.py  :  class TODOItem(models.EpisodeSubrecord):\n    job       = fields.CharField(max_length=200)\n    due_date  = fields.DateField(blank=True, null=True)\n    details   = fields.TextField(blank=True, null=True)\n    completed = fields.BooleanField(default=False)  This is simply a Django model, apart from the parent class  models.EpisodeSubrecord \nwhich provides us with some extra functionality:   A relationship to an episode, linked to a patient  JSON APIs for creating, retrieving and updating it  Ensuring that the OPAL Angular layer knows it exists   Next, we're going to let OPAL take care of the boilerplate that we'll need to use this\nmodel in our application. From the commandline:  $ opal scaffold mynewapp  Let's take a look at what that did:   It created a Django migration  It created a detail template  mynewapp/templates/records/todo_item.html  It created a form template  mynewapp/templates/modals/todo_item_modal.html   Detail template  The default detail template simply displays each field on a new line:  span ng-show=\"item.job\" [[ item.job ]]  br / /span  span ng-show=\"item.due_date\" [[ item.due_date  | shortDate ]]  br / /span  span ng-show=\"item.details\" [[ item.details ]]  br / /span  span ng-show=\"item.completed\" [[ item.completed ]]  br / /span   Form template  The default form template will display each field on a new line, with some basic\nappropriate form field types set.\nIt uses the OPAL form helpers templatetag library.  {% extends 'modal_base.html' %}\n{% load forms %}\n{% block modal_body %}\n   form class=\"form-horizontal\" \n   {% input  label=\"Job\" model=\"editing.job\"  %}\n   {% datepicker  label=\"Due Date\" model=\"editing.due_date\"  %}\n   {% textarea  label=\"Details\" model=\"editing.details\"  %}\n   {% checkbox  label=\"Completed\" model=\"editing.completed\"  %}\n   /form \n{% endblock %}  Adding TODOs to our Team Lists  Now let's add our TODO list model as a column in the Spreadsheet-like list view.  The columns for team lists are set in  mynewapp/schema.py  as a list of models.  Open mynewapp/schemas.py and edit the  list_columns  variable to add  models.TODOItem  as\nthe final item:  list_columns = [\n    models.Demographics,\n    models.Location,\n    models.Allergies,\n    models.Diagnosis,\n    models.PastMedicalHistory,\n    models.Treatment,\n    models.Investigation,\n    models.TODOItem\n]  Refresh the lists page in your browser, and you'll see your new column on the end - add a\nTODO item, noting how we automatically get appropriate form types like datepickers and\ncheckboxes.  You can edit any entry in the list view by double clicking on it.  Tweaking the default scaffolding  The scaffolding templates are only really supposed to get you started - you'll often\nneed to tweak the templates they generate with whatever logic makes sense for your\napplication.  For us, you'll notice that the value of  TODOItem.completed  simply displays as false -\nwhich is not particularly useful. So let's update that using the OPAL Boxed filter . In  mynewapp/templates/records/todo_item.html \nchange the last line to look like this:  span ng-show=\"item.completed\" [[ item.completed | boxed ]]  br / /span   Set an Icon for your model  You'll notice that your new column is the only one without an icon - we set the icon by\nadding the following property to your  TODOItem  class:      _icon = 'fa fa-th-list'  Some other batteries included  Let's take a look at some of the other core functionality that we now have out of the box:  Search  By default, we also enable the search module, which allows you to search by patient name\nor unique identifier:   Detail views  We also have a detail view for our patients, which you can access via search results. This\nview will typically allow for a more detailed display and editing of all the events\ncomprising an activity of care than is available on the list page.   JSON APIs  OPAL automatically creates self-documenting JSON APIs for your interacting with the data\nin your application. You can inspect these APIs interactively at the url:  http://localhost:8000/api/v0.1/   What next?  This is just a glimpse at the full range of functionality that comes with OPAL - there is\nmuch more to discover in the  Topic Guides .", 
            "title": "Writing a clinical service with OPAL"
        }, 
        {
            "location": "/guides/topic-guides/", 
            "text": "OPAL Guides\n\n\nA list of all available topic guides.\n\n\nOPAL\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOPAL - Applications, Plugins\n\n\nHow OPAL components hang together.\n\n\n\n\n\n\nCommand line tool\n\n\nrunning admin tasks from the command line\n\n\n\n\n\n\nDiscoverable\n\n\ndesign patterns and library for creating easily reusable features\n\n\n\n\n\n\nPlugins\n\n\nAvailable interfaces for OPAL plugins\n\n\n\n\n\n\nList of Plugins\n\n\nA list of available high quality plugins\n\n\n\n\n\n\n\n\nData and Business Logic\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Model\n\n\nHow OPAL models clinical reality.\n\n\n\n\n\n\nCore Clinical Model\n\n\nThe core clinical data model available to OPAL applications.\n\n\n\n\n\n\nFlow\n\n\nHooks to customise key moments in a patient's flow through a clinical service.\n\n\n\n\n\n\nAngular models\n\n\nWorking with Clinical data in Angular\n\n\n\n\n\n\nRoles \n Permissions\n\n\nHow we handle authorization in OPAL\n\n\n\n\n\n\nTagging\n\n\nTagging episodes in OPAL\n\n\n\n\n\n\nJSON API\n\n\nThe OPAL JSON API\n\n\n\n\n\n\nLookup Lists\n\n\nCanonical coded terms and ontologies\n\n\n\n\n\n\n\n\nPresentation and templating\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTemplates\n\n\nServer and client side templating\n\n\n\n\n\n\nDefault Context Processors\n\n\nOPAL Django context processors\n\n\n\n\n\n\nStatic Files\n\n\nHow OPAL handles static files\n\n\n\n\n\n\nForms\n\n\nForms for entering or editing data\n\n\n\n\n\n\nPatient Detail Views\n\n\nDetailed views of a Patient\n\n\n\n\n\n\nPatient List Views\n\n\nLists of patients\n\n\n\n\n\n\n\n\nOptional Components\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSearch\n\n\nDefault search implementation", 
            "title": "Guides"
        }, 
        {
            "location": "/guides/topic-guides/#opal-guides", 
            "text": "A list of all available topic guides.  OPAL           OPAL - Applications, Plugins  How OPAL components hang together.    Command line tool  running admin tasks from the command line    Discoverable  design patterns and library for creating easily reusable features    Plugins  Available interfaces for OPAL plugins    List of Plugins  A list of available high quality plugins     Data and Business Logic           Data Model  How OPAL models clinical reality.    Core Clinical Model  The core clinical data model available to OPAL applications.    Flow  Hooks to customise key moments in a patient's flow through a clinical service.    Angular models  Working with Clinical data in Angular    Roles   Permissions  How we handle authorization in OPAL    Tagging  Tagging episodes in OPAL    JSON API  The OPAL JSON API    Lookup Lists  Canonical coded terms and ontologies     Presentation and templating           Templates  Server and client side templating    Default Context Processors  OPAL Django context processors    Static Files  How OPAL handles static files    Forms  Forms for entering or editing data    Patient Detail Views  Detailed views of a Patient    Patient List Views  Lists of patients     Optional Components           Search  Default search implementation", 
            "title": "OPAL Guides"
        }, 
        {
            "location": "/reference/reference_guides/", 
            "text": "OPAL Reference material\n\n\nThe following reference guides are available:\n\n\nModels\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nopal.models.Episode model\n\n\nThe central Episode model\n\n\n\n\n\n\nopal.models.Patient\n\n\nThe Patient model\n\n\n\n\n\n\nopal.models.Subrecord base class\n\n\nBase class for subrecords of Episodes or Patients\n\n\n\n\n\n\n\n\nOPAL Core\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nopal.core.application\n\n\nOPAL Application objects\n\n\n\n\n\n\nopal.core.detail\n\n\nDetail Views - Custom views over one or many episodes.\n\n\n\n\n\n\nopal.core.episodes\n\n\nEpisode Categories - Controlling the behaviour of different types of episode.\n\n\n\n\n\n\nopal.core.schemas\n\n\nSchemas - Dynamic columns for the table views\n\n\n\n\n\n\nopal.core.patient_lists\n\n\nPatient Lists - defining different types of list.\n\n\n\n\n\n\n\n\nAngular Services\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEpisode\n\n\nEpisode objects\n\n\n\n\n\n\nItem\n\n\nSubrecord objects\n\n\n\n\n\n\nPatientSummary\n\n\nPatient search result summaries\n\n\n\n\n\n\nSearch Services\n\n\nServices from the Search module\n\n\n\n\n\n\n\n\nHelper libraries\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe forms Templatetag library\n\n\nThe building blocks for OPAL forms\n\n\n\n\n\n\nThe panels Templatetag library\n\n\nRendering record panels.\n\n\n\n\n\n\nJavascript Helpers\n\n\nAngular filters and $rootScope methods\n\n\n\n\n\n\n\n\nOPAL Search module\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMaking Search Queries\n\n\nSearch query backends and helper functions\n\n\n\n\n\n\n\n\nMiscenlaneous documentation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChangelog\n\n\nOPAL Changelog\n\n\n\n\n\n\nUpgrading\n\n\nUpgrading between OPAL versions\n\n\n\n\n\n\nJavascript dependencies\n\n\nExternal javascript libraries available", 
            "title": "Reference"
        }, 
        {
            "location": "/reference/reference_guides/#opal-reference-material", 
            "text": "The following reference guides are available:  Models           opal.models.Episode model  The central Episode model    opal.models.Patient  The Patient model    opal.models.Subrecord base class  Base class for subrecords of Episodes or Patients     OPAL Core           opal.core.application  OPAL Application objects    opal.core.detail  Detail Views - Custom views over one or many episodes.    opal.core.episodes  Episode Categories - Controlling the behaviour of different types of episode.    opal.core.schemas  Schemas - Dynamic columns for the table views    opal.core.patient_lists  Patient Lists - defining different types of list.     Angular Services           Episode  Episode objects    Item  Subrecord objects    PatientSummary  Patient search result summaries    Search Services  Services from the Search module     Helper libraries           The forms Templatetag library  The building blocks for OPAL forms    The panels Templatetag library  Rendering record panels.    Javascript Helpers  Angular filters and $rootScope methods     OPAL Search module           Making Search Queries  Search query backends and helper functions     Miscenlaneous documentation           Changelog  OPAL Changelog    Upgrading  Upgrading between OPAL versions    Javascript dependencies  External javascript libraries available", 
            "title": "OPAL Reference material"
        }, 
        {
            "location": "/guides/components_overview/", 
            "text": "Components of an OPAL application\n\n\nOPAL applications will typically be made up of several types of components.\n\n\n\n\nOPAL\n\n\nThe core OPAL framework provides you with a range of commonly required elements\nof clinical applications.\n\n\nIt contains a core \ndata model\n for persisting clinical information,\nas well core clinical archetypes out of the box that build on many\nyears of collaboratively modelling clinical concepts by medical domain experts.\n\n\nOPAL also makes it easy to integrate standard clinical \nreference data\n\ninto your application - things like medical diagnoses, tests, drugs et cetera.\n\n\nSome common functional components end up in to most clinical applications, and many\nof these come with OPAL as \"batteries included\" - immediately available modular features\nthat can be simply re-used without having to reinvent the wheel.\n\n\nFor example:\n\n\n\n\nPatient lists\n\n\nSearch\n\n\nAuthentication and \nPermissions\n\n\nForms for data entry\n\n\nJSON based REST APIs\n for all of your models\n\n\n... and \nmany more\n...\n\n\n\n\nPlugins\n\n\nOPAL plugins are intended to provide high quality generic, composable, re-usable chunks of\nfunctionality that can be \"dropped in\" to an application. For example, installing the\n\nDashboards\n plugin allows you to easily\ncreate clinical dashboards within your application. The\n\nReferral\n plugin provides the plumbing for\nbuilding complex inter-team referrals within an institution.\n\n\nPlugins have a \nrich plugin API\n they can hook into to, and\nmany examples can be found by inspecting the source of \nexisting plugins\n.\n\n\nApplications\n\n\nAn application is the collection of configuration and bespoke functionality that would be\nprovided to an individual institution - it's the thing that you would look to deploy.\n\n\nExample applications include \nelCID\n - a for managing\ninfection patients, or \nOPAL-Renal\n - an MDT \n\nhandover tool for Renal wards.\n\n\nA hospital might have multiple clinical services running on one application, or multiple\napplications that integrate with one another.\n\n\nOpinionated but Pluggable\n\n\nOPAL is an opinionated framework. It expects the developer to structure code in a\ncertain way.\n\n\nOPAL expects features to be implemented as single page Angular.js applications, with the server\nmostly figuring as an API endpoint for reading and writing data.\n\n\nThat said, the technology stack of Django, Angular \n Bootstrap allows the confident user a huge\ndegree of flexibility when writing their own applications and plugins.\n\n\nFor instance, there is nothing to \nstop\n a developer from implementing a part of the functionality\nin some other Javascript framework, and simply calling the \nJSON API\n. However, by\ndoing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera.\nWhile possible, this approach is not likely to be officially supported in the medium term.", 
            "title": "Component Overview"
        }, 
        {
            "location": "/guides/components_overview/#components-of-an-opal-application", 
            "text": "OPAL applications will typically be made up of several types of components.   OPAL  The core OPAL framework provides you with a range of commonly required elements\nof clinical applications.  It contains a core  data model  for persisting clinical information,\nas well core clinical archetypes out of the box that build on many\nyears of collaboratively modelling clinical concepts by medical domain experts.  OPAL also makes it easy to integrate standard clinical  reference data \ninto your application - things like medical diagnoses, tests, drugs et cetera.  Some common functional components end up in to most clinical applications, and many\nof these come with OPAL as \"batteries included\" - immediately available modular features\nthat can be simply re-used without having to reinvent the wheel.  For example:   Patient lists  Search  Authentication and  Permissions  Forms for data entry  JSON based REST APIs  for all of your models  ... and  many more ...   Plugins  OPAL plugins are intended to provide high quality generic, composable, re-usable chunks of\nfunctionality that can be \"dropped in\" to an application. For example, installing the Dashboards  plugin allows you to easily\ncreate clinical dashboards within your application. The Referral  plugin provides the plumbing for\nbuilding complex inter-team referrals within an institution.  Plugins have a  rich plugin API  they can hook into to, and\nmany examples can be found by inspecting the source of  existing plugins .  Applications  An application is the collection of configuration and bespoke functionality that would be\nprovided to an individual institution - it's the thing that you would look to deploy.  Example applications include  elCID  - a for managing\ninfection patients, or  OPAL-Renal  - an MDT  \nhandover tool for Renal wards.  A hospital might have multiple clinical services running on one application, or multiple\napplications that integrate with one another.  Opinionated but Pluggable  OPAL is an opinionated framework. It expects the developer to structure code in a\ncertain way.  OPAL expects features to be implemented as single page Angular.js applications, with the server\nmostly figuring as an API endpoint for reading and writing data.  That said, the technology stack of Django, Angular   Bootstrap allows the confident user a huge\ndegree of flexibility when writing their own applications and plugins.  For instance, there is nothing to  stop  a developer from implementing a part of the functionality\nin some other Javascript framework, and simply calling the  JSON API . However, by\ndoing so, the developer will lose a large collection of pre-existing libraries, conventions et cetera.\nWhile possible, this approach is not likely to be officially supported in the medium term.", 
            "title": "Components of an OPAL application"
        }, 
        {
            "location": "/guides/command_line_tool/", 
            "text": "The OPAL Command line tool\n\n\nOPAL ships with a helpful command line tool that helps with administrative tasks.\n\n\nThe \nopal\n script should be on your system path if you installed OPAL via setup.py or\npip. You can check whether it is available by running this command:\n\n\n$ opal -v\n\n\n\nstartproject \nname\n\n\nCreates a new OPAL project.\n\n\nThis creates boilerplate and a default configuration for your new project, including\ncreating a new underlying Django project, updating default settings to be compatible\nwith OPAL, creating directories and code boilerplate, and running initial migrations.\n\n\nstartplugin \nname\n\n\nCreates boilerplate code, and directory structures for a new OPAL plugin.\n\n\nscaffold \nappname\n\n\nUse with new record models.\n\n\nCreates and runs automatic migrations, creates display and form (modal) templates.\n\n\ntest \nwhat\n\n\nRun our tests suites.\n\n\nDefaults to running both Python and Javascript tests.\n\n\nIf specified, will only run one specific kind of test.\n\n\n$ opal test py\n   $ opal test js\n\n\nWhen running Python tests, the \n-t\n or \n--test\n option allows the user to specify a single\ntest module, case or method to run.\n\n\n$ opal test py -t opal.tests.test_models\n\n\ncheckout\n\n\nEnsure that all of our application plugins and packages are on the correct branch.\n\n\nThis is particularly useful when working on OPAL itself, or when you have multiple\nprojects that use different versions of OPAL or plugins. It will assume that github\nbased requirements will be installed in development via \npython setup.py develop\n.\n\n\nThis command will parse your project's \nrequirements.txt\n, and then ensure that any\nGithub sources are checked out loclaly to the branch specified therein.", 
            "title": "Command Line tool"
        }, 
        {
            "location": "/guides/command_line_tool/#the-opal-command-line-tool", 
            "text": "OPAL ships with a helpful command line tool that helps with administrative tasks.  The  opal  script should be on your system path if you installed OPAL via setup.py or\npip. You can check whether it is available by running this command:  $ opal -v  startproject  name  Creates a new OPAL project.  This creates boilerplate and a default configuration for your new project, including\ncreating a new underlying Django project, updating default settings to be compatible\nwith OPAL, creating directories and code boilerplate, and running initial migrations.  startplugin  name  Creates boilerplate code, and directory structures for a new OPAL plugin.  scaffold  appname  Use with new record models.  Creates and runs automatic migrations, creates display and form (modal) templates.  test  what  Run our tests suites.  Defaults to running both Python and Javascript tests.  If specified, will only run one specific kind of test.  $ opal test py\n   $ opal test js  When running Python tests, the  -t  or  --test  option allows the user to specify a single\ntest module, case or method to run.  $ opal test py -t opal.tests.test_models  checkout  Ensure that all of our application plugins and packages are on the correct branch.  This is particularly useful when working on OPAL itself, or when you have multiple\nprojects that use different versions of OPAL or plugins. It will assume that github\nbased requirements will be installed in development via  python setup.py develop .  This command will parse your project's  requirements.txt , and then ensure that any\nGithub sources are checked out loclaly to the branch specified therein.", 
            "title": "The OPAL Command line tool"
        }, 
        {
            "location": "/guides/plugins/", 
            "text": "Writing Plugins\n\n\nOPAL Plugins are Django apps on the server side, and collections of angular.js\nmodels for the client.\n\n\nGetting started with your plugin\n\n\nThe OPAL commandline tool will bootstrap your plugin for you - just run:\n\n\n$ opal startplugin yourcoolplugin\n\n\n\nAdding Discoverable Functionality\n\n\nA common pattern for plugins is to add functionality that other plugins or applications\ncan use by inheriting a base class that you define in a file with a magic name. (In\nmuch the same way that Django provides models.)\n\n\nFor example, if you're creating an appointments plugin that helps people to book and schedule\nappointments in clinics, you would create a base \nClinic\n class that can be subclassed to\ncreate specific clinics.\n\n\nclass Clinic(opal.core.discoverable.DiscoverableFeature):\n    module_name = 'clinics'\n\n\n\nWe can then create clinics in any installed app, and they will be available from \nClinic.list()\n\n\nclass OutpatientsClinic(Clinic):\n    name = 'Outpatients'\n\n    # Add your custom clnic functionality here e.g.\n    def book_appointment(self, date, patient):\n        pass\n\n\nClinic.list()\n# -\n Generator including OutPatientsClinic\n\nClinic.get('outpatients)\n# -\n OutpatientsClinic\n\n\n\nDefining new flows\n\n\nPlugins can define flows. They should return a dictionary of flows from the\nflows() method of the plugin class.\n\n\nAdding URLS\n\n\nAdd an urls.py, then add to your plugin class as YourPlugin.urls\n\n\nNaturally, these can point to views in your plugin!\n\n\nAdding Javascript\n\n\nadd to static, then add to your plugin class as YourPlugin.javascripts\n\n\nThere are some restricted namespaces for these...\n\n\nAdding APIs\n\n\nOPAL uses Django Rest Framweork to provide APIs, and you may add to these from your plugin.\nBy convention, APIs live in \nyourplugin/api.py\n. You are expected to provide a\n\nrest_framework.viewsets.ViewSet\n subclass, which you then detail as the \n.apis\n attribute\nof your plugin.\n\n\n# yourplugin/api.py\nfrom rest_framework.viewsets import ViewSet\nfrom rest_framework.response import Response\n\nclass PingViewSet(ViewSet):\n    def list(self, request): return Response('pong')\n\n# yourplugin/__init__.py\nfrom opal.core.plugins import OpalPlugin\nfrom yourplugin import api\n\nclass YourPlugin(OpalPlugin):\n    apis = [\n        ('ping', api.PingViewSet)\n    ]\n\n\n\nThese APIs will then be available and self-documenting fom the standard OPAL url \n/api/v0.1/\n\n\nAdding Actions to the sidebar\n\n\nActions can be added to the sidebar by setting the \nactions\n attribute of your plugin.\nActions is expected to be an iterable of strings which are templates to be included in\nthe sidebar. By convention, actions will live in \n./templates/actions/\n .\n\n\n# __init__.py:\nclass Plugin(OpalPlugin):\n    actions = ('actions/javascript_alert.html', 'actions/dummy_button.html')\n\n\n\nAnd then in the template:\n\n\np ng-show=\"episode.category == 'YourEpisodeCategory'\"\n\n  \nbutton class=\"btn btn-primary\" ng-click=\"alert('Boom!')\"\n\n    \ni href=\"fa fa-warning\"\n/i\n\n    ALERT ME\n  \n/button\n\n\n/p\n\n\n\n\nAdding dependencies globally to our angular modules\n\n\nDependencies listed in \nangular_module_deps\n will be added to all Angular modules (as long as they\nuse the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we\nwon't for now.\n\n\nInstalling plugins\n\n\nAdd to installed apps\nAdd to requirements if appropriate\n\n\nAdding extra markup to the \n tag\n\n\nAny templates you define in the property .head_extra will be included in the", 
            "title": "Plugins"
        }, 
        {
            "location": "/guides/plugins/#writing-plugins", 
            "text": "OPAL Plugins are Django apps on the server side, and collections of angular.js\nmodels for the client.  Getting started with your plugin  The OPAL commandline tool will bootstrap your plugin for you - just run:  $ opal startplugin yourcoolplugin  Adding Discoverable Functionality  A common pattern for plugins is to add functionality that other plugins or applications\ncan use by inheriting a base class that you define in a file with a magic name. (In\nmuch the same way that Django provides models.)  For example, if you're creating an appointments plugin that helps people to book and schedule\nappointments in clinics, you would create a base  Clinic  class that can be subclassed to\ncreate specific clinics.  class Clinic(opal.core.discoverable.DiscoverableFeature):\n    module_name = 'clinics'  We can then create clinics in any installed app, and they will be available from  Clinic.list()  class OutpatientsClinic(Clinic):\n    name = 'Outpatients'\n\n    # Add your custom clnic functionality here e.g.\n    def book_appointment(self, date, patient):\n        pass\n\n\nClinic.list()\n# -  Generator including OutPatientsClinic\n\nClinic.get('outpatients)\n# -  OutpatientsClinic  Defining new flows  Plugins can define flows. They should return a dictionary of flows from the\nflows() method of the plugin class.  Adding URLS  Add an urls.py, then add to your plugin class as YourPlugin.urls  Naturally, these can point to views in your plugin!  Adding Javascript  add to static, then add to your plugin class as YourPlugin.javascripts  There are some restricted namespaces for these...  Adding APIs  OPAL uses Django Rest Framweork to provide APIs, and you may add to these from your plugin.\nBy convention, APIs live in  yourplugin/api.py . You are expected to provide a rest_framework.viewsets.ViewSet  subclass, which you then detail as the  .apis  attribute\nof your plugin.  # yourplugin/api.py\nfrom rest_framework.viewsets import ViewSet\nfrom rest_framework.response import Response\n\nclass PingViewSet(ViewSet):\n    def list(self, request): return Response('pong')\n\n# yourplugin/__init__.py\nfrom opal.core.plugins import OpalPlugin\nfrom yourplugin import api\n\nclass YourPlugin(OpalPlugin):\n    apis = [\n        ('ping', api.PingViewSet)\n    ]  These APIs will then be available and self-documenting fom the standard OPAL url  /api/v0.1/  Adding Actions to the sidebar  Actions can be added to the sidebar by setting the  actions  attribute of your plugin.\nActions is expected to be an iterable of strings which are templates to be included in\nthe sidebar. By convention, actions will live in  ./templates/actions/  .  # __init__.py:\nclass Plugin(OpalPlugin):\n    actions = ('actions/javascript_alert.html', 'actions/dummy_button.html')  And then in the template:  p ng-show=\"episode.category == 'YourEpisodeCategory'\" \n   button class=\"btn btn-primary\" ng-click=\"alert('Boom!')\" \n     i href=\"fa fa-warning\" /i \n    ALERT ME\n   /button  /p   Adding dependencies globally to our angular modules  Dependencies listed in  angular_module_deps  will be added to all Angular modules (as long as they\nuse the OPAL.module() API. If not, you're on your own. We could monkey patch angular.module, but we\nwon't for now.  Installing plugins  Add to installed apps\nAdd to requirements if appropriate  Adding extra markup to the   tag  Any templates you define in the property .head_extra will be included in the", 
            "title": "Writing Plugins"
        }, 
        {
            "location": "/guides/plugins_list/", 
            "text": "OPAL Plugins list\n\n\nThe OPAL ecosystem has a rich array of re-usable Open Source plugins that can be used as composable\nunits of functionality to build your application. This page lists some of the best available:\n\n\nopal.core.search\n\n\nThe Search plugin bundled with OPAL core provides a default database based search implementation \nfor your application, and is scheduled to provide hooks for e.g. using Elastic Search as your \nserach backend.\n\n\nopal.core.collaborative\n\n\nThe Collaborative plugin bundled with OPAL core provides a mechanism for providing realtime\ncollaborative editing of patient data within lists, by providing a streaming websocket link\nof updates from other open sessions. (Requires \nGlossolalia\n ).\n\n\nopal-opat\n\n\nThe \nOPAT\n plugin provides a set of teams, flows\nand record types for running a BSAC OPAT clinic.\n\n\nopal-research\n\n\nThe \nResearch\n plugin allows an OPAL application to be used as the\ndata collection method for multiple concurrent research studies, including researcher blinding, a \nstructured role \n permission framework.\n\n\nopal-walk-in\n\n\nThe \nWalk In\n plugin supports the operation of \ndrop in services within your institution, including registration, triage, escalation \n \ndischarge summaries.\n\n\nopal-wardround\n\n\nThe \nWardround\n plugin provides structured virtual\nward rounds - sequential subsets of patients matching arbitrary criteria that the user may step \nthrough in order.\n\n\nopal-dischargesummary\n\n\nThe \nDischarge Summary\n plugin allows the\nuser to generate templated letters from the data concerning an episode already held in the Application.\n\n\nopal-referral\n\n\nThe \nReferral\n plugin provides the plumbing for \nbuilding complex inter-team referrals within an institution.\n\n\nopal-dashboard\n\n\nThe \nDashboard\n plugin allows for realtime clinical \ndashboards featuring arbitrary metrics, displayed within your application.\n\n\nopal-observations\n\n\nThe \nObservations\n plugin caters for the recording and\ndisplay of electronic observations data.\n\n\nopal-analytics\n\n\nThe \nAnalytics\n plugin allows you to integrate\nyour application with Google or Piwik Analytics with a minimum of fuss.\n\n\nopal-guidelines\n\n\nThe \nGuidelines\n plugin presents contextual links to clinical\nguidelines in use at your institution when viewing records of patients whose condition matches those guidelines.\n\n\nCan be used with national or local guidelines.\n\n\nopal-iframe-api\n\n\nThe \nIframe Api\n plugin allows you to set up an api key. \nWith this Api key you can create templates to view subrecords for embedding in for example iframes.", 
            "title": "Plugin List"
        }, 
        {
            "location": "/guides/plugins_list/#opal-plugins-list", 
            "text": "The OPAL ecosystem has a rich array of re-usable Open Source plugins that can be used as composable\nunits of functionality to build your application. This page lists some of the best available:  opal.core.search  The Search plugin bundled with OPAL core provides a default database based search implementation \nfor your application, and is scheduled to provide hooks for e.g. using Elastic Search as your \nserach backend.  opal.core.collaborative  The Collaborative plugin bundled with OPAL core provides a mechanism for providing realtime\ncollaborative editing of patient data within lists, by providing a streaming websocket link\nof updates from other open sessions. (Requires  Glossolalia  ).  opal-opat  The  OPAT  plugin provides a set of teams, flows\nand record types for running a BSAC OPAT clinic.  opal-research  The  Research  plugin allows an OPAL application to be used as the\ndata collection method for multiple concurrent research studies, including researcher blinding, a \nstructured role   permission framework.  opal-walk-in  The  Walk In  plugin supports the operation of \ndrop in services within your institution, including registration, triage, escalation   \ndischarge summaries.  opal-wardround  The  Wardround  plugin provides structured virtual\nward rounds - sequential subsets of patients matching arbitrary criteria that the user may step \nthrough in order.  opal-dischargesummary  The  Discharge Summary  plugin allows the\nuser to generate templated letters from the data concerning an episode already held in the Application.  opal-referral  The  Referral  plugin provides the plumbing for \nbuilding complex inter-team referrals within an institution.  opal-dashboard  The  Dashboard  plugin allows for realtime clinical \ndashboards featuring arbitrary metrics, displayed within your application.  opal-observations  The  Observations  plugin caters for the recording and\ndisplay of electronic observations data.  opal-analytics  The  Analytics  plugin allows you to integrate\nyour application with Google or Piwik Analytics with a minimum of fuss.  opal-guidelines  The  Guidelines  plugin presents contextual links to clinical\nguidelines in use at your institution when viewing records of patients whose condition matches those guidelines.  Can be used with national or local guidelines.  opal-iframe-api  The  Iframe Api  plugin allows you to set up an api key. \nWith this Api key you can create templates to view subrecords for embedding in for example iframes.", 
            "title": "OPAL Plugins list"
        }, 
        {
            "location": "/guides/datamodel/", 
            "text": "The OPAL Data model\n\n\nThe OPAL data model allows for patients to have multiple sequential or concurrent\n\nEpisodes of care\n. Some information is linked to an \nEpisode\n, some is linked to\na \nPatient\n.\n\n\n\n\nPatients\n\n\nA \nPatient\n may have many \nEpisodes\n. An \nEpisode\n is something like an Inpatient admission,\na telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic.\nApplications or plugins may define their own \nEpisode\n categories, and a common pattern is to\nalter the display or available functionality by episode type. (e.g. You may associate\ntemplates for discharge summaries with particular episode types)\n\n\nA \nPatient\n will have \nSubrecords\n (such as e.g. Demographics) which follow them across multiple\nepisodes. These are information linked to a particular person, and should be implemented as\nDjango models that inherit from the \nopal.models.PatientSubrecord\n base class.\n\n\nEpisodes\n\n\nAn \nEpisode\n is linked to a \nPatient\n, and will contain some metadata about the type and date\nof the episode. The field \nEpisode.category_name\n stores a string representing the relevant\n\nEpisodeCategory\n e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned\nfrom the \nepisode.category\n field. The start and end dates of an \nEpisode\n may be retrieved\nfrom the \nstart\n and \nend\n properties.\n\n\nAn \nEpisode\n will have \nSubrecords\n (such as e.g. Diagnosis) which are linked to this episode of\ncare. These should be implemented as Django models that inherit from the \nopal.models.EpisodeSubRecord\n\nbase class.\n\n\nRecords\n\n\nA \nSubrecord\n consists of a collection of fields that constitute a record. For example, one could\nimplement a Demograpics \nSubrecord\n as follows:\n\n\nclass Demographics(PatientSubrecord):\n    name             = models.CharField(max_length=255, blank=True)\n    hospital_number  = models.CharField(max_length=255, blank=True)\n    date_of_birth    = models.DateField(null=True, blank=True)\n    ethnicity        = models.CharField(max_length=255, blank=True,\n                                        null=True)\n    gender           = models.CharField(max_length=255, blank=True,\n                                        null=True)\n\n\n\nSubrecords also define various properties that will provide metadata about their\ndisplay or structure, which are documented in the\n\nSubrecord reference material\n\n\nCore Clinical Data Model\n\n\nOPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the \n$ opal startproject\n command will automatically\ncontain concrete implementations of these models in the application.\n\n\nFull documentation of these models is available in the \nArchetypes\n documentation.\n\n\nReference Data\n\n\nOPAL comes with a set of clinical terminology data models out of the box. - we often\nwant to link our records to one of these - for example to record a type of condition\na patient might have, or a drug they are taking.\n\n\nFull documentation of these is available in the \nLookup lists\n documentation.", 
            "title": "Data Model"
        }, 
        {
            "location": "/guides/datamodel/#the-opal-data-model", 
            "text": "The OPAL data model allows for patients to have multiple sequential or concurrent Episodes of care . Some information is linked to an  Episode , some is linked to\na  Patient .   Patients  A  Patient  may have many  Episodes . An  Episode  is something like an Inpatient admission,\na telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic.\nApplications or plugins may define their own  Episode  categories, and a common pattern is to\nalter the display or available functionality by episode type. (e.g. You may associate\ntemplates for discharge summaries with particular episode types)  A  Patient  will have  Subrecords  (such as e.g. Demographics) which follow them across multiple\nepisodes. These are information linked to a particular person, and should be implemented as\nDjango models that inherit from the  opal.models.PatientSubrecord  base class.  Episodes  An  Episode  is linked to a  Patient , and will contain some metadata about the type and date\nof the episode. The field  Episode.category_name  stores a string representing the relevant EpisodeCategory  e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned\nfrom the  episode.category  field. The start and end dates of an  Episode  may be retrieved\nfrom the  start  and  end  properties.  An  Episode  will have  Subrecords  (such as e.g. Diagnosis) which are linked to this episode of\ncare. These should be implemented as Django models that inherit from the  opal.models.EpisodeSubRecord \nbase class.  Records  A  Subrecord  consists of a collection of fields that constitute a record. For example, one could\nimplement a Demograpics  Subrecord  as follows:  class Demographics(PatientSubrecord):\n    name             = models.CharField(max_length=255, blank=True)\n    hospital_number  = models.CharField(max_length=255, blank=True)\n    date_of_birth    = models.DateField(null=True, blank=True)\n    ethnicity        = models.CharField(max_length=255, blank=True,\n                                        null=True)\n    gender           = models.CharField(max_length=255, blank=True,\n                                        null=True)  Subrecords also define various properties that will provide metadata about their\ndisplay or structure, which are documented in the Subrecord reference material  Core Clinical Data Model  OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the  $ opal startproject  command will automatically\ncontain concrete implementations of these models in the application.  Full documentation of these models is available in the  Archetypes  documentation.  Reference Data  OPAL comes with a set of clinical terminology data models out of the box. - we often\nwant to link our records to one of these - for example to record a type of condition\na patient might have, or a drug they are taking.  Full documentation of these is available in the  Lookup lists  documentation.", 
            "title": "The OPAL Data model"
        }, 
        {
            "location": "/guides/archetypes/", 
            "text": "Core Clinical Archetypes\n\n\nOPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the \n$ opal startproject\n command will automatically\ncontain concrete implementations of these models in the application.\n\n\nCommon Metadata fields\n\n\nAll subrecords will contain the following fields, which are not repreated individually\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncreated_by\n\n\nFK\n\n\nUser ID\n\n\n\n\n\n\ncreated\n\n\nDate\n\n\n\n\n\n\n\n\nupdated_by\n\n\nFK User ID\n\n\n\n\n\n\n\n\nupdate\n\n\nDate\n\n\n\n\n\n\n\n\n\n\nThe details of each individual archetype are set out below:\n\n\nPatient Subrecords\n\n\nDemographics\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\nhospital_number\n\n\nChar\n\n\n255\n\n\n\n\n\n\nnhs_number\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndate_of_birth\n\n\nDate\n\n\n\n\n\n\n\n\nplace_of_birth\n\n\nFKorFT(Destination)\n\n\n\n\n\n\n\n\nethnicity\n\n\nFKorFT(Ethnicity)\n\n\n\n\n\n\n\n\nsurname\n\n\nChar\n\n\n255\n\n\n\n\n\n\nfirst_name\n\n\nChar\n\n\n255\n\n\n\n\n\n\nmiddle_name\n\n\nChar\n\n\n255\n\n\n\n\n\n\nsex\n\n\nFKorFT(Gender)\n\n\n\n\n\n\n\n\n\n\nAllergies\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ndrug\n\n\nFKorFT(Drug)\n\n\n\n\n\n\n\n\nprovisional\n\n\nBoolean\n\n\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\n\n\nEpisode Subrecords\n\n\nLocation\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncategory\n\n\nChar\n\n\n255\n\n\n\n\n\n\nhospital\n\n\nChar\n\n\n255\n\n\n\n\n\n\nward\n\n\nChar\n\n\n255\n\n\n\n\n\n\nbed\n\n\nChar\n\n\n255\n\n\n\n\n\n\n\n\nTreatment\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ndrug\n\n\nFKorFT(Drug)\n\n\n\n\n\n\n\n\ndose\n\n\nChar\n\n\n255\n\n\n\n\n\n\nroute\n\n\nFKorFT(Drugroute)\n\n\n\n\n\n\n\n\nstart_date\n\n\nDate\n\n\n\n\n\n\n\n\nend_date\n\n\nDate\n\n\n\n\n\n\n\n\nfrequency\n\n\nFKorFT(Drugfreq)\n\n\n\n\n\n\n\n\n\n\nDiagnosis\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\nFKorFT(Condition)\n\n\n\n\n\n\n\n\nprovisional\n\n\nBoolean\n\n\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndate_of_diagnosis\n\n\nDate\n\n\n\n\n\n\n\n\n\n\nPastMedicalHistory\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\nFKorFT(Condition)\n\n\n\n\n\n\n\n\nyear\n\n\nChar\n\n\n4\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\n\n\nSymptomComplex\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\nsymptoms\n\n\nManyToMany(Symptom)\n\n\n\n\n\n\n\n\nduration\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndetails\n\n\nText\n\n\n\n\n\n\n\n\n\n\nReferralRoute\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ninternal\n\n\nNullBoolean\n\n\n\n\n\n\n\n\nreferral_route\n\n\nFKorFT(ReferralOrganisation)\n\n\n\n\n\n\n\n\nreferral_name\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndate_of_referral\n\n\nDate\n\n\n\n\n\n\n\n\nreferral_team\n\n\nFKorFT(Speciality)\n\n\n\n\n\n\n\n\nreferral_reason\n\n\nFKorFT(ReferralReason)\n\n\n\n\n\n\n\n\n\n\nPatientConsultation\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\nwhen\n\n\nDatetime\n\n\n\n\n\n\n\n\ninitials\n\n\nChar\n\n\n255\n\n\n\n\n\n\nreason_for_interaction\n\n\nFKorFT(Patient_consultation_reason_for_interaction)\n\n\n\n\n\n\n\n\ndiscussion\n\n\nText\n\n\n\n\n\n\n\n\n\n\nInvestigation\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ntest\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndate_ordered\n\n\nDate\n\n\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\nmicroscopy\n\n\nChar\n\n\n255\n\n\n\n\n\n\norganism\n\n\nChar\n\n\n255\n\n\n\n\n\n\nsensitive_antibiotics\n\n\nChar\n\n\n255\n\n\n\n\n\n\nresistant_antibiotics\n\n\nChar\n\n\n255\n\n\n\n\n\n\nresult\n\n\nChar\n\n\n255\n\n\n\n\n\n\nigm\n\n\nChar\n\n\n20\n\n\n\n\n\n\nigg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nvca_igm\n\n\nChar\n\n\n20\n\n\n\n\n\n\nvca_igg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nebna_igg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhbsag\n\n\nChar\n\n\n20\n\n\n\n\n\n\nanti_hbs\n\n\nChar\n\n\n20\n\n\n\n\n\n\nanti_hbcore_igm\n\n\nChar\n\n\n20\n\n\n\n\n\n\nanti_hbcore_igg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nrpr\n\n\nChar\n\n\n20\n\n\n\n\n\n\ntppa\n\n\nChar\n\n\n20\n\n\n\n\n\n\nviral_load\n\n\nChar\n\n\n20\n\n\n\n\n\n\nparasitaemia\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhsv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nvzv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nsyphilis\n\n\nChar\n\n\n20\n\n\n\n\n\n\nc_difficile_antigen\n\n\nChar\n\n\n20\n\n\n\n\n\n\nc_difficile_toxin\n\n\nChar\n\n\n20\n\n\n\n\n\n\nspecies\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhsv_1\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhsv_2\n\n\nChar\n\n\n20\n\n\n\n\n\n\nenterovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\ncmv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nebv\n\n\nChar\n\n\n20\n\n\n\n\n\n\ninfluenza_a\n\n\nChar\n\n\n20\n\n\n\n\n\n\ninfluenza_b\n\n\nChar\n\n\n20\n\n\n\n\n\n\nparainfluenza\n\n\nChar\n\n\n20\n\n\n\n\n\n\nmetapneumovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\nrsv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nadenovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\nnorovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\nrotavirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\ngiardia\n\n\nChar\n\n\n20\n\n\n\n\n\n\nentamoeba_histolytica\n\n\nChar\n\n\n20\n\n\n\n\n\n\ncryptosporidium\n\n\nChar\n\n\n20", 
            "title": "Archetypes"
        }, 
        {
            "location": "/guides/archetypes/#core-clinical-archetypes", 
            "text": "OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the  $ opal startproject  command will automatically\ncontain concrete implementations of these models in the application.", 
            "title": "Core Clinical Archetypes"
        }, 
        {
            "location": "/guides/archetypes/#common-metadata-fields", 
            "text": "All subrecords will contain the following fields, which are not repreated individually     Field  Type  Length      created_by  FK  User ID    created  Date     updated_by  FK User ID     update  Date      The details of each individual archetype are set out below:", 
            "title": "Common Metadata fields"
        }, 
        {
            "location": "/guides/archetypes/#patient-subrecords", 
            "text": "Demographics     Field  Type  Length      hospital_number  Char  255    nhs_number  Char  255    date_of_birth  Date     place_of_birth  FKorFT(Destination)     ethnicity  FKorFT(Ethnicity)     surname  Char  255    first_name  Char  255    middle_name  Char  255    sex  FKorFT(Gender)      Allergies     Field  Type  Length      drug  FKorFT(Drug)     provisional  Boolean     details  Char  255", 
            "title": "Patient Subrecords"
        }, 
        {
<<<<<<< HEAD
            "location": "/guides/archetypes/#episode-subrecords", 
            "text": "Location     Field  Type  Length      category  Char  255    hospital  Char  255    ward  Char  255    bed  Char  255     Treatment     Field  Type  Length      drug  FKorFT(Drug)     dose  Char  255    route  FKorFT(Drugroute)     start_date  Date     end_date  Date     frequency  FKorFT(Drugfreq)      Diagnosis     Field  Type  Length      condition  FKorFT(Condition)     provisional  Boolean     details  Char  255    date_of_diagnosis  Date      PastMedicalHistory     Field  Type  Length      condition  FKorFT(Condition)     year  Char  4    details  Char  255     SymptomComplex     Field  Type  Length      symptoms  ManyToMany(Symptom)     duration  Char  255    details  Text      ReferralRoute     Field  Type  Length      internal  NullBoolean     referral_route  FKorFT(ReferralOrganisation)     referral_name  Char  255    date_of_referral  Date     referral_team  FKorFT(Speciality)     referral_reason  FKorFT(ReferralReason)      PatientConsultation     Field  Type  Length      when  Datetime     initials  Char  255    reason_for_interaction  FKorFT(Patient_consultation_reason_for_interaction)     discussion  Text      Investigation     Field  Type  Length      test  Char  255    date_ordered  Date     details  Char  255    microscopy  Char  255    organism  Char  255    sensitive_antibiotics  Char  255    resistant_antibiotics  Char  255    result  Char  255    igm  Char  20    igg  Char  20    vca_igm  Char  20    vca_igg  Char  20    ebna_igg  Char  20    hbsag  Char  20    anti_hbs  Char  20    anti_hbcore_igm  Char  20    anti_hbcore_igg  Char  20    rpr  Char  20    tppa  Char  20    viral_load  Char  20    parasitaemia  Char  20    hsv  Char  20    vzv  Char  20    syphilis  Char  20    c_difficile_antigen  Char  20    c_difficile_toxin  Char  20    species  Char  20    hsv_1  Char  20    hsv_2  Char  20    enterovirus  Char  20    cmv  Char  20    ebv  Char  20    influenza_a  Char  20    influenza_b  Char  20    parainfluenza  Char  20    metapneumovirus  Char  20    rsv  Char  20    adenovirus  Char  20    norovirus  Char  20    rotavirus  Char  20    giardia  Char  20    entamoeba_histolytica  Char  20    cryptosporidium  Char  20", 
            "title": "Episode Subrecords"
=======
            "location": "/guides/datamodel/", 
            "text": "The OPAL Data model\n\n\nThe OPAL data model allows for patients to have multiple sequential or concurrent\n\nEpisodes of care\n. Some information is linked to an \nEpisode\n, some is linked to\na \nPatient\n.\n\n\n\n\nPatients\n\n\nA \nPatient\n may have many \nEpisodes\n. An \nEpisode\n is something like an Inpatient admission,\na telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic.\nApplications or plugins may define their own \nEpisode\n categories, and a common pattern is to\nalter the display or available functionality by episode type. (e.g. You may associate\ntemplates for discharge summaries with particular episode types)\n\n\nA \nPatient\n will have \nSubrecords\n (such as e.g. Demographics) which follow them across multiple\nepisodes. These are information linked to a particular person, and should be implemented as\nDjango models that inherit from the \nopal.models.PatientSubrecord\n base class.\n\n\nEpisodes\n\n\nAn \nEpisode\n is linked to a \nPatient\n, and will contain some metadata about the type and date\nof the episode. The field \nEpisode.category_name\n stores a string representing the relevant\n\nEpisodeCategory\n e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned\nfrom the \nepisode.category\n field. The start and end dates of an \nEpisode\n may be retrieved\nfrom the \nstart\n and \nend\n properties.\n\n\nAn \nEpisode\n will have \nSubrecords\n (such as e.g. Diagnosis) which are linked to this episode of\ncare. These should be implemented as Django models that inherit from the \nopal.models.EpisodeSubRecord\n\nbase class.\n\n\nRecords\n\n\nA \nSubrecord\n consists of a collection of fields that constitute a record. For example, one could\nimplement a Demograpics \nSubrecord\n as follows:\n\n\nclass Demographics(PatientSubrecord):\n    name             = models.CharField(max_length=255, blank=True)\n    hospital_number  = models.CharField(max_length=255, blank=True)\n    date_of_birth    = models.DateField(null=True, blank=True)\n    ethnicity        = models.CharField(max_length=255, blank=True,\n                                        null=True)\n    gender           = models.CharField(max_length=255, blank=True,\n                                        null=True)\n\n\n\nSubrecords also define various properties that will provide metadata about their\ndisplay or structure, which are documented in the\n\nSubrecord reference material\n\n\nCore Clinical Data Model\n\n\nOPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the \n$ opal startproject\n command will automatically\ncontain concrete implementations of these models in the application.\n\n\nFull documentation of these models is available in the \nArchetypes\n documentation.\n\n\nReference Data\n\n\nOPAL comes with a set of clinical terminology data models out of the box. - we often\nwant to link our records to one of these - for example to record a type of condition\na patient might have, or a drug they are taking.\n\n\nFull documentation of these is available in the \nLookup lists\n documentation.", 
            "title": "Data Model"
>>>>>>> gh-pages
        }, 
        {
            "location": "/guides/working_with_data_in_angular/", 
            "text": "Working with Clinical Data in Angular\n\n\nOPAL provides a range of Angular services for working with clinical data on\nthe front end.\n\n\nThe Episode Service\n\n\nThe \nEpisode\n Service will return an Episode object that represents an individual\nepisode of care, and provides various methods for interacting with both episodes and\nsubrecords.\n\n\nvar episode = new Episode(my_episode_data);\nvar editing = episode.makeCopy();\nediting.start_date = new Date();\nepisode.save(editing);\n\n\n\n\nThe Item Service\n\n\nThe \nItem\n Service returns Item objects that represent individual instances of\nsubrecords. They must be initialised with an episode and a schema representing\nthe available data fields for this subrecord type.\n\n\nvar diagnosis = new Item({}, episode, $rootScope.fields.diagnosis);\nvar editing = diagnosis.makeCopy();\nediting.date_of_diagnosis = new Date();\ndiagnosis.save(editing);\n\n\n\n\nCustomising Subrecords\n\n\nSometimes our application will wish to customise a subrecord of a particular type - for\ninstance to set default values. We do this by setting a custom record service.\n\n\nFirst, we set the name of the service to use as a constructor for this record type as\na property on the model.\n\n\n# yourapp/models.py\nclass Diagnosis(models.Diagnosis):\n    _angular_service = 'Diagnosis'\n\n\n\n\nNext we must include the file with our new service in our application.\n\n\n# yourapp/__init__.py\nclass YourApp(application.OpalApplication):\n    javascripts = [..., 'js/diagnosis.js', ...]\n\n\n\n\nFinally we define an Angular service which expects to be passed the record in order\nto set defaults.\n\n\n// yourapp/static/js/diagnosis.js\nangular.module('opal.records').factory('Diagnosis', function(){\n    return function(record){\n        if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()}\n        return record;\n    }\n});", 
            "title": "Angular Models"
        }, 
        {
<<<<<<< HEAD
            "location": "/guides/working_with_data_in_angular/#working-with-clinical-data-in-angular", 
            "text": "OPAL provides a range of Angular services for working with clinical data on\nthe front end.", 
            "title": "Working with Clinical Data in Angular"
        }, 
        {
            "location": "/guides/working_with_data_in_angular/#the-episode-service", 
            "text": "The  Episode  Service will return an Episode object that represents an individual\nepisode of care, and provides various methods for interacting with both episodes and\nsubrecords.  var episode = new Episode(my_episode_data);\nvar editing = episode.makeCopy();\nediting.start_date = new Date();\nepisode.save(editing);", 
            "title": "The Episode Service"
        }, 
        {
            "location": "/guides/working_with_data_in_angular/#the-item-service", 
            "text": "The  Item  Service returns Item objects that represent individual instances of\nsubrecords. They must be initialised with an episode and a schema representing\nthe available data fields for this subrecord type.  var diagnosis = new Item({}, episode, $rootScope.fields.diagnosis);\nvar editing = diagnosis.makeCopy();\nediting.date_of_diagnosis = new Date();\ndiagnosis.save(editing);", 
            "title": "The Item Service"
        }, 
        {
            "location": "/guides/working_with_data_in_angular/#customising-subrecords", 
            "text": "Sometimes our application will wish to customise a subrecord of a particular type - for\ninstance to set default values. We do this by setting a custom record service.  First, we set the name of the service to use as a constructor for this record type as\na property on the model.  # yourapp/models.py\nclass Diagnosis(models.Diagnosis):\n    _angular_service = 'Diagnosis'  Next we must include the file with our new service in our application.  # yourapp/__init__.py\nclass YourApp(application.OpalApplication):\n    javascripts = [..., 'js/diagnosis.js', ...]  Finally we define an Angular service which expects to be passed the record in order\nto set defaults.  // yourapp/static/js/diagnosis.js\nangular.module('opal.records').factory('Diagnosis', function(){\n    return function(record){\n        if(!record.date_of_diagnosis){ record.date_of_diagnosis = moment()}\n        return record;\n    }\n});", 
            "title": "Customising Subrecords"
=======
            "location": "/guides/datamodel/#patients", 
            "text": "A  Patient  may have many  Episodes . An  Episode  is something like an Inpatient admission,\na telephone liaison, care under an outpatient clinic, an appointment at a drop in clinic.\nApplications or plugins may define their own  Episode  categories, and a common pattern is to\nalter the display or available functionality by episode type. (e.g. You may associate\ntemplates for discharge summaries with particular episode types)  A  Patient  will have  Subrecords  (such as e.g. Demographics) which follow them across multiple\nepisodes. These are information linked to a particular person, and should be implemented as\nDjango models that inherit from the  opal.models.PatientSubrecord  base class.", 
            "title": "Patients"
        }, 
        {
            "location": "/guides/datamodel/#episodes", 
            "text": "An  Episode  is linked to a  Patient , and will contain some metadata about the type and date\nof the episode. The field  Episode.category_name  stores a string representing the relevant EpisodeCategory  e.g. ('Inpatient', 'Outpatient', ...), while a category object is returned\nfrom the  episode.category  field. The start and end dates of an  Episode  may be retrieved\nfrom the  start  and  end  properties.  An  Episode  will have  Subrecords  (such as e.g. Diagnosis) which are linked to this episode of\ncare. These should be implemented as Django models that inherit from the  opal.models.EpisodeSubRecord \nbase class.", 
            "title": "Episodes"
        }, 
        {
            "location": "/guides/datamodel/#records", 
            "text": "A  Subrecord  consists of a collection of fields that constitute a record. For example, one could\nimplement a Demograpics  Subrecord  as follows:  class Demographics(PatientSubrecord):\n    name             = models.CharField(max_length=255, blank=True)\n    hospital_number  = models.CharField(max_length=255, blank=True)\n    date_of_birth    = models.DateField(null=True, blank=True)\n    ethnicity        = models.CharField(max_length=255, blank=True,\n                                        null=True)\n    gender           = models.CharField(max_length=255, blank=True,\n                                        null=True)  Subrecords also define various properties that will provide metadata about their\ndisplay or structure, which are documented in the Subrecord reference material", 
            "title": "Records"
        }, 
        {
            "location": "/guides/datamodel/#core-clinical-data-model", 
            "text": "OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the  $ opal startproject  command will automatically\ncontain concrete implementations of these models in the application.  Full documentation of these models is available in the  Archetypes  documentation.", 
            "title": "Core Clinical Data Model"
        }, 
        {
            "location": "/guides/datamodel/#reference-data", 
            "text": "OPAL comes with a set of clinical terminology data models out of the box. - we often\nwant to link our records to one of these - for example to record a type of condition\na patient might have, or a drug they are taking.  Full documentation of these is available in the  Lookup lists  documentation.", 
            "title": "Reference Data"
        }, 
        {
            "location": "/guides/archetypes/", 
            "text": "Core Clinical Archetypes\n\n\nOPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the \n$ opal startproject\n command will automatically\ncontain concrete implementations of these models in the application.\n\n\nCommon Metadata fields\n\n\nAll subrecords will contain the following fields, which are not repreated individually\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncreated_by\n\n\nFK\n\n\nUser ID\n\n\n\n\n\n\ncreated\n\n\nDate\n\n\n\n\n\n\n\n\nupdated_by\n\n\nFK User ID\n\n\n\n\n\n\n\n\nupdate\n\n\nDate\n\n\n\n\n\n\n\n\n\n\nThe details of each individual archetype are set out below:\n\n\nPatient Subrecords\n\n\nDemographics\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\nhospital_number\n\n\nChar\n\n\n255\n\n\n\n\n\n\nnhs_number\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndate_of_birth\n\n\nDate\n\n\n\n\n\n\n\n\nplace_of_birth\n\n\nFKorFT(Destination)\n\n\n\n\n\n\n\n\nethnicity\n\n\nFKorFT(Ethnicity)\n\n\n\n\n\n\n\n\nsurname\n\n\nChar\n\n\n255\n\n\n\n\n\n\nfirst_name\n\n\nChar\n\n\n255\n\n\n\n\n\n\nmiddle_name\n\n\nChar\n\n\n255\n\n\n\n\n\n\nsex\n\n\nFKorFT(Gender)\n\n\n\n\n\n\n\n\n\n\nAllergies\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ndrug\n\n\nFKorFT(Drug)\n\n\n\n\n\n\n\n\nprovisional\n\n\nBoolean\n\n\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\n\n\nEpisode Subrecords\n\n\nLocation\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncategory\n\n\nChar\n\n\n255\n\n\n\n\n\n\nhospital\n\n\nChar\n\n\n255\n\n\n\n\n\n\nward\n\n\nChar\n\n\n255\n\n\n\n\n\n\nbed\n\n\nChar\n\n\n255\n\n\n\n\n\n\n\n\nTreatment\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ndrug\n\n\nFKorFT(Drug)\n\n\n\n\n\n\n\n\ndose\n\n\nChar\n\n\n255\n\n\n\n\n\n\nroute\n\n\nFKorFT(Drugroute)\n\n\n\n\n\n\n\n\nstart_date\n\n\nDate\n\n\n\n\n\n\n\n\nend_date\n\n\nDate\n\n\n\n\n\n\n\n\nfrequency\n\n\nFKorFT(Drugfreq)\n\n\n\n\n\n\n\n\n\n\nDiagnosis\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\nFKorFT(Condition)\n\n\n\n\n\n\n\n\nprovisional\n\n\nBoolean\n\n\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndate_of_diagnosis\n\n\nDate\n\n\n\n\n\n\n\n\n\n\nPastMedicalHistory\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ncondition\n\n\nFKorFT(Condition)\n\n\n\n\n\n\n\n\nyear\n\n\nChar\n\n\n4\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\n\n\nInvestigation\n\n\n\n\n\n\n\n\nField\n\n\nType\n\n\nLength\n\n\n\n\n\n\n\n\n\n\ntest\n\n\nChar\n\n\n255\n\n\n\n\n\n\ndate_ordered\n\n\nDate\n\n\n\n\n\n\n\n\ndetails\n\n\nChar\n\n\n255\n\n\n\n\n\n\nmicroscopy\n\n\nChar\n\n\n255\n\n\n\n\n\n\norganism\n\n\nChar\n\n\n255\n\n\n\n\n\n\nsensitive_antibiotics\n\n\nChar\n\n\n255\n\n\n\n\n\n\nresistant_antibiotics\n\n\nChar\n\n\n255\n\n\n\n\n\n\nresult\n\n\nChar\n\n\n255\n\n\n\n\n\n\nigm\n\n\nChar\n\n\n20\n\n\n\n\n\n\nigg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nvca_igm\n\n\nChar\n\n\n20\n\n\n\n\n\n\nvca_igg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nebna_igg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhbsag\n\n\nChar\n\n\n20\n\n\n\n\n\n\nanti_hbs\n\n\nChar\n\n\n20\n\n\n\n\n\n\nanti_hbcore_igm\n\n\nChar\n\n\n20\n\n\n\n\n\n\nanti_hbcore_igg\n\n\nChar\n\n\n20\n\n\n\n\n\n\nrpr\n\n\nChar\n\n\n20\n\n\n\n\n\n\ntppa\n\n\nChar\n\n\n20\n\n\n\n\n\n\nviral_load\n\n\nChar\n\n\n20\n\n\n\n\n\n\nparasitaemia\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhsv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nvzv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nsyphilis\n\n\nChar\n\n\n20\n\n\n\n\n\n\nc_difficile_antigen\n\n\nChar\n\n\n20\n\n\n\n\n\n\nc_difficile_toxin\n\n\nChar\n\n\n20\n\n\n\n\n\n\nspecies\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhsv_1\n\n\nChar\n\n\n20\n\n\n\n\n\n\nhsv_2\n\n\nChar\n\n\n20\n\n\n\n\n\n\nenterovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\ncmv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nebv\n\n\nChar\n\n\n20\n\n\n\n\n\n\ninfluenza_a\n\n\nChar\n\n\n20\n\n\n\n\n\n\ninfluenza_b\n\n\nChar\n\n\n20\n\n\n\n\n\n\nparainfluenza\n\n\nChar\n\n\n20\n\n\n\n\n\n\nmetapneumovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\nrsv\n\n\nChar\n\n\n20\n\n\n\n\n\n\nadenovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\nnorovirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\nrotavirus\n\n\nChar\n\n\n20\n\n\n\n\n\n\ngiardia\n\n\nChar\n\n\n20\n\n\n\n\n\n\nentamoeba_histolytica\n\n\nChar\n\n\n20\n\n\n\n\n\n\ncryptosporidium\n\n\nChar\n\n\n20", 
            "title": "Archetypes"
        }, 
        {
            "location": "/guides/archetypes/#core-clinical-archetypes", 
            "text": "OPAL ships with a wide range of core clinical concepts implemented as Abstract Subrecords.\nApplications that are generated via the  $ opal startproject  command will automatically\ncontain concrete implementations of these models in the application.", 
            "title": "Core Clinical Archetypes"
        }, 
        {
            "location": "/guides/archetypes/#common-metadata-fields", 
            "text": "All subrecords will contain the following fields, which are not repreated individually     Field  Type  Length      created_by  FK  User ID    created  Date     updated_by  FK User ID     update  Date      The details of each individual archetype are set out below:", 
            "title": "Common Metadata fields"
        }, 
        {
            "location": "/guides/archetypes/#patient-subrecords", 
            "text": "", 
            "title": "Patient Subrecords"
        }, 
        {
            "location": "/guides/archetypes/#demographics", 
            "text": "Field  Type  Length      hospital_number  Char  255    nhs_number  Char  255    date_of_birth  Date     place_of_birth  FKorFT(Destination)     ethnicity  FKorFT(Ethnicity)     surname  Char  255    first_name  Char  255    middle_name  Char  255    sex  FKorFT(Gender)", 
            "title": "Demographics"
        }, 
        {
            "location": "/guides/archetypes/#allergies", 
            "text": "Field  Type  Length      drug  FKorFT(Drug)     provisional  Boolean     details  Char  255", 
            "title": "Allergies"
        }, 
        {
            "location": "/guides/archetypes/#episode-subrecords", 
            "text": "", 
            "title": "Episode Subrecords"
        }, 
        {
            "location": "/guides/archetypes/#location", 
            "text": "Field  Type  Length      category  Char  255    hospital  Char  255    ward  Char  255    bed  Char  255", 
            "title": "Location"
        }, 
        {
            "location": "/guides/archetypes/#treatment", 
            "text": "Field  Type  Length      drug  FKorFT(Drug)     dose  Char  255    route  FKorFT(Drugroute)     start_date  Date     end_date  Date     frequency  FKorFT(Drugfreq)", 
            "title": "Treatment"
        }, 
        {
            "location": "/guides/archetypes/#diagnosis", 
            "text": "Field  Type  Length      condition  FKorFT(Condition)     provisional  Boolean     details  Char  255    date_of_diagnosis  Date", 
            "title": "Diagnosis"
        }, 
        {
            "location": "/guides/archetypes/#pastmedicalhistory", 
            "text": "Field  Type  Length      condition  FKorFT(Condition)     year  Char  4    details  Char  255", 
            "title": "PastMedicalHistory"
        }, 
        {
            "location": "/guides/archetypes/#investigation", 
            "text": "Field  Type  Length      test  Char  255    date_ordered  Date     details  Char  255    microscopy  Char  255    organism  Char  255    sensitive_antibiotics  Char  255    resistant_antibiotics  Char  255    result  Char  255    igm  Char  20    igg  Char  20    vca_igm  Char  20    vca_igg  Char  20    ebna_igg  Char  20    hbsag  Char  20    anti_hbs  Char  20    anti_hbcore_igm  Char  20    anti_hbcore_igg  Char  20    rpr  Char  20    tppa  Char  20    viral_load  Char  20    parasitaemia  Char  20    hsv  Char  20    vzv  Char  20    syphilis  Char  20    c_difficile_antigen  Char  20    c_difficile_toxin  Char  20    species  Char  20    hsv_1  Char  20    hsv_2  Char  20    enterovirus  Char  20    cmv  Char  20    ebv  Char  20    influenza_a  Char  20    influenza_b  Char  20    parainfluenza  Char  20    metapneumovirus  Char  20    rsv  Char  20    adenovirus  Char  20    norovirus  Char  20    rotavirus  Char  20    giardia  Char  20    entamoeba_histolytica  Char  20    cryptosporidium  Char  20", 
            "title": "Investigation"
>>>>>>> gh-pages
        }, 
        {
            "location": "/guides/flow/", 
            "text": "Flow hooks in OPAL\n\n\nOPAL provides various hooks that developers can use to customise behaviour at certain key points in a\npatient's journey through a clinical service - for example when a patient is discharged.\n\n\nThese hooks are associated with verbs \nenter\n, \nexit\n.\n\n\nThe Flow service\n\n\nYour application scaffold will have created a file at\n\n./yourapp/assets/js/yourapp/services/flow.js\n. This file will declare an angular service that\nyour application will use to determine how to move to the correct next step for a patient.\n\n\nFlow services must define an \nenter\n and an \nexit\n method, which both return the appropriate\nangular controller and template to use. Although OPAL provides sensible default controllers and\ntemplates for these common actions, applications with custom flows may customise these methods\nas required.\n\n\nThe enter verb\n\n\nThe enter verb is called when a patient is added to a service - for instance by adding a patient to a team list.\n\n\nImplementations of enter are expected to return a dictionary of the controller and template they wish to be called.\n\n\nenter: function(){\n        return {\n            'controller': 'HospitalNumberCtrl',\n            'template'  : '/templates/modals/hospital_number.html/'\n        }\n    }\n\n\n\nA common strategy is to examine angular \n$route\n or \n$routeParams\n to determine where the user is in the application.\nFor instance you may wish to have custom controllers for a particular patient list, or the search results page.\n\n\nThe exit verb\n\n\nThe exit verb is called when a patient is moving through a service - for instance when we discharge a patient, or end\none phase of a clinical pathway.\n\n\nImplementations of exit are expected to return a dictionary of the controller and template they wish to be called.\n\n\nThe enter verb will receive the episode that we are acting on - for instance a controller that acts differently for\ndeceased patients might look as follows\n\n\nexit: function(episode){\n      if(episode.demographics[0].deceased){\n          return {\n              'controller': 'DeceasedDischargeEpisodeCtrl',\n              'template'  : '/templates/modals/deceased_discharge.html/'\n          }\n      }\n      return {\n          'controller': 'DischargeEpisodeCtrl',\n          'template'  : '/templates/modals/discharge_episode.html/'\n      }\n    }", 
            "title": "Flow"
        }, 
        {
            "location": "/guides/flow/#flow-hooks-in-opal", 
            "text": "OPAL provides various hooks that developers can use to customise behaviour at certain key points in a\npatient's journey through a clinical service - for example when a patient is discharged.  These hooks are associated with verbs  enter ,  exit .  The Flow service  Your application scaffold will have created a file at ./yourapp/assets/js/yourapp/services/flow.js . This file will declare an angular service that\nyour application will use to determine how to move to the correct next step for a patient.  Flow services must define an  enter  and an  exit  method, which both return the appropriate\nangular controller and template to use. Although OPAL provides sensible default controllers and\ntemplates for these common actions, applications with custom flows may customise these methods\nas required.  The enter verb  The enter verb is called when a patient is added to a service - for instance by adding a patient to a team list.  Implementations of enter are expected to return a dictionary of the controller and template they wish to be called.  enter: function(){\n        return {\n            'controller': 'HospitalNumberCtrl',\n            'template'  : '/templates/modals/hospital_number.html/'\n        }\n    }  A common strategy is to examine angular  $route  or  $routeParams  to determine where the user is in the application.\nFor instance you may wish to have custom controllers for a particular patient list, or the search results page.  The exit verb  The exit verb is called when a patient is moving through a service - for instance when we discharge a patient, or end\none phase of a clinical pathway.  Implementations of exit are expected to return a dictionary of the controller and template they wish to be called.  The enter verb will receive the episode that we are acting on - for instance a controller that acts differently for\ndeceased patients might look as follows  exit: function(episode){\n      if(episode.demographics[0].deceased){\n          return {\n              'controller': 'DeceasedDischargeEpisodeCtrl',\n              'template'  : '/templates/modals/deceased_discharge.html/'\n          }\n      }\n      return {\n          'controller': 'DischargeEpisodeCtrl',\n          'template'  : '/templates/modals/discharge_episode.html/'\n      }\n    }", 
            "title": "Flow hooks in OPAL"
        }, 
        {
            "location": "/guides/roles_and_permissions/", 
            "text": "Roles \n Permissions in OPAL\n\n\nOPAL provides some global per-user flags, which are set in the UserProfile model, as well\nas more detailed permissions available via roles.\n\n\nThe UserProfile model\n\n\nSome global properties about Users are set in the \nopal.models.UserProfile\n\nmodel.\n\n\nUserProflie._can_extract\n\n\nBoolean flag to determine whether this user is allowed to download data extracts\nfrom the system\n\n\nUserProflie._force_password_change\n\n\nBoolean flag to determine whether we would like to force this user to change\ntheir password on their next login. This defaults to \nTrue\n when the \nUser\n is\nfirst created.\n\n\nUserProfile._readonly\n\n\nBoolean flag to determine whether this user has readonly access.\n\n\nUserProfile._restricted_only\n\n\nBoolean flag to determine whether this user should be only shown teams for which they\nhave explicitly been given permission to view or whether they should also see the list of\ngeneral access teams.\n\n\nUserProfile.get_roles()\n\n\nReturn a dictionary of roles in various contexts for our user\n\n\nprofile.get_roles() # -\n\n{\n    'default': ['doctor'],\n    'some_research_study': ['Clinical Lead']\n}\n\n\n\nUserProfile.get_teams()\n\n\nReturn a list of \nTeam\n objects that this user should be allowed to see.\n\n\nRoles\n\n\nA user may be given a particular role. These can be either global - in which case they are\nreturned in the 'default' section of the roles dict from \nget_roles()\n, or specific to\na team.", 
            "title": "Roles & Permissions"
        }, 
        {
            "location": "/guides/roles_and_permissions/#roles-permissions-in-opal", 
            "text": "OPAL provides some global per-user flags, which are set in the UserProfile model, as well\nas more detailed permissions available via roles.  The UserProfile model  Some global properties about Users are set in the  opal.models.UserProfile \nmodel.  UserProflie._can_extract  Boolean flag to determine whether this user is allowed to download data extracts\nfrom the system  UserProflie._force_password_change  Boolean flag to determine whether we would like to force this user to change\ntheir password on their next login. This defaults to  True  when the  User  is\nfirst created.  UserProfile._readonly  Boolean flag to determine whether this user has readonly access.  UserProfile._restricted_only  Boolean flag to determine whether this user should be only shown teams for which they\nhave explicitly been given permission to view or whether they should also see the list of\ngeneral access teams.  UserProfile.get_roles()  Return a dictionary of roles in various contexts for our user  profile.get_roles() # - \n{\n    'default': ['doctor'],\n    'some_research_study': ['Clinical Lead']\n}  UserProfile.get_teams()  Return a list of  Team  objects that this user should be allowed to see.  Roles  A user may be given a particular role. These can be either global - in which case they are\nreturned in the 'default' section of the roles dict from  get_roles() , or specific to\na team.", 
            "title": "Roles &amp; Permissions in OPAL"
        }, 
        {
            "location": "/guides/tagging/", 
            "text": "Tagging\n\n\nEpisodes in OPAL may be tagged. This is commonly used as a mechanism to\nrecord that a particular team is looking after a patient - via \nTaggedPatientList\n,\nbut also to group patients.\n\n\nFor instance, we might like to 'tag' episodes with a particular string when some\nparticular event occurrs so that we can run reports or analyse these groups later.\n\n\nThe \"Teams\" modal in list and detail views, is actually an interface over updating\nthe tagging of the episode in question.\n\n\nMetadata concerning tags can be found via the Options API.", 
            "title": "Tagging"
        }, 
        {
            "location": "/guides/tagging/#tagging", 
            "text": "Episodes in OPAL may be tagged. This is commonly used as a mechanism to\nrecord that a particular team is looking after a patient - via  TaggedPatientList ,\nbut also to group patients.  For instance, we might like to 'tag' episodes with a particular string when some\nparticular event occurrs so that we can run reports or analyse these groups later.  The \"Teams\" modal in list and detail views, is actually an interface over updating\nthe tagging of the episode in question.  Metadata concerning tags can be found via the Options API.", 
            "title": "Tagging"
        }, 
        {
            "location": "/guides/json_api/", 
            "text": "The OPAL JSON API\n\n\nOPAL features a rich, self documenting set of open JSON APIs.\n\n\nOPAL applications are generally simply a collection of Browser-based clients\nfor these APIs.\n\n\nOPAL uses Django Rest Framework to provide it's APIs.\n\n\nYou may examine the API of any running OPAL application by navigating to the url \n/api/v0.1/\n\n\nAdding your own APIs\n\n\nYou can add your own APIs to the OPAL API namespae \nfrom plugins\n or \nby registering them directly with the router.\n\n\nfrom rest_framework.viewsets import ViewSet\nfrom rest_framework.response import Response\nfrom opal.core.api import router\n\n\nclass PingViewSet(ViewSet):\n    def list(self, request): return Response('pong')\n\nrouter.register('ping', PingViewSet)", 
            "title": "JSON API"
        }, 
        {
            "location": "/guides/json_api/#the-opal-json-api", 
            "text": "OPAL features a rich, self documenting set of open JSON APIs.  OPAL applications are generally simply a collection of Browser-based clients\nfor these APIs.  OPAL uses Django Rest Framework to provide it's APIs.  You may examine the API of any running OPAL application by navigating to the url  /api/v0.1/  Adding your own APIs  You can add your own APIs to the OPAL API namespae  from plugins  or \nby registering them directly with the router.  from rest_framework.viewsets import ViewSet\nfrom rest_framework.response import Response\nfrom opal.core.api import router\n\n\nclass PingViewSet(ViewSet):\n    def list(self, request): return Response('pong')\n\nrouter.register('ping', PingViewSet)", 
            "title": "The OPAL JSON API"
        }, 
        {
            "location": "/guides/lookup_lists/", 
            "text": "OPAL Lookup Lists\n\n\nLookup Lists allow us to reference canonical lists of available terminology as a foreign key, while\nalso allowing synonymous terms, and a free text override.\n\n\nAdding a lookup list\n\n\nLookup lists are subclasses of \nopal.core.lookuplists.LookupList\n. Typically, a specific named\nlookup list will not need to do anything other than define a class that inherits from the base\nclass.\n\n\nThe custom field type \nopal.core.fields.ForeignKeyOrFreeText\n allows you to build interfaces\nthat cater for synonyms, and also allow the user to enter a free text string that is not in\nthe lookup list.\n\n\n# yourapp.models\n\nfrom django.db import models\nfrom opal.core import lookuplists\nfrom opal.core.fields import ForeignKeyOrFreeText\nfrom opal.models import EpisodeSubrecord\n\nclass TreatmentType(lookuplists.LookupList): pass\n\nclass Treatment(EpisodeSubrecord):\n    treatment = ForeignKeyOrFreeText(TreatmentType)\n    notes     = models.CharField(max_length=200)\n# yourapp.models\n\n\n\nWhen you create your lookup list, you are creating a new model, so you will need a new migration\nto accompany it.\n\n\n$ python manage.py schemamigration --atuo yourapp\n$ python manage.py migrate yourapp\n\n\n\nThe lookup list will automatically be added to the admin.\n\n\nManagement commands\n\n\nOPAL ships with some managemnent commands for importing and exporting lookup lists\n\n\ndump_lookup_lists\n\n\nPrints all lookuplists as JSON to stdout.\n\n\nload_lookup_lists -f [filename]\n\n\nLoads lookup lists in the OPAL JSON format.\n\n\ndelete_all_lookuplists\n\n\nDeletes all currently lookuplist values and related synonyms", 
            "title": "Lookup Lists"
        }, 
        {
            "location": "/guides/lookup_lists/#opal-lookup-lists", 
            "text": "Lookup Lists allow us to reference canonical lists of available terminology as a foreign key, while\nalso allowing synonymous terms, and a free text override.  Adding a lookup list  Lookup lists are subclasses of  opal.core.lookuplists.LookupList . Typically, a specific named\nlookup list will not need to do anything other than define a class that inherits from the base\nclass.  The custom field type  opal.core.fields.ForeignKeyOrFreeText  allows you to build interfaces\nthat cater for synonyms, and also allow the user to enter a free text string that is not in\nthe lookup list.  # yourapp.models\n\nfrom django.db import models\nfrom opal.core import lookuplists\nfrom opal.core.fields import ForeignKeyOrFreeText\nfrom opal.models import EpisodeSubrecord\n\nclass TreatmentType(lookuplists.LookupList): pass\n\nclass Treatment(EpisodeSubrecord):\n    treatment = ForeignKeyOrFreeText(TreatmentType)\n    notes     = models.CharField(max_length=200)\n# yourapp.models  When you create your lookup list, you are creating a new model, so you will need a new migration\nto accompany it.  $ python manage.py schemamigration --atuo yourapp\n$ python manage.py migrate yourapp  The lookup list will automatically be added to the admin.  Management commands  OPAL ships with some managemnent commands for importing and exporting lookup lists  dump_lookup_lists  Prints all lookuplists as JSON to stdout.  load_lookup_lists -f [filename]  Loads lookup lists in the OPAL JSON format.  delete_all_lookuplists  Deletes all currently lookuplist values and related synonyms", 
            "title": "OPAL Lookup Lists"
        }, 
        {
            "location": "/guides/templates/", 
            "text": "Templates in OPAL\n\n\nOPAL uses a mixture of Django and Angular templates.\n\n\nAngular templates\n\n\nIn order to be compatible with Django templating, we use the \n[[ ... ]]\n notation for\nAngular interpolation, which allows us to mix Django template interpolation in templates\ndesigned to be rendered by Angular on the client side.\n\n\n!-- app_details_snippet.html --\n\n{{ OPAL_BRAND_NAME }} [[ OPAL_VERSION ]]\n\n\n\nGeneric Template URL\n\n\nOn many occasions we simply want to fetch a template from the server in our Angular code\nwithout any further processing. OPAL provides a default catchall HTML template url which\nwill render .html files direct from disk.\n\n\n# opal.urls\n\nurl(r'templates/(?P\ntemplate_name\n[a-z_/]+.html)', views.RawTemplateView.as_view())\n\n\n\nSo if our template is at \n./myapp/templates/foo/bar.html\n, then the url \n/templates/foo/bar.html\n\nwill return it.", 
            "title": "Templates"
        }, 
        {
            "location": "/guides/templates/#templates-in-opal", 
            "text": "OPAL uses a mixture of Django and Angular templates.  Angular templates  In order to be compatible with Django templating, we use the  [[ ... ]]  notation for\nAngular interpolation, which allows us to mix Django template interpolation in templates\ndesigned to be rendered by Angular on the client side.  !-- app_details_snippet.html -- \n{{ OPAL_BRAND_NAME }} [[ OPAL_VERSION ]]  Generic Template URL  On many occasions we simply want to fetch a template from the server in our Angular code\nwithout any further processing. OPAL provides a default catchall HTML template url which\nwill render .html files direct from disk.  # opal.urls\n\nurl(r'templates/(?P template_name [a-z_/]+.html)', views.RawTemplateView.as_view())  So if our template is at  ./myapp/templates/foo/bar.html , then the url  /templates/foo/bar.html \nwill return it.", 
            "title": "Templates in OPAL"
        }, 
        {
            "location": "/guides/context_processors/", 
            "text": "Default context Processors\n\n\nsettings\n\n\nall settings are copied into the context of the template\n\n\nmodels\n\n\nall subrecords are copied into the context of the template under the namespace models, e.g. the allergies subrecord can be referred to by models.Allergy", 
            "title": "Context Processors"
        }, 
        {
            "location": "/guides/context_processors/#default-context-processors", 
            "text": "settings  all settings are copied into the context of the template", 
            "title": "Default context Processors"
        }, 
        {
            "location": "/guides/context_processors/#models", 
            "text": "all subrecords are copied into the context of the template under the namespace models, e.g. the allergies subrecord can be referred to by models.Allergy", 
            "title": "models"
        }, 
        {
            "location": "/guides/static_files/", 
            "text": "Static Files in OPAL\n\n\nAs with any Javascript heavy application, OPAL apps can quickly accumulate large numbers\nof static files. OPAL ships with the \nDjango Compressor\n\nlibrary out of the box, and uses it to manage the Javascript asset pipeline.\n\n\nDo consult the excellent Django Compresor documentation for more details on exactly how this process works.", 
            "title": "Static Files"
        }, 
        {
            "location": "/guides/static_files/#static-files-in-opal", 
            "text": "As with any Javascript heavy application, OPAL apps can quickly accumulate large numbers\nof static files. OPAL ships with the  Django Compressor \nlibrary out of the box, and uses it to manage the Javascript asset pipeline.  Do consult the excellent Django Compresor documentation for more details on exactly how this process works.", 
            "title": "Static Files in OPAL"
        }, 
        {
            "location": "/guides/forms/", 
            "text": "Forms\n\n\nEditing Records\n\n\nThe editing of records is a key component of any OPAL application. A key pattern is to edit\nor create an individual record in a modal containing the form for just that record. OPAL provides\nthe Angular Controller \nopal.controllers.EditItemCtrl\n for doing just this\n\n\nCustomising the Angular Controller\n\n\nOPAL uses the \nformController\n attribute of an \nItem\n to determine which Angular Controller to use. This\ndefaults to \nopal.controllers.EditItemCtrl\n. Individual Subrecords may customise this by implementing an Angualar record Service\nand overriding the formController attribute.\n\n\n# yourapp/models.py\nclass Diagnosis(models.Diagnosis):\n    _angular_service = 'Diagnosis'\n\n\n\n\n// yourapp/static/js/diagnosis.js\nangular.module('opal.records').factory('Diagnosis', function(){\n    return function(record){\n        record.formController = 'MyCustomDiagnosisFormController';\n        return record;\n    }\n});\n\n\n\n\n\nCustom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved\n\n\nForm and modal templates\n\n\nSubrecords have \nget_form_template()\n and \nget_modal_template()\n methods, which are used for\nfiguring out how to render forms for interacting with them. These use the following template\npaths based on the context in which they are called:\n\n\n# Forms\nforms/{episode_type}/{list slug}/{record_name}_form.html\nforms/{list_slug}/{record_name}_form.html\nforms/{episode_type}/{record_name}_form.html\nforms/{record_name}_form.html\n\n# Modals\nmodals/{episode_type}/{list slug}/{record_name}_modal.html\nmodals/{list_slug}/{record_name}_modal.html\nmodals/{episode_type}/{record_name}_modal.html\nmodals/{record_name}_modal.html\n\n\n\nAutogenerating forms\n\n\nThe \nopal\n commandline tool has a scaffold command, which will autogenerate missing form templates\nfor subrecord models. Simply run the following command to generate.\n\n\n$ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE\n\n\n\n(Note this will also generate and run migrations for any unmigrated models.xb)\n\n\nClient side Validation\n\n\nClient side validation for forms requires a pattern and a help block \n uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input)\n\n\nHelpers\n\n\nOPAL contains a number of helpers for developing forms and input modals.\n\n\nMany of these are located in the forms template tag library, which is a\nDjango templatetag library that understands the context of common patterns with\nOPAL for creating forms and modals.\n\n\nIt provides helpers for various input types that will allow you to render consistent\nforms, with less verbose templates.\n\n\n{% load forms %}\n\nform class=\"form-horizontal\"\n\n  {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %}\n  {% datepicker label=\"Date\" model=\"editing.date\" %}\n  {% checkbox label=\"Alone?\" model=\"editing.alone\" %}\n\n/form\n\n\n\n\nFor full documentation of the options, please see the \nForm templatetags reference material", 
            "title": "Forms"
        }, 
        {
            "location": "/guides/forms/#forms", 
            "text": "Editing Records  The editing of records is a key component of any OPAL application. A key pattern is to edit\nor create an individual record in a modal containing the form for just that record. OPAL provides\nthe Angular Controller  opal.controllers.EditItemCtrl  for doing just this  Customising the Angular Controller  OPAL uses the  formController  attribute of an  Item  to determine which Angular Controller to use. This\ndefaults to  opal.controllers.EditItemCtrl . Individual Subrecords may customise this by implementing an Angualar record Service\nand overriding the formController attribute.  # yourapp/models.py\nclass Diagnosis(models.Diagnosis):\n    _angular_service = 'Diagnosis'  // yourapp/static/js/diagnosis.js\nangular.module('opal.records').factory('Diagnosis', function(){\n    return function(record){\n        record.formController = 'MyCustomDiagnosisFormController';\n        return record;\n    }\n});  Custom form controllers can use the preSave(itemToBeSaved) hook to add their own custom logic before the item is saved  Form and modal templates  Subrecords have  get_form_template()  and  get_modal_template()  methods, which are used for\nfiguring out how to render forms for interacting with them. These use the following template\npaths based on the context in which they are called:  # Forms\nforms/{episode_type}/{list slug}/{record_name}_form.html\nforms/{list_slug}/{record_name}_form.html\nforms/{episode_type}/{record_name}_form.html\nforms/{record_name}_form.html\n\n# Modals\nmodals/{episode_type}/{list slug}/{record_name}_modal.html\nmodals/{list_slug}/{record_name}_modal.html\nmodals/{episode_type}/{record_name}_modal.html\nmodals/{record_name}_modal.html  Autogenerating forms  The  opal  commandline tool has a scaffold command, which will autogenerate missing form templates\nfor subrecord models. Simply run the following command to generate.  $ opal scaffold $DJANGO_APP_WHERE_MODELS_LIVE  (Note this will also generate and run migrations for any unmigrated models.xb)  Client side Validation  Client side validation for forms requires a pattern and a help block   uses ng-pattern, ng-disabled (https://docs.angularjs.org/api/ng/directive/input)  Helpers  OPAL contains a number of helpers for developing forms and input modals.  Many of these are located in the forms template tag library, which is a\nDjango templatetag library that understands the context of common patterns with\nOPAL for creating forms and modals.  It provides helpers for various input types that will allow you to render consistent\nforms, with less verbose templates.  {% load forms %} form class=\"form-horizontal\" \n  {% input \"autofocus\" label=\"Destination\" model=\"editing.destination\" lookuplist=\"destination_list\" %}\n  {% datepicker label=\"Date\" model=\"editing.date\" %}\n  {% checkbox label=\"Alone?\" model=\"editing.alone\" %} /form   For full documentation of the options, please see the  Form templatetags reference material", 
            "title": "Forms"
        }, 
        {
            "location": "/guides/patient_detail_views/", 
            "text": "OPAL Patient Detail Views\n\n\nOPAL provides all patients with a detail view.\n\n\nThe default detail view will allow the user to switch between all of a patient's\n\nepisodes\n, as well as editing patient information linked to the patient\nrather than an episode. (Allergies for example.)\n\n\nTemplate selection\n\n\nThe base template for a patient detail view is \n./opal/templates/patient_detail_base.html\n,\nalthough you can override or customise that for your application most easily by implementing\na \n./templates/patient_detail.html\n and customising specific blocks, as the OPAL implementation\nsimply includes the base template.\n\n\nEach episode will display using the template appropriate for it's \nEpisodeCategory\n - for instance\nan \nInpatientEpisode\n will use \n./templates/detail/inpatient.html\n. You may \ndefine your own\nepisode types\n should you require.\n\n\nRecord Panels\n\n\nA frequent pattern when constructing detail views is to render a panel for a particular \nSubrecord\n\ntype. The panels templatetag library contains some useful helpers for rendering panels based on\nmodels.\n\n\n{% load panels %}\n{% record_panel Diagnosis %}\n\n\n\nThe above code will render a panel for your episode, including the \nSubrecord\n detail template for\neach instance, and allowing editing, deletion and creation of instances of your \nSubrecord\n.\n\n\nYou may also consult the Detailed \nreference documentation\n for\nRecord Panels.\n\n\nCustom Patient Detail Views\n\n\nSometimes we also need to display information about a patient across multiple episodes, or simlply\na particular view of one episode. For instance, you might like to have a specific view for showing\nall of the lab results for a patient, which would be overwhelming were they all displayed in the\nepisode detail view.\n\n\nOPAL's PatientDetailView allows you to do just this. To add an additional view to a patient you\nsimply declare a PatientDetailView class:\n\n\n# detail.py\nfrom opal.core import detail\n\nclass MyCustomView(detail.PatientDetailView):\n    name = 'my_custom_view'\n    title = 'Special View'\n    template = 'detail/my_custom_view.html'\n\n\n\nThis will then be available in the Patient Detail view in the episode switcher menu. You can\nfind details of all the various options for PatientDetailViews in the\n\nreference documentation\n.", 
            "title": "Patient Detail Views"
        }, 
        {
            "location": "/guides/patient_detail_views/#opal-patient-detail-views", 
            "text": "OPAL provides all patients with a detail view.  The default detail view will allow the user to switch between all of a patient's episodes , as well as editing patient information linked to the patient\nrather than an episode. (Allergies for example.)  Template selection  The base template for a patient detail view is  ./opal/templates/patient_detail_base.html ,\nalthough you can override or customise that for your application most easily by implementing\na  ./templates/patient_detail.html  and customising specific blocks, as the OPAL implementation\nsimply includes the base template.  Each episode will display using the template appropriate for it's  EpisodeCategory  - for instance\nan  InpatientEpisode  will use  ./templates/detail/inpatient.html . You may  define your own\nepisode types  should you require.  Record Panels  A frequent pattern when constructing detail views is to render a panel for a particular  Subrecord \ntype. The panels templatetag library contains some useful helpers for rendering panels based on\nmodels.  {% load panels %}\n{% record_panel Diagnosis %}  The above code will render a panel for your episode, including the  Subrecord  detail template for\neach instance, and allowing editing, deletion and creation of instances of your  Subrecord .  You may also consult the Detailed  reference documentation  for\nRecord Panels.  Custom Patient Detail Views  Sometimes we also need to display information about a patient across multiple episodes, or simlply\na particular view of one episode. For instance, you might like to have a specific view for showing\nall of the lab results for a patient, which would be overwhelming were they all displayed in the\nepisode detail view.  OPAL's PatientDetailView allows you to do just this. To add an additional view to a patient you\nsimply declare a PatientDetailView class:  # detail.py\nfrom opal.core import detail\n\nclass MyCustomView(detail.PatientDetailView):\n    name = 'my_custom_view'\n    title = 'Special View'\n    template = 'detail/my_custom_view.html'  This will then be available in the Patient Detail view in the episode switcher menu. You can\nfind details of all the various options for PatientDetailViews in the reference documentation .", 
            "title": "OPAL Patient Detail Views"
        }, 
        {
            "location": "/guides/list_views/", 
            "text": "OPAL Patient List views\n\n\nOPAL provides support for displaying lists of patients, both via a spreadsheet like view,\nand with a card based view.\n\n\nDefining lists\n\n\nOPAL patient lists are subclasses of \nopal.core.patient_lists.PatientList\n.\n\n\nTypically these are found in a \npatient_lists.py\n module of your application or plugin. (Lists \ncan\n be\ndefined elsewhere, but may not be autodiscovered.)\n\n\nA basic list needs only define it's \ndisplay_name\n a \nqueryset\n of episodes to display, and\na \nschema\n of subrecords to show for each episode.\n\n\n# patient_lists.py\nfrom opal.models import Episore\nfrom opal.core import patient_lists\n\nfrom myapplication import models\n\nclass AlphabetListA(patient_lists.PatientList):\n    display_name = 'A Patients'\n\n    queryset = Episode.objects.filter(demographics__name__istartswith='a')\n\n    schema = [\n        models.Demographics,\n        models.Location,\n        models.Diagnosis,\n        models.Treatment\n    ]\n\n\n\nThe \ndisplay_name\n property is the human readable name for our list - which is displayed as\nlink text to our list.\n\n\nSchemas\n\n\nSchemas are lists of Subrecords that we would like to display in our list. By default we\nrender the subrecord display_template, and allow editing and addition of each subrecord in\nplace.\n\n\nTemplate selection\n\n\nThe list view is constructed by rendering a column for each record, in the order\ndefined in the schema, and a row for each episode in the list.\n\n\nThe template for each cell should live in \n./templates/records/*\n. In order to\nselect the appropriate template for a given episode, OPAL looks in the following\nlocations:\n\n\nrecords/{episode_type}/{list slug}/{record_name}.html\nrecords/{list_slug}/{record_name}.html\nrecords/{episode_type}/{record_name}.html\nrecords/{record_name}.html\n\n\n\nQuerysets\n\n\nThe queryset property of your list should contain all of the episodes for this particular\nlist. On occasion we require a more dynamic queryset, in which case we can ovreride the\n\nget_queryset\n method.\n\n\n# patient_lists.py\nimport datetime\nfrom opal.models import Episode\nfrom opal.core import patient_lists\n\nclass MyWeeklyList(patient_lists.PatientList):\n    def get_queryset(self):\n        one_week_ago = datetime.date.today() - datetime.timedelta(days=1)\n        return Episode.objects.filter(date_of_admission__gte=one_week_ago)\n\n\n\nOrdering Lists\n\n\nAs a \ndiscoverable.SortableFeature\n lists may be ordered by setting the\n\norder\n property to an integer. Lists will display in drop-downs, tables et cetera, in\nthis order.\n\n\nSlug\n\n\nAs a \ndiscoverable\n feature, the slug for each list is determined by\neither setting the \nslug\n property, or returning a string from the \nget_slug\n classmethod.\n\n\nTemplates\n\n\nTagged Patient Lists\n\n\nA common model for working with lists is to use lists based on the tags assigned to an episode.\nThis allows users to add and remove patients from lists as they see fit, rather than attempting\nto infer it from other properties of the patient (e.g. their current location for instance.)\nwhich can be particularly challenging for some clinical services.\n\n\nOPAL provides a specific subclass for working with Tagged Patient Lists:\n\n\n# patient_lists.py\nfrom opal.core import patient_lists\n\nclass MyTagList(patient_lists.TaggedPatientList):\n    display_name = 'Tagged blue'\n    tag = 'blue'\n\n\n\nTagged lists will automatically fetch the appropriate queryset for patients tagged with the tag\nyou specify.\n\n\nInvalid Tagged Patient Lists\n\n\nTag names may not have hyphens in them - OPAL uses hyphens to distinguish between tags and subtags\nin the urls for lists, so attempting to define one will raise an exception.\n\n\nclass MyList(TaggedPatientList):\n    tag = 'foo-bar'\n\n# This will raise InvalidDiscoverableFeatureError !\n\n\n\nDirect Add\n\n\nSometimes, we want to control the flow of patients onto, off, or between lists a little more closely.\nFor instance, we might need to ensure additional data collection at points in a patient journey.\n\n\nIn order to accomplish this, we often implement custom patient flows that wil programatically tag\nepisodes to tagged lists. In those cases we will want to prevent users from manually adding or\nremoving the tags themselves. This can be easily accomplished via the \ndirect_add\n property. When\nset to false, users will not be able to add the tag for this list.\n\n\nclass MyLockedDownList(TaggedPatientList):\n    tag = 'liaisonpatients'\n    direct_add = False\n\n\n\nAccess Control\n\n\nAs PatientLists are a \nRestrictableFeature\n, Access control\nfor lists is set by overriding the \nvisible_to\n classmethod. Your list will only be visible to\nthose users for whom this method returns \nTrue\n.\n\n\nFor instance, we could define a Patient List that was only available to Django Superusers:\n\n\nclass SuperuserPatientList(PatientList):\n\n    @classmethod\n    def visible_to(klass, user):\n        return user.is_superuser", 
            "title": "Patient List Views"
        }, 
        {
            "location": "/guides/list_views/#opal-patient-list-views", 
            "text": "OPAL provides support for displaying lists of patients, both via a spreadsheet like view,\nand with a card based view.  Defining lists  OPAL patient lists are subclasses of  opal.core.patient_lists.PatientList .  Typically these are found in a  patient_lists.py  module of your application or plugin. (Lists  can  be\ndefined elsewhere, but may not be autodiscovered.)  A basic list needs only define it's  display_name  a  queryset  of episodes to display, and\na  schema  of subrecords to show for each episode.  # patient_lists.py\nfrom opal.models import Episore\nfrom opal.core import patient_lists\n\nfrom myapplication import models\n\nclass AlphabetListA(patient_lists.PatientList):\n    display_name = 'A Patients'\n\n    queryset = Episode.objects.filter(demographics__name__istartswith='a')\n\n    schema = [\n        models.Demographics,\n        models.Location,\n        models.Diagnosis,\n        models.Treatment\n    ]  The  display_name  property is the human readable name for our list - which is displayed as\nlink text to our list.  Schemas  Schemas are lists of Subrecords that we would like to display in our list. By default we\nrender the subrecord display_template, and allow editing and addition of each subrecord in\nplace.  Template selection  The list view is constructed by rendering a column for each record, in the order\ndefined in the schema, and a row for each episode in the list.  The template for each cell should live in  ./templates/records/* . In order to\nselect the appropriate template for a given episode, OPAL looks in the following\nlocations:  records/{episode_type}/{list slug}/{record_name}.html\nrecords/{list_slug}/{record_name}.html\nrecords/{episode_type}/{record_name}.html\nrecords/{record_name}.html  Querysets  The queryset property of your list should contain all of the episodes for this particular\nlist. On occasion we require a more dynamic queryset, in which case we can ovreride the get_queryset  method.  # patient_lists.py\nimport datetime\nfrom opal.models import Episode\nfrom opal.core import patient_lists\n\nclass MyWeeklyList(patient_lists.PatientList):\n    def get_queryset(self):\n        one_week_ago = datetime.date.today() - datetime.timedelta(days=1)\n        return Episode.objects.filter(date_of_admission__gte=one_week_ago)  Ordering Lists  As a  discoverable.SortableFeature  lists may be ordered by setting the order  property to an integer. Lists will display in drop-downs, tables et cetera, in\nthis order.  Slug  As a  discoverable  feature, the slug for each list is determined by\neither setting the  slug  property, or returning a string from the  get_slug  classmethod.  Templates  Tagged Patient Lists  A common model for working with lists is to use lists based on the tags assigned to an episode.\nThis allows users to add and remove patients from lists as they see fit, rather than attempting\nto infer it from other properties of the patient (e.g. their current location for instance.)\nwhich can be particularly challenging for some clinical services.  OPAL provides a specific subclass for working with Tagged Patient Lists:  # patient_lists.py\nfrom opal.core import patient_lists\n\nclass MyTagList(patient_lists.TaggedPatientList):\n    display_name = 'Tagged blue'\n    tag = 'blue'  Tagged lists will automatically fetch the appropriate queryset for patients tagged with the tag\nyou specify.  Invalid Tagged Patient Lists  Tag names may not have hyphens in them - OPAL uses hyphens to distinguish between tags and subtags\nin the urls for lists, so attempting to define one will raise an exception.  class MyList(TaggedPatientList):\n    tag = 'foo-bar'\n\n# This will raise InvalidDiscoverableFeatureError !  Direct Add  Sometimes, we want to control the flow of patients onto, off, or between lists a little more closely.\nFor instance, we might need to ensure additional data collection at points in a patient journey.  In order to accomplish this, we often implement custom patient flows that wil programatically tag\nepisodes to tagged lists. In those cases we will want to prevent users from manually adding or\nremoving the tags themselves. This can be easily accomplished via the  direct_add  property. When\nset to false, users will not be able to add the tag for this list.  class MyLockedDownList(TaggedPatientList):\n    tag = 'liaisonpatients'\n    direct_add = False  Access Control  As PatientLists are a  RestrictableFeature , Access control\nfor lists is set by overriding the  visible_to  classmethod. Your list will only be visible to\nthose users for whom this method returns  True .  For instance, we could define a Patient List that was only available to Django Superusers:  class SuperuserPatientList(PatientList):\n\n    @classmethod\n    def visible_to(klass, user):\n        return user.is_superuser", 
            "title": "OPAL Patient List views"
        }, 
        {
            "location": "/guides/discoverable/", 
            "text": "OPAL Discoverable Features\n\n\nOPAL makes extensive use of the case of discoverable features. These are pieces of\ncomposable functionality that can be implemented by any plugin or application,\nsimply by declaring a class with the appropriate fields and methods implemented. (Details\nof exactly which fields and methods vary by feature.)\n\n\nDefining Discoverable Features\n\n\nThe only thing required for a discoverable feature, is that it defines the name of\nthe module in which it should expect to find instances.\n\n\nfrom opal.core import discoverable\n\nclass MyFeature(discoverable.DiscoverableFeature):\n    module_name = 'myfeature'\n\n\n\nThis now gives us acces to various interfaces which come with the library. We can access\nall subclasses of \nMyFeature\n by calling \nMyFeature.list()\n - which will look through all\nDjango apps in our application, and look for a module named \nmyfeature.py\n. The \nlist()\n\nmethod then returns any subclasses of \nMyFeature\n.\n\n\nSlugs and Display Names\n\n\nWe often want to define human and machine readable strings to name our features. Display\nnames are intended for people - feel free to include spaces, numbers and puctuation. Slugs\nare intended for machines - so no spaces, numbers, hypens, periods or other punctuation. By\ndefault, if there is a display name and no explicit slug, we wil 'slugify' the display name.\n\n\nclass MyNameFeature(MyFeature):\n    display_name = 'Hello World'\n\nprint MyNameFeature.get_slug()\n# 'hello_world'\n\nclass MySlugFeature(MyFeature):\n    slug = 'this_is_a_slug'\n\nprint MySlugFeature.get_slug()\n# 'this_is_a_slug'\n\n\n\nRetrieving Subclasses\n\n\nOnce we define a \ndisplay_name\n or \nslug\n for sublasses of our feature, we can then fetch them via\nthe \nget()\n api.\n\n\nclass RedFeature(MyFeature):\n    slug = 'red_feature'\n\nMyFeature.get('red_feature') # -\n RedFeature\n\n\n\nSortable Features\n\n\nWe can make our feature sortable via an \norder\n property by including\n \ndiscoverable.SortableFeature\n as a parent class. This will ensure that \nMyFeature.list()\n\n respects the \n.order\n number of any subclass.\n\n\nclass MyFeature(discoverable.DiscoverableFeature,\n                 discoverable.SortableFeature):\n     module_name = 'myfeature'\n\nclass ThirdFeature(MyFeature):\n    order = 3\n\nclass FirstFeature(MyFeature):\n    order = 1\n\nclass SecondFeature(MyFeature):\n    order = 2\n\nfor f in MyFeature.list():\n    print f.order, f\n\n# \nclass '*.*.FirstFeature'\n, 1\n# \nclass '*.*.SecondFeature'\n, 2\n# \nclass '*.*.ThirdFeature'\n, 3\n\n\n\nRestrictable Features\n\n\nWe can ensure that only particular users can access a feature by including\n \ndiscoverable.RestrictableFeature\n as a parent class, and implementing the \nvisible_to\n\n classmethod on any restricted subclasses.\n\n\n class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature):\n     module_name = 'myfeature'\n\n\n\nFor instance, a feature that was only visible to superusers could be implemented like this:\n\n\n class SuperuserFeature(MyFeature):\n\n     @classmethod\n     def visible_to(klass, user):\n         return user.is_superuser\n\n\n\nValidating Features\n\n\nSometimes we wish to validate features so that we don't cause unintended consequences when\nwe implement subclasses of them. This is available via the \nis_valid\n classmethod. For instance,\nif we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was\ntrue, we could to this as follows:\n\n\nclass BombFeature(discoverable.DiscoverableFeature):\n    module_name = 'bombs'\n    blow_up = False\n\n    @classmethod\n    def is_valid(klass):\n        if klass.blow_up == True:\n            from opal.core.exceptions import InvalidDiscoverableFeatureError\n            raise InvalidDiscoverableFeatureError('BLOWING UP')\n\n\nclass Threat(BombFeature): pass\n# That's fine.\n\nclass Detonate(BombFeature):\n    blow_up = True\n# InvalidDiscoverableFeatureError: BLOWING UP\n\n\n\nAbstract Features\n\n\nSometimes we want to declare an abstract feature - something with reusable functionality\nthat isn't itself a new feature. We would rather not have our abstract feature show up\nwhen we \nlist()\n our base feature - because it's simply a programming convenience. This\nis made simple by using \nopal.utils.AbstractBase\n.\n\n\n    class A(discoverable.DiscoverableFeature):\n        module_name = 'a'\n\n    class AA(A, AbstractBase): pass\n\n    class B(A): pass\n\n    class C(AA): pass\n\n    class D(AA): pass\n\n\n    A.list()\n    # [B, C, D]", 
            "title": "Discoverable Features"
        }, 
        {
            "location": "/guides/discoverable/#opal-discoverable-features", 
            "text": "OPAL makes extensive use of the case of discoverable features. These are pieces of\ncomposable functionality that can be implemented by any plugin or application,\nsimply by declaring a class with the appropriate fields and methods implemented. (Details\nof exactly which fields and methods vary by feature.)  Defining Discoverable Features  The only thing required for a discoverable feature, is that it defines the name of\nthe module in which it should expect to find instances.  from opal.core import discoverable\n\nclass MyFeature(discoverable.DiscoverableFeature):\n    module_name = 'myfeature'  This now gives us acces to various interfaces which come with the library. We can access\nall subclasses of  MyFeature  by calling  MyFeature.list()  - which will look through all\nDjango apps in our application, and look for a module named  myfeature.py . The  list() \nmethod then returns any subclasses of  MyFeature .  Slugs and Display Names  We often want to define human and machine readable strings to name our features. Display\nnames are intended for people - feel free to include spaces, numbers and puctuation. Slugs\nare intended for machines - so no spaces, numbers, hypens, periods or other punctuation. By\ndefault, if there is a display name and no explicit slug, we wil 'slugify' the display name.  class MyNameFeature(MyFeature):\n    display_name = 'Hello World'\n\nprint MyNameFeature.get_slug()\n# 'hello_world'\n\nclass MySlugFeature(MyFeature):\n    slug = 'this_is_a_slug'\n\nprint MySlugFeature.get_slug()\n# 'this_is_a_slug'  Retrieving Subclasses  Once we define a  display_name  or  slug  for sublasses of our feature, we can then fetch them via\nthe  get()  api.  class RedFeature(MyFeature):\n    slug = 'red_feature'\n\nMyFeature.get('red_feature') # -  RedFeature  Sortable Features  We can make our feature sortable via an  order  property by including\n  discoverable.SortableFeature  as a parent class. This will ensure that  MyFeature.list() \n respects the  .order  number of any subclass.  class MyFeature(discoverable.DiscoverableFeature,\n                 discoverable.SortableFeature):\n     module_name = 'myfeature'\n\nclass ThirdFeature(MyFeature):\n    order = 3\n\nclass FirstFeature(MyFeature):\n    order = 1\n\nclass SecondFeature(MyFeature):\n    order = 2\n\nfor f in MyFeature.list():\n    print f.order, f\n\n#  class '*.*.FirstFeature' , 1\n#  class '*.*.SecondFeature' , 2\n#  class '*.*.ThirdFeature' , 3  Restrictable Features  We can ensure that only particular users can access a feature by including\n  discoverable.RestrictableFeature  as a parent class, and implementing the  visible_to \n classmethod on any restricted subclasses.   class MyFeature(discoverable.DiscoverableFeature, discoverable.RestrictableFeature):\n     module_name = 'myfeature'  For instance, a feature that was only visible to superusers could be implemented like this:   class SuperuserFeature(MyFeature):\n\n     @classmethod\n     def visible_to(klass, user):\n         return user.is_superuser  Validating Features  Sometimes we wish to validate features so that we don't cause unintended consequences when\nwe implement subclasses of them. This is available via the  is_valid  classmethod. For instance,\nif we wanted to implement a \"Bomb\" feature, which blew up every time the blow_up attribute was\ntrue, we could to this as follows:  class BombFeature(discoverable.DiscoverableFeature):\n    module_name = 'bombs'\n    blow_up = False\n\n    @classmethod\n    def is_valid(klass):\n        if klass.blow_up == True:\n            from opal.core.exceptions import InvalidDiscoverableFeatureError\n            raise InvalidDiscoverableFeatureError('BLOWING UP')\n\n\nclass Threat(BombFeature): pass\n# That's fine.\n\nclass Detonate(BombFeature):\n    blow_up = True\n# InvalidDiscoverableFeatureError: BLOWING UP  Abstract Features  Sometimes we want to declare an abstract feature - something with reusable functionality\nthat isn't itself a new feature. We would rather not have our abstract feature show up\nwhen we  list()  our base feature - because it's simply a programming convenience. This\nis made simple by using  opal.utils.AbstractBase .      class A(discoverable.DiscoverableFeature):\n        module_name = 'a'\n\n    class AA(A, AbstractBase): pass\n\n    class B(A): pass\n\n    class C(AA): pass\n\n    class D(AA): pass\n\n\n    A.list()\n    # [B, C, D]", 
            "title": "OPAL Discoverable Features"
        }, 
        {
            "location": "/guides/search/", 
            "text": "OPAL Search overview\n\n\nThe OPAL Search backend is switchable using the settings value OPAL_SEARCH_BACKEND.\n\n\nBy default it will do a database query.\n\n\nThe backend takes in a dictionary with the following fields\n\n\n{\n      \"queryType\": either \"Equals\" or \"Contains\",\n      \"field\": the label of the column that will be queried, e.g. Hospital Number,\n      \"query\": the value to be queried, e.g. \"1111\",\n      'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries\n      'column': the model to be queried e.g. 'demographics'\n}", 
            "title": "Search Overview"
        }, 
        {
            "location": "/guides/search/#opal-search-overview", 
            "text": "The OPAL Search backend is switchable using the settings value OPAL_SEARCH_BACKEND.  By default it will do a database query.  The backend takes in a dictionary with the following fields  {\n      \"queryType\": either \"Equals\" or \"Contains\",\n      \"field\": the label of the column that will be queried, e.g. Hospital Number,\n      \"query\": the value to be queried, e.g. \"1111\",\n      'combine': whether the query is 'and' or 'or' in conjunction with other dictionaries\n      'column': the model to be queried e.g. 'demographics'\n}", 
            "title": "OPAL Search overview"
        }, 
        {
            "location": "/reference/episode/", 
            "text": "opal.models.Episode\n\n\nThe \nopal.models.Episode\n class represents an episode of care for a patient. This can be either\nan inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic,\nor any other arbitrarially defined period of care.\n\n\nFields\n\n\nEpisode.category\n\n\nThe category of this episode - e.g. inpatient, outpatient et cetera.\nThis defaults to whatever is set on your application's subclass of\n\nopal.core.application.OpalApplication\n - which itseflf defaults to 'inpatient'.\n\n\nEpisode.patient\n\n\nA foreign key relationship to the patient for whom this episode concerns.\n\n\nEpisode.active\n\n\nA boolean to provide a quick lookup for whether this is an active or closed episode.\n\n\nEpisode.date_of_admission\n\n\nIf this is an inpatient episode, the date of admission.\n\n\nEpisode.discharge_date\n\n\nIf this is an inpatient episode, the date of discharge.\n\n\nEpisode.date_of_episode\n\n\nIf this is an episode that occurs on one date (like a clinic visit or telephone liaison), the\ndate of that event.\n\n\nEpisode.consistency_token\n\n\nA (automatically generated) hash of the above fields. This is used for detecting concurrent edits.\n\n\nMethods\n\n\nThe Episode model has the following methods:\n\n\nEpisode.to_dict\n\n\nReturn a dictionary of field value pairs for this episode\n\n\nepisode.to_dict(user)\n\n\n\nArguments:\n\n\n\n\nuser\n The User for whom we want to serialise this episode\n\n\n\n\nKeywords:\n\n\n\n\nshallow\n Boolean to indicate whether we want just this episode, or also a sorted set of\nprevious and subsequent episodes\n\n\n\n\nEpisode.get_tag_names\n\n\nArguments:\n\n\n\n\nuser\n The user for whom we want the tag names.\n\n\n\n\nReturn the current active tag names for this Episode as strings.\n\n\nepisode.get_tag_names(user)\n# ['mine', 'infectioncontrol']\n\n\n\nEpisode.set_tag_names\n\n\nArguments:\n\n\n\n\ntag_names\n The list of tags that we want to be active for this Episode.\n\n\nuser\n The user for whom we want the tag names.\n\n\n\n\nReturn the current active tag names for this Episode as strings.\n\n\nepisode.set_tag_names(['mine', 'infectioncontrol'], user)\n\n\n\nManager\n\n\nThe custom manager for Episodes has the following methods:\n\n\nEpisode.objects.serialised()\n\n\nReturn a set of serialised episodes.\n\n\nEpisode.objects.serialised(User, [episode, ...], historic_tags=False)\n\n\n\nArguments:\n\n\n\n\nuser\n The User for whom we want to serialise this episode\n\n\nepisodes\n An iterable of Episode instances\n\n\n\n\nKeywords:\n\n\n\n\nhistoric_tags\n A boolean to indicate whether the user desires historic or just current tags to\nbe serialised", 
            "title": "The Episode model"
        }, 
        {
            "location": "/reference/episode/#opalmodelsepisode", 
            "text": "The  opal.models.Episode  class represents an episode of care for a patient. This can be either\nan inpatient stay, an outpatient treatment, a telephone liaison, an appointment at a clinic,\nor any other arbitrarially defined period of care.  Fields  Episode.category  The category of this episode - e.g. inpatient, outpatient et cetera.\nThis defaults to whatever is set on your application's subclass of opal.core.application.OpalApplication  - which itseflf defaults to 'inpatient'.  Episode.patient  A foreign key relationship to the patient for whom this episode concerns.  Episode.active  A boolean to provide a quick lookup for whether this is an active or closed episode.  Episode.date_of_admission  If this is an inpatient episode, the date of admission.  Episode.discharge_date  If this is an inpatient episode, the date of discharge.  Episode.date_of_episode  If this is an episode that occurs on one date (like a clinic visit or telephone liaison), the\ndate of that event.  Episode.consistency_token  A (automatically generated) hash of the above fields. This is used for detecting concurrent edits.  Methods  The Episode model has the following methods:  Episode.to_dict  Return a dictionary of field value pairs for this episode  episode.to_dict(user)  Arguments:   user  The User for whom we want to serialise this episode   Keywords:   shallow  Boolean to indicate whether we want just this episode, or also a sorted set of\nprevious and subsequent episodes   Episode.get_tag_names  Arguments:   user  The user for whom we want the tag names.   Return the current active tag names for this Episode as strings.  episode.get_tag_names(user)\n# ['mine', 'infectioncontrol']  Episode.set_tag_names  Arguments:   tag_names  The list of tags that we want to be active for this Episode.  user  The user for whom we want the tag names.   Return the current active tag names for this Episode as strings.  episode.set_tag_names(['mine', 'infectioncontrol'], user)  Manager  The custom manager for Episodes has the following methods:  Episode.objects.serialised()  Return a set of serialised episodes.  Episode.objects.serialised(User, [episode, ...], historic_tags=False)  Arguments:   user  The User for whom we want to serialise this episode  episodes  An iterable of Episode instances   Keywords:   historic_tags  A boolean to indicate whether the user desires historic or just current tags to\nbe serialised", 
            "title": "opal.models.Episode"
        }, 
        {
            "location": "/reference/episode_categories/", 
            "text": "opal.core.episodes\n\n\nEpisodeCategory\n\n\nOPAL Episodes have an associated category. These categories are implemented as subclasses\nof \nopal.core.episodes.EpisodeCategory\n. This class is an OPAL \nDiscoverableFeature\n\nand thus inherits all of the core Discoverable API.\n\n\nThe category of any episode can be accessed as the \n.category\n property of any \nEpisode\n instance.\n\n\nProperties\n\n\nEpisodeCategory.detail_template\n\n\nThis is the template used within the \nPatient Detail View\n to display\ninformation about episodes of this category.\n\n\nEpisodeCategory.start\n\n\nReturns the Start date of this episode type.\n\n\nEpisodeCategory.stop\n\n\nReturns the Stop date of this episode type\n\n\nInpatientEpisode\n\n\nThis is the defualt EpisodeCategory imlpementation - applications started with OPAL's scaffolding\nscripts will use this as the \nOpalApplication.default_episode_category\n. It sets the detail template to\n\ndetail/inpatient.html", 
            "title": "Episode Categories"
        }, 
        {
            "location": "/reference/episode_categories/#opalcoreepisodes", 
            "text": "", 
            "title": "opal.core.episodes"
        }, 
        {
            "location": "/reference/episode_categories/#episodecategory", 
            "text": "OPAL Episodes have an associated category. These categories are implemented as subclasses\nof  opal.core.episodes.EpisodeCategory . This class is an OPAL  DiscoverableFeature \nand thus inherits all of the core Discoverable API.  The category of any episode can be accessed as the  .category  property of any  Episode  instance.  Properties  EpisodeCategory.detail_template  This is the template used within the  Patient Detail View  to display\ninformation about episodes of this category.  EpisodeCategory.start  Returns the Start date of this episode type.  EpisodeCategory.stop  Returns the Stop date of this episode type", 
            "title": "EpisodeCategory"
        }, 
        {
            "location": "/reference/episode_categories/#inpatientepisode", 
            "text": "This is the defualt EpisodeCategory imlpementation - applications started with OPAL's scaffolding\nscripts will use this as the  OpalApplication.default_episode_category . It sets the detail template to detail/inpatient.html", 
            "title": "InpatientEpisode"
        }, 
        {
            "location": "/reference/patient/", 
            "text": "opal.models.Patient\n\n\nmethods\n\n\ncreate_episode\n\n\nReturns a new \nEpisode\n for this patient.\n\n\nto_dict\n\n\nReturn the dictionary representation of this patient - suitable for serialization.\n\n\npatient.to_dict(user)\n\n\n\nbulk_update\n\n\nCreate or update many subrecords in one go, from a serialised dictionary of data.\n\n\nPass in a dictionary of subrecords you want to update, as well as an episode if one exists.\nThis method will create all the subrecords and implicitly create a new episode if required.\n\n\nThis API will execute all create/update operations as an atomic transaction.\n\n\nFor example the following will create a patient:\n\n\npatient = Patient()\npatient.bulk_update(\n  {\n    \"demographics\": \"hospital_number\": \"1231212\",\n    \"allergies\": [\n        {\"drug\": \"penicillin\"},\n        {\"drug\": \"aspirin\"},\n    ]\n  },\n  user\n)", 
            "title": "Patient"
        }, 
        {
            "location": "/reference/patient/#opalmodelspatient", 
            "text": "methods  create_episode  Returns a new  Episode  for this patient.  to_dict  Return the dictionary representation of this patient - suitable for serialization.  patient.to_dict(user)  bulk_update  Create or update many subrecords in one go, from a serialised dictionary of data.  Pass in a dictionary of subrecords you want to update, as well as an episode if one exists.\nThis method will create all the subrecords and implicitly create a new episode if required.  This API will execute all create/update operations as an atomic transaction.  For example the following will create a patient:  patient = Patient()\npatient.bulk_update(\n  {\n    \"demographics\": \"hospital_number\": \"1231212\",\n    \"allergies\": [\n        {\"drug\": \"penicillin\"},\n        {\"drug\": \"aspirin\"},\n    ]\n  },\n  user\n)", 
            "title": "opal.models.Patient"
        }, 
        {
            "location": "/reference/subrecords/", 
            "text": "OPAL Subrecords\n\n\nOPAL Subrecords are models that relate to either Patients or Episodes, and inherit from\nbase classes \nopal.models.PatientSubrecord\n or \nopal.models.EpisodeSubrecord\n\n\nProperties\n\n\nSubrecord._angular_service\n\n\nName of the Angular service you would like to use to customise the initialization of this\nsubrecord in the javascript layer.\n\n\n\nclass Demographics(PatientSubrecord):\n    _angular_service = 'Demographics'\n\n\n\n\nSubrecord._icon\n\n\nString that provides the name of the icon to use for forms, column headings etc.\n\n\nclass Demographics(PatientSubrecord):\n    _icon = 'fa fa-user'\n\n\n\nSubrecord._is_singleton\n\n\nBoolean that determines whether this subrecord is a singleton.\nThere may only be one of each singleton Subrecord, which is created whth the parent.\n\n\nclass Demographics(PatientSubrecord):\n    _is_singleton = True\n\n\n\nFor this case, when a \nPatient\n is created, an empty \nDemographics\n instance will\nautomatically be created.\n\n\nSubrecord._list_limit\n\n\nInteger to indicate the maximum number of entries to display in list view for this\nmodel. Useful for record types where many entries will accrue, or where display is\nparticularly verbose.\n\n\nclass BloodPressureReading(EpisodeSubrecord):\n    _list_limit = 3\n\n\n\nSubrecord._modal\n\n\nString to indicate a non-default modal size to be used for editing this \nSubrecord\n.\nValid options are: 'lg', 'sm'. Typically used for complex forms or the display of\nadditional contextually sensitive information when editing or entering data.\n\n\nclass Antimicrobial(EpisodeSubrecord):\n    _modal = 'lg'\n\n\n\nSubrecord._sort\n\n\nName of the field by which we want to sort these records when displaying.\n\n\nclass Antimicrobial(EpisodeSubrecord):\n    _sort = 'start_date'\n\n\n\nSubrecord._title\n\n\nString we would like to use for user-facing display of this record type.\n\n\nclass Antimicrobial(EpisodeSubrecord):\n    _title = 'Abx'\n\n\n\nSubrecord._clonable\n\n\nA Boolean that is True by default used by \nopal.views.EpisodeCopyToCategoryView\n\nto determine if instances of this record should be copied across.\n\n\nclass Antimicrobial(EpisodeSubrecord):\n    _clonable = 'False'\n\n\n\nSubrecord._exclude_from_extract\n\n\nBoolean to specify that this subrecord should be excluded from any standard data extract.\nThis implicitly defaults to False.\n\n\nclass Antimicrobial(EpisodeSubrecord):\n    _exclude_from_extract = 'Abx'\n\n\n\nSubrecord.pid_fields\n\n\nAn iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID).\n\n\nThis is used when creating data extracts to exclude PID from e.g. CSV downloads.\n\n\nMethods\n\n\nSubrecord.get_display_template()\n\n\nClassmethod to locate the active display template for our record.\n\n\nReturns the name of the template or None.\n\n\nKeywords:\n\n\n\n\nepisode_type\n Optional episode type string to check for form customisations\n\n\npatient_list\n Optional patient list slug string to check for form customisations\n\n\n\n\nSubrecord.get_form_template()\n\n\nClassmethod to locate the active template for our record. Returns the name of a template or None.\n\n\nKeywords:\n\n\n\n\nepisode_type\n Optional episode type string to check for form customisations\n\n\npatient_list\n Optional patient list slug string to check for form customisations\n\n\n\n\nSubrecord.get_modal_template()\n\n\nClassmethod to locate the active template for our record. Returns the name of a template or None.\n\n\nKeywords:\n\n\n\n\nepisode_type\n Optional episode type string to check for modal customisations\n\n\npatient_list\n Optional patient list slug string to check for modal customisations\n\n\n\n\nSubrecord.get_modal_footer_template\n\n\nClassmethod to add a custom footer to a modal, used for example to denote if\nthe data from a model has been sourced from an external source\n\n\nSubrecord.update_from_dict()\n\n\nAn instance method that will update a model with a dictionary. This method is used\nto provides a hook for changing the way a subrecord handles being updated from serialised\ndata.\n\n\nFor example on a new allergy\n    allergy.update_from_dict({\"drug\": \"penicillin\"})\n\n\nwill update the allergy to have the correct drug\n\n\nSubrecord.bulk_update_from_dicts()\n\n\nA Classmethod to allow the creation of multiple objects.\n\n\nTakes in the parent model - an episode\nfor EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates\nover all the subrecords, adds in the parent relationship and calls update_from_dict\n\n\nSubrecord Mixins\n\n\nTrackedModel\n\n\nA Tracked Model automatically has created, created_by, updated, updated_by and\nthese are only updated when used via the api\n\n\nExternallySourcedModel\n\n\nOften we want data to be sourced from external systems, this mixin adds in the\nfields external_system and external_identifier to allow us to track where\nthey come from and how they are referenced by that system.\n\n\nThese fields are then often used in forms to make the data read only", 
            "title": "Subrecords"
        }, 
        {
            "location": "/reference/subrecords/#opal-subrecords", 
            "text": "OPAL Subrecords are models that relate to either Patients or Episodes, and inherit from\nbase classes  opal.models.PatientSubrecord  or  opal.models.EpisodeSubrecord  Properties  Subrecord._angular_service  Name of the Angular service you would like to use to customise the initialization of this\nsubrecord in the javascript layer.  \nclass Demographics(PatientSubrecord):\n    _angular_service = 'Demographics'  Subrecord._icon  String that provides the name of the icon to use for forms, column headings etc.  class Demographics(PatientSubrecord):\n    _icon = 'fa fa-user'  Subrecord._is_singleton  Boolean that determines whether this subrecord is a singleton.\nThere may only be one of each singleton Subrecord, which is created whth the parent.  class Demographics(PatientSubrecord):\n    _is_singleton = True  For this case, when a  Patient  is created, an empty  Demographics  instance will\nautomatically be created.  Subrecord._list_limit  Integer to indicate the maximum number of entries to display in list view for this\nmodel. Useful for record types where many entries will accrue, or where display is\nparticularly verbose.  class BloodPressureReading(EpisodeSubrecord):\n    _list_limit = 3  Subrecord._modal  String to indicate a non-default modal size to be used for editing this  Subrecord .\nValid options are: 'lg', 'sm'. Typically used for complex forms or the display of\nadditional contextually sensitive information when editing or entering data.  class Antimicrobial(EpisodeSubrecord):\n    _modal = 'lg'  Subrecord._sort  Name of the field by which we want to sort these records when displaying.  class Antimicrobial(EpisodeSubrecord):\n    _sort = 'start_date'  Subrecord._title  String we would like to use for user-facing display of this record type.  class Antimicrobial(EpisodeSubrecord):\n    _title = 'Abx'  Subrecord._clonable  A Boolean that is True by default used by  opal.views.EpisodeCopyToCategoryView \nto determine if instances of this record should be copied across.  class Antimicrobial(EpisodeSubrecord):\n    _clonable = 'False'  Subrecord._exclude_from_extract  Boolean to specify that this subrecord should be excluded from any standard data extract.\nThis implicitly defaults to False.  class Antimicrobial(EpisodeSubrecord):\n    _exclude_from_extract = 'Abx'  Subrecord.pid_fields  An iterable of strings that correspond to fieldnames that contain Patient Identifiable Data (PID).  This is used when creating data extracts to exclude PID from e.g. CSV downloads.  Methods  Subrecord.get_display_template()  Classmethod to locate the active display template for our record.  Returns the name of the template or None.  Keywords:   episode_type  Optional episode type string to check for form customisations  patient_list  Optional patient list slug string to check for form customisations   Subrecord.get_form_template()  Classmethod to locate the active template for our record. Returns the name of a template or None.  Keywords:   episode_type  Optional episode type string to check for form customisations  patient_list  Optional patient list slug string to check for form customisations   Subrecord.get_modal_template()  Classmethod to locate the active template for our record. Returns the name of a template or None.  Keywords:   episode_type  Optional episode type string to check for modal customisations  patient_list  Optional patient list slug string to check for modal customisations   Subrecord.get_modal_footer_template  Classmethod to add a custom footer to a modal, used for example to denote if\nthe data from a model has been sourced from an external source  Subrecord.update_from_dict()  An instance method that will update a model with a dictionary. This method is used\nto provides a hook for changing the way a subrecord handles being updated from serialised\ndata.  For example on a new allergy\n    allergy.update_from_dict({\"drug\": \"penicillin\"})  will update the allergy to have the correct drug  Subrecord.bulk_update_from_dicts()  A Classmethod to allow the creation of multiple objects.  Takes in the parent model - an episode\nfor EpisodeSubrecords a patient for PatientSubrecords. Under the covers it iterates\nover all the subrecords, adds in the parent relationship and calls update_from_dict  Subrecord Mixins  TrackedModel  A Tracked Model automatically has created, created_by, updated, updated_by and\nthese are only updated when used via the api  ExternallySourcedModel  Often we want data to be sourced from external systems, this mixin adds in the\nfields external_system and external_identifier to allow us to track where\nthey come from and how they are referenced by that system.  These fields are then often used in forms to make the data read only", 
            "title": "OPAL Subrecords"
        }, 
        {
            "location": "/reference/opal_application/", 
            "text": "opal.core.application\n\n\nOpalApplication\n\n\nThe base class for your main application entrypoints is opal.core.application.OpalApplication.\n\n\nYou must subclass this in order for OPAL to discover your application.\n\n\nIf you started your OPAL project via \n$ opal startproject yourproject\n then this will have been\ngenerated for you, and located in \nyourproject/yourproject/__init__.py\n\n\nProperties\n\n\nProperties available on an OpalApplication:\n\n\nOpalApplication.actions\n\n\nOpalApplication.default_episode_category\n\n\nThe default category is 'Inpatient', but can be overridden in the\n\nOpalApplication\n subclass for your implementation.\n\n\nOpalApplication.javascripts\n\n\nA list of javascripts that our application would like to include. These should be strings\nrepresenting paths ready for staticfiles. Defaults to \n[]\n.\n\n\nclass MyApplication(OpalApplication):\n    javascripts = ['js/one.js']\n\n\n\n\nOpalApplication.menuitems\n\n\nA list of items to add to the top level menu\n\n\nOpalApplication.styles\n\n\nA list of stylesheets that our application would like to include. These should be strings\nrepresenting paths ready for staticfiles. Defaults to \n[]\n. These styles are included after\nthe default OPAL styles.\n\n\nclass MyApplication(OpalApplication):\n    styles = ['css/app.css']\n\n\n\n\nClassmethods\n\n\nClassmethod API for OpalApplication instances:\n\n\nOpalApplication.get_core_javascripts(namespace)\n\n\nReturn a list of the core javascript files specified within a given namespace. These wil be\nrelative paths ready for staticfiles.\n\n\napplication.get_core_javascripts('opal.utils')\n# -\n ['js/opal/utils.js', ...]\n\n\n\n\nOpalApplication.get_javascripts()\n\n\nReturn a list of the application's javasctipts as paths to them ready for staticfiles.\nDefaults to returning the \nOpalApplication.javascripts\n property.\n\n\napplication.get_javascripts()\n# -\n ['js/one.js', 'js/two.js', ...]\n\n\n\n\nOpalApplication.get_menu_items()\n\n\nOpalApplication.get_styles()\n\n\nReturn a list of the application's stylesheets as paths to them ready for staticfiles.\nDefaults to returning the contents of \nOpalApplication.styles\n.\n\n\napplication.get_styles()\n# -\n ['css/app.css', ...]", 
            "title": "OpalApplication"
        }, 
        {
            "location": "/reference/opal_application/#opalcoreapplication", 
            "text": "", 
            "title": "opal.core.application"
        }, 
        {
            "location": "/reference/opal_application/#opalapplication", 
            "text": "The base class for your main application entrypoints is opal.core.application.OpalApplication.  You must subclass this in order for OPAL to discover your application.  If you started your OPAL project via  $ opal startproject yourproject  then this will have been\ngenerated for you, and located in  yourproject/yourproject/__init__.py  Properties  Properties available on an OpalApplication:  OpalApplication.actions  OpalApplication.default_episode_category  The default category is 'Inpatient', but can be overridden in the OpalApplication  subclass for your implementation.  OpalApplication.javascripts  A list of javascripts that our application would like to include. These should be strings\nrepresenting paths ready for staticfiles. Defaults to  [] .  class MyApplication(OpalApplication):\n    javascripts = ['js/one.js']  OpalApplication.menuitems  A list of items to add to the top level menu  OpalApplication.styles  A list of stylesheets that our application would like to include. These should be strings\nrepresenting paths ready for staticfiles. Defaults to  [] . These styles are included after\nthe default OPAL styles.  class MyApplication(OpalApplication):\n    styles = ['css/app.css']  Classmethods  Classmethod API for OpalApplication instances:  OpalApplication.get_core_javascripts(namespace)  Return a list of the core javascript files specified within a given namespace. These wil be\nrelative paths ready for staticfiles.  application.get_core_javascripts('opal.utils')\n# -  ['js/opal/utils.js', ...]  OpalApplication.get_javascripts()  Return a list of the application's javasctipts as paths to them ready for staticfiles.\nDefaults to returning the  OpalApplication.javascripts  property.  application.get_javascripts()\n# -  ['js/one.js', 'js/two.js', ...]  OpalApplication.get_menu_items()  OpalApplication.get_styles()  Return a list of the application's stylesheets as paths to them ready for staticfiles.\nDefaults to returning the contents of  OpalApplication.styles .  application.get_styles()\n# -  ['css/app.css', ...]", 
            "title": "OpalApplication"
        }, 
        {
            "location": "/reference/episode_service/", 
            "text": "The Episode service\n\n\nThe \nEpisode\n service in \nopal.services\n provides us with core functionality related\nto interacting with episodes in the client.\n\n\nConstructor\n\n\nThe Episode service is instantiated with the Episode data that comes back from the\nEpisode JSON API.\n\n\nvar episode = new Episode(json_data);\n\n\n\nMethods\n\n\nEpisode.getTags\n\n\nReturn a list of the current tags this episode has as strings.\n\n\nepisode.getTags();\n// ['mine', 'infectioncontrol']\n\n\n\nEpisode.hasTag\n\n\nPredicate function that determines whether the episode is tagged with a given tag.\n\n\nArguments:\n\n\n\n\ntag\n: The tag you are interested in.\n\n\n\n\nEpisode.newItem\n\n\nInstantiate a new subrecord for this episode of a given type.\n\n\nArguments: \n\n\n\n\nrecordName\n: The name of the type of record you want to instantiate.\n\n\n\n\nExample usage: \n\n\nepisode.newItem('diagnosis');\n// item (an Item() instance.", 
            "title": "Episode service"
        }, 
        {
            "location": "/reference/episode_service/#the-episode-service", 
            "text": "The  Episode  service in  opal.services  provides us with core functionality related\nto interacting with episodes in the client.  Constructor  The Episode service is instantiated with the Episode data that comes back from the\nEpisode JSON API.  var episode = new Episode(json_data);  Methods  Episode.getTags  Return a list of the current tags this episode has as strings.  episode.getTags();\n// ['mine', 'infectioncontrol']  Episode.hasTag  Predicate function that determines whether the episode is tagged with a given tag.  Arguments:   tag : The tag you are interested in.   Episode.newItem  Instantiate a new subrecord for this episode of a given type.  Arguments:    recordName : The name of the type of record you want to instantiate.   Example usage:   episode.newItem('diagnosis');\n// item (an Item() instance.", 
            "title": "The Episode service"
        }, 
        {
            "location": "/reference/item_service/", 
            "text": "The Item service\n\n\nThe \nItem\n service in \nopal.services\n provides us with core functionality related\nto interacting with subrecord in the client.\n\n\nMethods\n\n\nItem.makeCopy\n\n\nReturns a clone of the editable fields + consistency token so that\nwe can then update them in isolation elsewhere.\n\n\nItem.save\n\n\nSaves attributes to the server.\n\n\nitem.save(data_to_save);\n\n\n\nItem.formController\n\n\nThe Angular controller used by the modal that is opened when you edit this item to allow custom logic.\n\n\nDefaults to 'EditItemCtrl';", 
            "title": "Item service"
        }, 
        {
            "location": "/reference/item_service/#the-item-service", 
            "text": "The  Item  service in  opal.services  provides us with core functionality related\nto interacting with subrecord in the client.  Methods  Item.makeCopy  Returns a clone of the editable fields + consistency token so that\nwe can then update them in isolation elsewhere.  Item.save  Saves attributes to the server.  item.save(data_to_save);  Item.formController  The Angular controller used by the modal that is opened when you edit this item to allow custom logic.  Defaults to 'EditItemCtrl';", 
            "title": "The Item service"
        }, 
        {
            "location": "/reference/patient_summary_service/", 
            "text": "The PatientSummary service\n\n\nThe \nPatientSummary\n service in \nopal.services\n provides us with core\nfunctionality related to interacting with patient search results in the client.\n\n\nConstructor\n\n\nThe PatientSummary service is instantiated with the Patient search result data\nthat comes back from the Patient search JSON API.\n\n\nvar patient_summary = new PatientSummary(json_data);", 
            "title": "Patient summary service"
        }, 
        {
            "location": "/reference/patient_summary_service/#the-patientsummary-service", 
            "text": "The  PatientSummary  service in  opal.services  provides us with core\nfunctionality related to interacting with patient search results in the client.  Constructor  The PatientSummary service is instantiated with the Patient search result data\nthat comes back from the Patient search JSON API.  var patient_summary = new PatientSummary(json_data);", 
            "title": "The PatientSummary service"
        }, 
        {
            "location": "/reference/form_templatetags/", 
            "text": "Form Helpers\n\n\nOPAL comes with a selection of templatetags that can help you with the\nrepetitive task of generating Bootstrap and OPAL compatible markup for\nyour forms.\n\n\n{% checkbox ... %}\n\n\nGenerates a checkbox\n\n\nKeywords:\n\n\n\n\nfield\n a string of the model name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% checkbox field=\"DogOwner.dog\" %}\n\n\nlabel\n The Label with which to describe this field\n\n\nmodel\n The model which we are editing (This is a string that references an in-scope Angular variable)\n\n\ndisabled\n If this exists, we use this as the expression for the ng-disabled directive\n\n\n\n\n{% datepicker ... %}\n\n\nGenerates a datepicker\n\n\nKeywords:\n\n\n\n\nfield\n a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% datepicker field=\"DogOwner.dog\" %}\n\n\nlabel\n The Label with which to describe this field\n\n\nmodel\n The model which we are editing (This is a string that references an in-scope Angular variable)\n\n\nshow\n  A string that contains an Angular expression for the ng-show directive\n\n\nhide\n  A string that contains an Angular expression for the ng-hide directive\n\n\nrequired\n Label to show when we're required\n\n\nmindate\n Expression to use to set the minimum possible date\n\n\n\n\n{% input ... %}\n\n\nGenerates an Input. If you pass a field, the tag will infer the label, model and lookuplist by introspecting the relevant subrecord model.\n\n\n{% input field=\"allergies.drug\" %}\n\n\n\nKeywords:\n\n\n\n\nfield\n a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% input field=\"DogOwner.dog\" %}\n\n\nlabel\n The Label with which to describe this field\n\n\nmodel\n The model which we are editing (This is a string that references an in-scope Angular variable)\n\n\nshow\n  A string that contains an Angular expression for the ng-show directive\n\n\nhide\n  A string that contains an Angular expression for the ng-hide directive\n\n\nlookuplist\n an Angular expression that evaluates to an array containing the lookuplist values\n\n\nrequired\n Label to show when we're required\n\n\nenter\n expression to evaluate if the user presses return when in this input\n\n\nmaxlength\n maximum number of characters for this input. Will render the form invalid and display help text if exceeded.\n\n\nstatic\n an Angular expression that will swap the display to be a static input if it evaluates to \ntrue\n\n\n\n\n{% radio ... %}\n\n\nGenerates an inline radio input\n\n\nKeywords:\n\n\n\n\nfield\n a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %}\n\n\nlabel\n The Label with which to describe this input\n\n\nmodel\n The model which we are editing (This is a string that references an in-scope Angular variable)\n\n\nshow\n  A string that contains an Angular expression for the ng-show directive\n\n\nhide\n  A string that contains an Angular expression for the ng-hide directive\n\n\nlookuplist\n an Angular expression that evaluates to an array containing the radio values\n\n\n\n\n{% select ... %}\n\n\nGenerates an inline select input\n\n\nKeywords:\n\n\n\n\nfield\n a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %}\n\n\nlabel\n The Label with which to describe this input\n\n\nmodel\n The model which we are editing (This is a string that references an in-scope Angular variable)\n\n\nshow\n  A string that contains an Angular expression for the ng-show directive\n\n\nhide\n  A string that contains an Angular expression for the ng-hide directive\n\n\nlookuplist\n an Angular expression that evaluates to an array containing the radio values\n\n\nother\n A boolean parameter that if true, provides a free text option when 'Other' is selected\n\n\nhelp\n a template to use as the contents of a help popover\n\n\nstatic\n an Angular expression that will swap the display to be a static input if it evaluates to \ntrue\n\n*\n\n\n\n\n{% textarea ... %}\n\n\nGenerates an inline textarea input\n\n\nKeywords:\n\n\n\n\nfield\n a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %}\n\n\nlabel\n The Label with which to describe this input\n\n\nmodel\n The model which we are editing (This is a string that references an in-scope Angular variable)\n\n\nshow\n  A string that contains an Angular expression for the ng-show directive\n\n\nhide\n  A string that contains an Angular expression for the ng-hide directive\n\n\n\n\n{% static ... %}\n\n\nGenerates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles).\n\n\nTakes one positional argument, a string representing the subrecord field path.\n\n\n{% static \"Demographics.name\" %}\n\n!-- Renders as --\n\n\ndiv class=\"form-group\"\n\n  \nlabel class=\"control-label col-sm-3\"\n\n    Name\n  \n/label\n\n  \np class=\"form-control-static col-sm-8\"\n\n    [[ editing.demographics.name ]]\n  \n/p\n\n\n/div\n\n\n\n\n{% icon \"icon-name\" %}\n\n\nRenders a Bootstrap style Icon tag.\nIf the icon starts with \nfa\n or \nglyphicon\n then we will insert the preceding \nfa\n.\n\n\n{% icon \"fa-user-md\" %}\n\ni class=\"fa fa-user-md\"\n/i\n\n\n{% icon \"cusom-icon\"}\n\ni class=\"custom-icon\"\n/i", 
            "title": "Form helpers"
        }, 
        {
            "location": "/reference/form_templatetags/#form-helpers", 
            "text": "OPAL comes with a selection of templatetags that can help you with the\nrepetitive task of generating Bootstrap and OPAL compatible markup for\nyour forms.  {% checkbox ... %}  Generates a checkbox  Keywords:   field  a string of the model name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% checkbox field=\"DogOwner.dog\" %}  label  The Label with which to describe this field  model  The model which we are editing (This is a string that references an in-scope Angular variable)  disabled  If this exists, we use this as the expression for the ng-disabled directive   {% datepicker ... %}  Generates a datepicker  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% datepicker field=\"DogOwner.dog\" %}  label  The Label with which to describe this field  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  required  Label to show when we're required  mindate  Expression to use to set the minimum possible date   {% input ... %}  Generates an Input. If you pass a field, the tag will infer the label, model and lookuplist by introspecting the relevant subrecord model.  {% input field=\"allergies.drug\" %}  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% input field=\"DogOwner.dog\" %}  label  The Label with which to describe this field  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  lookuplist  an Angular expression that evaluates to an array containing the lookuplist values  required  Label to show when we're required  enter  expression to evaluate if the user presses return when in this input  maxlength  maximum number of characters for this input. Will render the form invalid and display help text if exceeded.  static  an Angular expression that will swap the display to be a static input if it evaluates to  true   {% radio ... %}  Generates an inline radio input  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %}  label  The Label with which to describe this input  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  lookuplist  an Angular expression that evaluates to an array containing the radio values   {% select ... %}  Generates an inline select input  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %}  label  The Label with which to describe this input  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  lookuplist  an Angular expression that evaluates to an array containing the radio values  other  A boolean parameter that if true, provides a free text option when 'Other' is selected  help  a template to use as the contents of a help popover  static  an Angular expression that will swap the display to be a static input if it evaluates to  true \n*   {% textarea ... %}  Generates an inline textarea input  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %}  label  The Label with which to describe this input  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive   {% static ... %}  Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles).  Takes one positional argument, a string representing the subrecord field path.  {% static \"Demographics.name\" %} !-- Renders as --  div class=\"form-group\" \n   label class=\"control-label col-sm-3\" \n    Name\n   /label \n   p class=\"form-control-static col-sm-8\" \n    [[ editing.demographics.name ]]\n   /p  /div   {% icon \"icon-name\" %}  Renders a Bootstrap style Icon tag.\nIf the icon starts with  fa  or  glyphicon  then we will insert the preceding  fa .  {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i \n\n{% icon \"cusom-icon\"} i class=\"custom-icon\" /i", 
            "title": "Form Helpers"
        }, 
        {
<<<<<<< HEAD
=======
            "location": "/reference/form_templatetags/#checkbox", 
            "text": "Generates a checkbox  Keywords:   field  a string of the model name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% checkbox field=\"DogOwner.dog\" %}  label  The Label with which to describe this field  model  The model which we are editing (This is a string that references an in-scope Angular variable)  disabled  If this exists, we use this as the expression for the ng-disabled directive", 
            "title": "{% checkbox ... %}"
        }, 
        {
            "location": "/reference/form_templatetags/#datepicker", 
            "text": "Generates a datepicker  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% datepicker field=\"DogOwner.dog\" %}  label  The Label with which to describe this field  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  required  Label to show when we're required  mindate  Expression to use to set the minimum possible date", 
            "title": "{% datepicker ... %}"
        }, 
        {
            "location": "/reference/form_templatetags/#input", 
            "text": "Generates an Input. If you pass a field, the tag will infer the label, model and lookuplist by introspecting the relevant subrecord model.  {% input field=\"allergies.drug\" %}  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% input field=\"DogOwner.dog\" %}  label  The Label with which to describe this field  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  lookuplist  an Angular expression that evaluates to an array containing the lookuplist values  required  Label to show when we're required  enter  expression to evaluate if the user presses return when in this input  maxlength  maximum number of characters for this input. Will render the form invalid and display help text if exceeded.  static  an Angular expression that will swap the display to be a static input if it evaluates to  true", 
            "title": "{% input ... %}"
        }, 
        {
            "location": "/reference/form_templatetags/#radio", 
            "text": "Generates an inline radio input  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% radio field=\"DogOwner.dog\" %}  label  The Label with which to describe this input  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  lookuplist  an Angular expression that evaluates to an array containing the radio values", 
            "title": "{% radio ... %}"
        }, 
        {
            "location": "/reference/form_templatetags/#select", 
            "text": "Generates an inline select input  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% select field=\"DogOwner.dog\" %}  label  The Label with which to describe this input  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive  lookuplist  an Angular expression that evaluates to an array containing the radio values  other  A boolean parameter that if true, provides a free text option when 'Other' is selected  help  a template to use as the contents of a help popover  static  an Angular expression that will swap the display to be a static input if it evaluates to  true \n*", 
            "title": "{% select ... %}"
        }, 
        {
            "location": "/reference/form_templatetags/#textarea", 
            "text": "Generates an inline textarea input  Keywords:   field  a string of the models api name '.' field from this it calculates the label, model and will infer the lookuplist if required. For example {% textarea field=\"DogOwner.dog\" %}  label  The Label with which to describe this input  model  The model which we are editing (This is a string that references an in-scope Angular variable)  show   A string that contains an Angular expression for the ng-show directive  hide   A string that contains an Angular expression for the ng-hide directive", 
            "title": "{% textarea ... %}"
        }, 
        {
            "location": "/reference/form_templatetags/#static", 
            "text": "Generates a bootstrap Static div (for displaying data from fields as uneditable but formatted nicely with appropriate styles).  Takes one positional argument, a string representing the subrecord field path.  {% static \"Demographics.name\" %} !-- Renders as --  div class=\"form-group\" \n   label class=\"control-label col-sm-3\" \n    Name\n   /label \n   p class=\"form-control-static col-sm-8\" \n    [[ editing.demographics.name ]]\n   /p  /div", 
            "title": "{% static ... %}"
        }, 
        {
            "location": "/reference/form_templatetags/#icon-icon-name", 
            "text": "Renders a Bootstrap style Icon tag.\nIf the icon starts with  fa  or  glyphicon  then we will insert the preceding  fa .  {% icon \"fa-user-md\" %} i class=\"fa fa-user-md\" /i \n\n{% icon \"cusom-icon\"} i class=\"custom-icon\" /i", 
            "title": "{% icon \"icon-name\" %}"
        }, 
        {
>>>>>>> gh-pages
            "location": "/reference/panels_templatetags/", 
            "text": "Panel helpers\n\n\nOPAL comes with a selection of templatetags for rendering OPAL panels\nfor a given subrecord. These panels also allow the user to\nsee instances of the model against the current value of \nepisode\n in\nAngular \n$scope\n. The user can also create new\ninstances of the given model, as well as editing any existing ones.\n\n\n{% record_panel ... %}\n\n\nRender a panel for a given record that will allow the user to view, create, update and delete instances.\n\n\nThe record panel template expects the relevant Angular \n$scope\n to have \nnewNamedItem(name, index)\n,\n\neditNamedItem(name, index)\n and \ndeleteItem(name, index)\n methods implemented. Default\nimplementations of these are available from the \nEpisodeDetailMixin\n.\n\n\n{% load panels %}\n{% record_panel Diagnosis %}\n\n\n\nKeywords:\n\n\n\n\nmodel\n: The model we want to render our panel for\n\n\ntitle\n: The display title for this panel\n\n\ndetail_template\n: The display template to use. Defaults to Subrecord.get_detail_template()\n\n\neditable\n: Whether this panel should allow editing. Defaults to True.\n\n\nangular_filter\n: An Angular expression that will be evaluated to decide whether to show each item\n\n\nnoentries\n: A string to render if there are no instances of \nmodel\n for the current episode\n\n\nonly_display_if_exists\n: Boolean defaulting to False. If true, the panel will simply not render if there are no instances of \nmodel\n\n\n\n\n{% record_timeline ... %}\n\n\nSimilar to \nrecord_panel\n, \nrecord_timeline\n renders a penel for a given record as a timeline - particularly\nuseful for subrecord types where the date is a key field.\n\n\n{% load panels %}\n{% record_panel Diagnosis 'when' %}\n\n\n\nArguments:\n\n\n\n\nmodel\n: The model we want to render our panel for\n\n\nwhenfield\n: String of the field that we're using to sort by.", 
            "title": "Panel Template tags"
        }, 
        {
            "location": "/reference/panels_templatetags/#panel-helpers", 
            "text": "OPAL comes with a selection of templatetags for rendering OPAL panels\nfor a given subrecord. These panels also allow the user to\nsee instances of the model against the current value of  episode  in\nAngular  $scope . The user can also create new\ninstances of the given model, as well as editing any existing ones.  {% record_panel ... %}  Render a panel for a given record that will allow the user to view, create, update and delete instances.  The record panel template expects the relevant Angular  $scope  to have  newNamedItem(name, index) , editNamedItem(name, index)  and  deleteItem(name, index)  methods implemented. Default\nimplementations of these are available from the  EpisodeDetailMixin .  {% load panels %}\n{% record_panel Diagnosis %}  Keywords:   model : The model we want to render our panel for  title : The display title for this panel  detail_template : The display template to use. Defaults to Subrecord.get_detail_template()  editable : Whether this panel should allow editing. Defaults to True.  angular_filter : An Angular expression that will be evaluated to decide whether to show each item  noentries : A string to render if there are no instances of  model  for the current episode  only_display_if_exists : Boolean defaulting to False. If true, the panel will simply not render if there are no instances of  model   {% record_timeline ... %}  Similar to  record_panel ,  record_timeline  renders a penel for a given record as a timeline - particularly\nuseful for subrecord types where the date is a key field.  {% load panels %}\n{% record_panel Diagnosis 'when' %}  Arguments:   model : The model we want to render our panel for  whenfield : String of the field that we're using to sort by.", 
            "title": "Panel helpers"
        }, 
        {
            "location": "/reference/javascript_helpers/", 
            "text": "OPAL Javascript Helpers\n\n\n$rootScope methods\n\n\nOPAL provides some methods on the Angular $rootScope object.\n\n\nopen_modal\n\n\n$rootScope.open_modal(controller, template, size, {episode: episode})\n\n\n\nOpen an arbitrary controller in a modal, passing in the name of the controller,\nthe url for the template, the size of the modal window (either 'sm' or 'lg').\n\n\nYou may also pass through a dictionary of items to resolve.\n\n\nAngular Directives\n\n\nOPAL provides some built-in Angular directives for your project to use.\n\n\ndate-of-birth\n\n\nCreates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old.\n\n\nAngular Filters\n\n\nOPAL provides some built-in Angular filters for your project to use.\n\n\nshort-date\n\n\nDisplays a date as DD/MM if it's this year, else DD/MM/YYYY\n\n\nhhmm\n\n\nDisplays the hours \n minutes portion of a javascript Date object as HH:MM\n\n\nboxed\n\n\nDisplays Boolean fields as a checkbox (e.g. either [ ] or [X])\n\n\n[[ item.boolean_field | boxed]]", 
            "title": "Javascript helpers"
        }, 
        {
            "location": "/reference/javascript_helpers/#opal-javascript-helpers", 
            "text": "$rootScope methods  OPAL provides some methods on the Angular $rootScope object.  open_modal  $rootScope.open_modal(controller, template, size, {episode: episode})  Open an arbitrary controller in a modal, passing in the name of the controller,\nthe url for the template, the size of the modal window (either 'sm' or 'lg').  You may also pass through a dictionary of items to resolve.  Angular Directives  OPAL provides some built-in Angular directives for your project to use.  date-of-birth  Creates an input field that assumes to base field is a moment and handles validation and parsing. It assumes no one is born in the future or is over 150 years old.  Angular Filters  OPAL provides some built-in Angular filters for your project to use.  short-date  Displays a date as DD/MM if it's this year, else DD/MM/YYYY  hhmm  Displays the hours   minutes portion of a javascript Date object as HH:MM  boxed  Displays Boolean fields as a checkbox (e.g. either [ ] or [X])  [[ item.boolean_field | boxed]]", 
            "title": "OPAL Javascript Helpers"
        }, 
        {
            "location": "/reference/javascript_dependencies/", 
            "text": "OPAL Javscript Dependencies\n\n\nOPAL makes use of a number of upstream dependencies which are available for\ndevleopers to use in building applications.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModernizr\n\n\nOpal has a custom modernizr build that detects touch events\n\n\n\n\n\n\nJquery\n\n\n1.11.3\n\n\n\n\n\n\nAngular\n\n\n1.2.20\n\n\n\n\n\n\nUnderscore.js\n\n\n1.8.3\n\n\n\n\n\n\nD3\n\n\n3.5.6\n\n\n\n\n\n\nC3\n\n\n0.4.10", 
            "title": "Javascript dependencies"
        }, 
        {
            "location": "/reference/javascript_dependencies/#opal-javscript-dependencies", 
            "text": "OPAL makes use of a number of upstream dependencies which are available for\ndevleopers to use in building applications.           Modernizr  Opal has a custom modernizr build that detects touch events    Jquery  1.11.3    Angular  1.2.20    Underscore.js  1.8.3    D3  3.5.6    C3  0.4.10", 
            "title": "OPAL Javscript Dependencies"
        }, 
        {
            "location": "/reference/schemas/", 
            "text": "OPAL Schemas\n\n\nOpal Schemas allow dynamic representation of columns within a table\n\n\nget_all_list_schema_classes\n\n\nreturns a dictionary to a list of classes of all the plugins\n(the classes are the columns inc column headers)", 
            "title": "Schemas"
        }, 
        {
            "location": "/reference/schemas/#opal-schemas", 
            "text": "Opal Schemas allow dynamic representation of columns within a table  get_all_list_schema_classes  returns a dictionary to a list of classes of all the plugins\n(the classes are the columns inc column headers)", 
            "title": "OPAL Schemas"
        }, 
        {
            "location": "/reference/search_queries/", 
            "text": "opal.core.search.queries\n\n\nThis module provides our base classes for query backends as well as helper functions.\n\n\nepisodes_for_user\n\n\nGiven an iterable of EPISODES and a USER, return a filtered list of episodes that this user has\nthe permissions to know about.\n\n\nfiltered_episodes = episodes_for_user(episodes, user)", 
            "title": "Search Queries"
        }, 
        {
            "location": "/reference/search_queries/#opalcoresearchqueries", 
            "text": "This module provides our base classes for query backends as well as helper functions.  episodes_for_user  Given an iterable of EPISODES and a USER, return a filtered list of episodes that this user has\nthe permissions to know about.  filtered_episodes = episodes_for_user(episodes, user)", 
            "title": "opal.core.search.queries"
        }, 
        {
            "location": "/reference/detail_views/", 
            "text": "opal.core.PatientDetailView\n\n\nPatientDetailViews allow us to define a custom view over either one or many episodes,\navailable from the main \nPatient Detail\n view.\n\n\nPatientDetailView inherits from the \ndiscoverable\n features\n\nDiscoverableFeature\n, \nSortableFeature\n, \nRestrictableFeature\n.\n\n\nFields\n\n\nPatientDetailView.name\n\n\nThe machine readable name for this view. Should be lower case, and have no spaces.\n\n\nPatientDetailView.title\n\n\nThe display name for this view. This is what will display in links to it.\n\n\nPatientDetailView.template\n\n\nThe template we should use to render the view when it's active.\n\n\nPatientDetailView.order\n\n\nAn integer controlling the order of PatientDetailViews in the episode switcher menu on\nthe Patient Detail screen is determined by this property. Lower numbers mean higher up.\n\n\nClassmethods\n\n\nPatientDetailView.visible_to\n\n\nOverriding this method will restrict who the view is available to. For instance, we\nwould implement a superuser only view:\n\n\n@classmethod\ndef to_user(klass, user):\n   return user.is_superuser", 
            "title": "Detail Views"
        }, 
        {
            "location": "/reference/detail_views/#opalcorepatientdetailview", 
            "text": "PatientDetailViews allow us to define a custom view over either one or many episodes,\navailable from the main  Patient Detail  view.  PatientDetailView inherits from the  discoverable  features DiscoverableFeature ,  SortableFeature ,  RestrictableFeature .", 
            "title": "opal.core.PatientDetailView"
        }, 
        {
            "location": "/reference/detail_views/#fields", 
            "text": "PatientDetailView.name  The machine readable name for this view. Should be lower case, and have no spaces.  PatientDetailView.title  The display name for this view. This is what will display in links to it.  PatientDetailView.template  The template we should use to render the view when it's active.  PatientDetailView.order  An integer controlling the order of PatientDetailViews in the episode switcher menu on\nthe Patient Detail screen is determined by this property. Lower numbers mean higher up.  Classmethods  PatientDetailView.visible_to  Overriding this method will restrict who the view is available to. For instance, we\nwould implement a superuser only view:  @classmethod\ndef to_user(klass, user):\n   return user.is_superuser", 
            "title": "Fields"
        }, 
        {
            "location": "/reference/patient_list/", 
            "text": "opal.core.patient_lists\n\n\nThe \npatient_lists\n module defines a number of classes for working with lists of patients.\n\n\nPatientList\n\n\n...\n\n\nProperties\n\n\nPatientList.display_name\n\n\nHow we want to refer to this list on screen to users.\n\n\nTaggedPatientList\n\n\nTagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties\nof Patient Lists.\n\n\nProperties\n\n\nTaggedPatientList.tag\n\n\nThe main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.\n\n\nTaggedPatientList.subtag\n\n\nThe child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.", 
            "title": "Patient Lists"
        }, 
        {
            "location": "/reference/patient_list/#opalcorepatient_lists", 
            "text": "The  patient_lists  module defines a number of classes for working with lists of patients.", 
            "title": "opal.core.patient_lists"
        }, 
        {
            "location": "/reference/patient_list/#patientlist", 
            "text": "...  Properties  PatientList.display_name  How we want to refer to this list on screen to users.", 
            "title": "PatientList"
        }, 
        {
            "location": "/reference/patient_list/#taggedpatientlist", 
            "text": "Tagged Patient Lists inherit from Patient Lists - as such they have all of the same methods and properties\nof Patient Lists.  Properties  TaggedPatientList.tag  The main, or parent tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.  TaggedPatientList.subtag  The child tag for this list. Should be lowercase, with no numbers or dashes. Underscores are OK.", 
            "title": "TaggedPatientList"
        }, 
        {
            "location": "/reference/search_js_services/", 
            "text": "OPAL Core Search Javascript Services\n\n\nFilter\n\n\nThe Angular Service for saved filters. Maps to the model \nopal.models.Filter\n.\n\n\nsave(attrs)\n\n\nSave this filter with the attributes passed in. If there is no ID, this is taken to be a create.\n\n\ndestroy()\n\n\nDestroy this filter.\n\n\nfiltersLoader\n\n\nLoader service that will resolve with instantiated \nFilter\n objects for each of the current\nuser's filters.\n\n\nFilterResource\n\n\nAngular $resource for Filter objects.", 
            "title": "Search JS Services"
        }, 
        {
            "location": "/reference/search_js_services/#opal-core-search-javascript-services", 
            "text": "", 
            "title": "OPAL Core Search Javascript Services"
        }, 
        {
            "location": "/reference/search_js_services/#filter", 
            "text": "The Angular Service for saved filters. Maps to the model  opal.models.Filter .  save(attrs)  Save this filter with the attributes passed in. If there is no ID, this is taken to be a create.  destroy()  Destroy this filter.", 
            "title": "Filter"
        }, 
        {
            "location": "/reference/search_js_services/#filtersloader", 
            "text": "Loader service that will resolve with instantiated  Filter  objects for each of the current\nuser's filters.", 
            "title": "filtersLoader"
        }, 
        {
            "location": "/reference/search_js_services/#filterresource", 
            "text": "Angular $resource for Filter objects.", 
            "title": "FilterResource"
        }, 
        {
            "location": "/reference/changelog/", 
<<<<<<< HEAD
            "text": "0.7.0 (Major Release)\n\n\n Episode Categories\n\n\nRefactors EpisodeCategory to be a discoverable feature.\n\n\nRenames \nEpisode.category\n -\n \nEpisode.category_name\n.\n\n\n Episode JSON API\n\n\nThe Restful Episode JSON API previously available at \n/episode/:pk/\n is now moved into\n\n/api/v0.1/episode/:pk/\n for consistency with the rest of our JSON APIs.\nThe OPAL Angular layer has been updated to reflect this, and\nshould handle the transition seamlessly, but code calling the API directly should update\nto reflect the new URL.\n\n\n0.6.0 (Major Release)\n\n\nDetail views\n\n\nMoves from episode oriented detail to patient oriented detail.\n(All episodes plus x-episode views are available from a patient detail screen)\n\n\nTagging\n\n\nAs a performance optimisation for the frequent access of historic tags, untagging\nan episode simply renders the tag inactive rather than deleting it and relying on\nDjango-Reversion for access to historical data.\n\n\nDate Formatting\n\n\nWe now expect 'd/m/y' date formatting by default.\n\n\nPatient lists\n\n\nLists are now declarative, and separate from teams. They are implemented as\nsubclasses of opal.core.patient_lists.PatientList.\n\n\nForms vs. Modals\n\n\nIntroduces a distinction between a form and a modal.\nBy default, we now use forms for subrecords, only overriding the modal if there\nis something we want to do differently specifically in the modal.\n\n\nCommand line tools\n\n\nAdds $opal checkout for switching between applications or application versions.\n\n\n Upgrade instructions:\n\n\n\n\nUpdate your settings to use the new date formats.\n\n\n\n\n0.5.5 (Minor Release)\n\n\nChanges the way old tags are handled.\n\n\nTags are no longer deleted episodes, rather they're marked as archived.\n\n\n0.5.4 (Minor Release)\n\n\n\n\nInclude local storage\n\n\n\n\n0.5.3 (Minor Release)\n\n\n\n\nSpeed up loading of the lookup lists\n\n\nFix pagination issues in search\n\n\nSpeed up loading of many to many fields\n\n\nIncrease test coverage\n\n\nAdd some extra help fields to {% forms %} helpers\n\n\nFixes bug with $rootScope.open_modal() where keystrokes were being intercepted\n\n\n\n\n0.5.2 (Minor Release)\n\n\nSpeed improvements on page load\nallow us to only show record panels if a record of that type exists\ndisable modal buttons while saving\n\n\n0.5.1 (Minor Release)\n\n\nMinor bug fixes\n\n\n0.5 (Major release)\n\n\nSearch\n\n\nComplete re-design of Search interface to provide a single search box on every page and pagination for resulta.\nPuts in place a pluggable interface that could be swapped out for e.g. ElasticSearch.\nNew Service for PatientSummary()\n\n\nAnalytics\n\n\nMoves Analytics integration into OPAL core with the ability to blacklist pages that should never be reported\n\n\nList view\n\n\nRemoved old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row.\nUpdated scrolling and loading behaviour to snap to viewport and not display the page build.\n\n\nSubrecord metadata\n\n\nAdded four new utility fields to Patient and Episode subrecords:\n\n\ncreated_by, updated_by, created, updated\n\n\nSelect2 and list fields\n\n\nAdded support for select2 as an input widget and Subrecord fields that can be lists of things.\n\n\nAlso\n\n\nNumerous small bugfixes.\nRefactoring of the models package into a models module.\nUpdated Underscore.js -\n 1.8.3\nUpdated Angular.js -\n 1.3.11\n\n\n0.4.3 (Minor release)\n\n\nRefactors opal.models to be a models.py file rather than a package.\nAdds several improvements to forms helpers -\n Help argument, other argument to select.\n\n\nUpdates dependency graph:\n\n\n\n\nAngular-strap -\n 2.3.1\n\n\n\n\n0.4.2 (Minor release)\n\n\nUpgrades dependency graph:\n\n\n\n\nDjango -\n 1.8.3\n\n\nDjango-reversion -\n 1.8.7\n\n\njQuery -\n 1.11.3\n\n\nD3 -\n 3.5.6\n\n\nC4 -\n 0.4.10\n\n\n\n\nSouth has been removed, now using django migrations\n\n\n0.4.1 (Bugfix release)\n\n\nFixes some search results appearing duplicated.\n\n\n0.4 (Major release)\n\n\nNew Design\n\n\nCompletely re-designed UI following extensive user research and multiple iterations.\n\n\nManagementcommands and scaffolding\n\n\nFeatures the opal command line tool for common administrative tasks\nhttp://opal.openhealthcare.org.uk/docs/guides/command_line_tool/\n\n\n Form helpers templatetag library\n\n\nNew template library for consistent form controls in line with our new interface guidelines\nhttp://opal.openhealthcare.org.uk/docs/reference/form_templatetags/\n\n\nAPI Documentation\n\n\nOPAL JSON APIs are now fully self-documenting for all updated instances\nhttp://opal.openhealthcare.org.uk/docs/guides/json_api/\n\n\n0.3 (Major release)\n\n\nBugfixes, significant flexibility in template customisability.\n\n\nMinor UI updates.\n\n\n0.2.2 (Bugfix release)\n\n\nNumerous small bugfixes.\n\n\nAdds the concept of undischarging patients.\n\n\n0.2.1\n\n\nNumerous small bugfixes.\n\n\n0.2.0\n\n\nSearch overhaul - introduces advanced searches.\n\n\n0.1.1\n\n\nInitial public release", 
            "title": "Changelog"
        }, 
        {
=======
            "text": "0.7.0 (Major Release)\n\n\n Episode Categories\n\n\nRefactors EpisodeCategory to be a discoverable feature. Renames \nEpisode.category\n -\n \nEpisode.category_name\n.\n\n\n Episode JSON API\n\n\nThe Restful Episode JSON API previously available at \n/episode/:pk/\n is now moved into\n\n/api/v0.1/episode/:pk/\n for consistency with the rest of our JSON APIs.\nThe OPAL Angular layer has been updated to reflect this, and\nshould handle the transition seamlessly, but code calling the API directly should update\nto reflect the new URL.\n\n\n0.6.0 (Major Release)\n\n\nDetail views\n\n\nMoves from episode oriented detail to patient oriented detail.\n(All episodes plus x-episode views are available from a patient detail screen)\n\n\nTagging\n\n\nAs a performance optimisation for the frequent access of historic tags, untagging\nan episode simply renders the tag inactive rather than deleting it and relying on\nDjango-Reversion for access to historical data.\n\n\nDate Formatting\n\n\nWe now expect 'd/m/y' date formatting by default.\n\n\nPatient lists\n\n\nLists are now declarative, and separate from teams. They are implemented as\nsubclasses of opal.core.patient_lists.PatientList.\n\n\nForms vs. Modals\n\n\nIntroduces a distinction between a form and a modal.\nBy default, we now use forms for subrecords, only overriding the modal if there\nis something we want to do differently specifically in the modal.\n\n\nCommand line tools\n\n\nAdds $opal checkout for switching between applications or application versions.\n\n\n Upgrade instructions:\n\n\n\n\nUpdate your settings to use the new date formats.\n\n\n\n\n0.5.5 (Minor Release)\n\n\nChanges the way old tags are handled.\n\n\nTags are no longer deleted episodes, rather they're marked as archived.\n\n\n0.5.4 (Minor Release)\n\n\n\n\nInclude local storage\n\n\n\n\n0.5.3 (Minor Release)\n\n\n\n\nSpeed up loading of the lookup lists\n\n\nFix pagination issues in search\n\n\nSpeed up loading of many to many fields\n\n\nIncrease test coverage\n\n\nAdd some extra help fields to {% forms %} helpers\n\n\nFixes bug with $rootScope.open_modal() where keystrokes were being intercepted\n\n\n\n\n0.5.2 (Minor Release)\n\n\nSpeed improvements on page load\nallow us to only show record panels if a record of that type exists\ndisable modal buttons while saving\n\n\n0.5.1 (Minor Release)\n\n\nMinor bug fixes\n\n\n0.5 (Major release)\n\n\nSearch\n\n\nComplete re-design of Search interface to provide a single search box on every page and pagination for resulta.\nPuts in place a pluggable interface that could be swapped out for e.g. ElasticSearch.\nNew Service for PatientSummary()\n\n\nAnalytics\n\n\nMoves Analytics integration into OPAL core with the ability to blacklist pages that should never be reported\n\n\nList view\n\n\nRemoved old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row.\nUpdated scrolling and loading behaviour to snap to viewport and not display the page build.\n\n\nSubrecord metadata\n\n\nAdded four new utility fields to Patient and Episode subrecords:\n\n\ncreated_by, updated_by, created, updated\n\n\nSelect2 and list fields\n\n\nAdded support for select2 as an input widget and Subrecord fields that can be lists of things.\n\n\nAlso\n\n\nNumerous small bugfixes.\nRefactoring of the models package into a models module.\nUpdated Underscore.js -\n 1.8.3\nUpdated Angular.js -\n 1.3.11\n\n\n0.4.3 (Minor release)\n\n\nRefactors opal.models to be a models.py file rather than a package.\nAdds several improvements to forms helpers -\n Help argument, other argument to select.\n\n\nUpdates dependency graph:\n\n\n\n\nAngular-strap -\n 2.3.1\n\n\n\n\n0.4.2 (Minor release)\n\n\nUpgrades dependency graph:\n\n\n\n\nDjango -\n 1.8.3\n\n\nDjango-reversion -\n 1.8.7\n\n\njQuery -\n 1.11.3\n\n\nD3 -\n 3.5.6\n\n\nC4 -\n 0.4.10\n\n\n\n\nSouth has been removed, now using django migrations\n\n\n0.4.1 (Bugfix release)\n\n\nFixes some search results appearing duplicated.\n\n\n0.4 (Major release)\n\n\nNew Design\n\n\nCompletely re-designed UI following extensive user research and multiple iterations.\n\n\nManagementcommands and scaffolding\n\n\nFeatures the opal command line tool for common administrative tasks\nhttp://opal.openhealthcare.org.uk/docs/guides/command_line_tool/\n\n\n Form helpers templatetag library\n\n\nNew template library for consistent form controls in line with our new interface guidelines\nhttp://opal.openhealthcare.org.uk/docs/reference/form_templatetags/\n\n\nAPI Documentation\n\n\nOPAL JSON APIs are now fully self-documenting for all updated instances\nhttp://opal.openhealthcare.org.uk/docs/guides/json_api/\n\n\n0.3 (Major release)\n\n\nBugfixes, significant flexibility in template customisability.\n\n\nMinor UI updates.\n\n\n0.2.2 (Bugfix release)\n\n\nNumerous small bugfixes.\n\n\nAdds the concept of undischarging patients.\n\n\n0.2.1\n\n\nNumerous small bugfixes.\n\n\n0.2.0\n\n\nSearch overhaul - introduces advanced searches.\n\n\n0.1.1\n\n\nInitial public release", 
            "title": "Changelog"
        }, 
        {
            "location": "/reference/changelog/#070-major-release", 
            "text": "Episode Categories  Refactors EpisodeCategory to be a discoverable feature. Renames  Episode.category  -   Episode.category_name .   Episode JSON API  The Restful Episode JSON API previously available at  /episode/:pk/  is now moved into /api/v0.1/episode/:pk/  for consistency with the rest of our JSON APIs.\nThe OPAL Angular layer has been updated to reflect this, and\nshould handle the transition seamlessly, but code calling the API directly should update\nto reflect the new URL.", 
            "title": "0.7.0 (Major Release)"
        }, 
        {
            "location": "/reference/changelog/#060-major-release", 
            "text": "Detail views  Moves from episode oriented detail to patient oriented detail.\n(All episodes plus x-episode views are available from a patient detail screen)  Tagging  As a performance optimisation for the frequent access of historic tags, untagging\nan episode simply renders the tag inactive rather than deleting it and relying on\nDjango-Reversion for access to historical data.  Date Formatting  We now expect 'd/m/y' date formatting by default.  Patient lists  Lists are now declarative, and separate from teams. They are implemented as\nsubclasses of opal.core.patient_lists.PatientList.  Forms vs. Modals  Introduces a distinction between a form and a modal.\nBy default, we now use forms for subrecords, only overriding the modal if there\nis something we want to do differently specifically in the modal.  Command line tools  Adds $opal checkout for switching between applications or application versions.   Upgrade instructions:   Update your settings to use the new date formats.", 
            "title": "0.6.0 (Major Release)"
        }, 
        {
            "location": "/reference/changelog/#055-minor-release", 
            "text": "Changes the way old tags are handled.  Tags are no longer deleted episodes, rather they're marked as archived.", 
            "title": "0.5.5 (Minor Release)"
        }, 
        {
            "location": "/reference/changelog/#054-minor-release", 
            "text": "Include local storage", 
            "title": "0.5.4 (Minor Release)"
        }, 
        {
            "location": "/reference/changelog/#053-minor-release", 
            "text": "Speed up loading of the lookup lists  Fix pagination issues in search  Speed up loading of many to many fields  Increase test coverage  Add some extra help fields to {% forms %} helpers  Fixes bug with $rootScope.open_modal() where keystrokes were being intercepted", 
            "title": "0.5.3 (Minor Release)"
        }, 
        {
            "location": "/reference/changelog/#052-minor-release", 
            "text": "Speed improvements on page load\nallow us to only show record panels if a record of that type exists\ndisable modal buttons while saving", 
            "title": "0.5.2 (Minor Release)"
        }, 
        {
            "location": "/reference/changelog/#051-minor-release", 
            "text": "Minor bug fixes", 
            "title": "0.5.1 (Minor Release)"
        }, 
        {
            "location": "/reference/changelog/#05-major-release", 
            "text": "Search  Complete re-design of Search interface to provide a single search box on every page and pagination for resulta.\nPuts in place a pluggable interface that could be swapped out for e.g. ElasticSearch.\nNew Service for PatientSummary()  Analytics  Moves Analytics integration into OPAL core with the ability to blacklist pages that should never be reported  List view  Removed old spreadsheet-style cell based navigation and moved to row-wise nav with clearer highlighting of the active row.\nUpdated scrolling and loading behaviour to snap to viewport and not display the page build.  Subrecord metadata  Added four new utility fields to Patient and Episode subrecords:  created_by, updated_by, created, updated  Select2 and list fields  Added support for select2 as an input widget and Subrecord fields that can be lists of things.  Also  Numerous small bugfixes.\nRefactoring of the models package into a models module.\nUpdated Underscore.js -  1.8.3\nUpdated Angular.js -  1.3.11", 
            "title": "0.5 (Major release)"
        }, 
        {
            "location": "/reference/changelog/#043-minor-release", 
            "text": "Refactors opal.models to be a models.py file rather than a package.\nAdds several improvements to forms helpers -  Help argument, other argument to select.  Updates dependency graph:   Angular-strap -  2.3.1", 
            "title": "0.4.3 (Minor release)"
        }, 
        {
            "location": "/reference/changelog/#042-minor-release", 
            "text": "Upgrades dependency graph:   Django -  1.8.3  Django-reversion -  1.8.7  jQuery -  1.11.3  D3 -  3.5.6  C4 -  0.4.10   South has been removed, now using django migrations", 
            "title": "0.4.2 (Minor release)"
        }, 
        {
            "location": "/reference/changelog/#041-bugfix-release", 
            "text": "Fixes some search results appearing duplicated.", 
            "title": "0.4.1 (Bugfix release)"
        }, 
        {
            "location": "/reference/changelog/#04-major-release", 
            "text": "New Design  Completely re-designed UI following extensive user research and multiple iterations.  Managementcommands and scaffolding  Features the opal command line tool for common administrative tasks\nhttp://opal.openhealthcare.org.uk/docs/guides/command_line_tool/   Form helpers templatetag library  New template library for consistent form controls in line with our new interface guidelines\nhttp://opal.openhealthcare.org.uk/docs/reference/form_templatetags/  API Documentation  OPAL JSON APIs are now fully self-documenting for all updated instances\nhttp://opal.openhealthcare.org.uk/docs/guides/json_api/", 
            "title": "0.4 (Major release)"
        }, 
        {
            "location": "/reference/changelog/#03-major-release", 
            "text": "Bugfixes, significant flexibility in template customisability.  Minor UI updates.", 
            "title": "0.3 (Major release)"
        }, 
        {
            "location": "/reference/changelog/#022-bugfix-release", 
            "text": "Numerous small bugfixes.  Adds the concept of undischarging patients.", 
            "title": "0.2.2 (Bugfix release)"
        }, 
        {
            "location": "/reference/changelog/#021", 
            "text": "Numerous small bugfixes.", 
            "title": "0.2.1"
        }, 
        {
            "location": "/reference/changelog/#020", 
            "text": "Search overhaul - introduces advanced searches.", 
            "title": "0.2.0"
        }, 
        {
            "location": "/reference/changelog/#011", 
            "text": "Initial public release", 
            "title": "0.1.1"
        }, 
        {
>>>>>>> gh-pages
            "location": "/reference/upgrading/", 
            "text": "Upgrading Your OPAL Application\n\n\nThis document provides instructions for specific steps required to upgrading your OPAL\napplication to a later version where there are extra steps required.\n\n\n6.x -\n 7.x\n\n\nBreaking changes\n\n\nOPAL 0.7 contains a number of breaking changes.\n\n\nopal.models.Episode.category\n has been re-named \ncategory_name\n. If your application\ndirectly sets category, you will be required to update all instances where this happens.\n\n\nThe \n/episode/:pk/\n API has moved to \n/api/v0.1/episode/:pk/\n so any code (typically\njavascript) code that directly saves to this API endpoint rather than using the OPAL JS\n\nEpisode\n services should work immediately when re-pointed at the new URL.\n\n\n4.X -\n 5.x\n\n\nMigrations\n\n\nBefore upgrading from 4.x to 5.x you should ensure that you have upgraded from South\nto Djangomigrations.\n\n\n$ rm yourapp/migrations/*\n$ python manage.py makemigrations yourapp\n$ python manage.py migrate yourapp --fake-initial\n\n\n\nOPAL\n\n\nNext you will need to upgrade the OPAL version itself.\n\n\nHow you do this depends on how you have configured your application, but updating your\nrequirements.txt to update the version should work. This will also update FFS and Django\nAxes as well as adding Python Dateutil.\n\n\n-e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal\n\n\n\nMigrations.\n\n\nOPAL has fresh migrations in 0.5.x, which we should run. There are also changes to the\nbase abstract model classes (to add created/updated timestamps) so you'll need to create\nfresh migrations for your own application.\n\n\n$ python manage.py migrate\n$ python manage.py makemigrations yourapp\n$ python manage.py migrate yourapp\n\n\n\nAt this stage you'll want to commit your new migrations, as well as any changes to your\napplication's requirements file.\n\n\nTags\n\n\nAs of 0.5.5, old tags in OPAL are stored directly on the Tagging model rather than via\nDjano Reversion. We can import those old tags by doing the following.\n\n\n$ python manage.py shell\n\n\n from opal.models import Tagging\n\n Tagging.import_from_reversion()\n\n\n\nDeployment\n\n\nThe first time you deploy your upgraded application you'll need to run the following\ncommands to upgrade your database:\n\n\n$ python manage.py migrate --fake-initial\n\n\n\nYou'll also have to repeat the Tagging step once for each deployment.", 
            "title": "Upgrading"
        }, 
        {
            "location": "/reference/upgrading/#upgrading-your-opal-application", 
            "text": "This document provides instructions for specific steps required to upgrading your OPAL\napplication to a later version where there are extra steps required.  6.x -  7.x  Breaking changes  OPAL 0.7 contains a number of breaking changes.  opal.models.Episode.category  has been re-named  category_name . If your application\ndirectly sets category, you will be required to update all instances where this happens.  The  /episode/:pk/  API has moved to  /api/v0.1/episode/:pk/  so any code (typically\njavascript) code that directly saves to this API endpoint rather than using the OPAL JS Episode  services should work immediately when re-pointed at the new URL.  4.X -  5.x  Migrations  Before upgrading from 4.x to 5.x you should ensure that you have upgraded from South\nto Djangomigrations.  $ rm yourapp/migrations/*\n$ python manage.py makemigrations yourapp\n$ python manage.py migrate yourapp --fake-initial  OPAL  Next you will need to upgrade the OPAL version itself.  How you do this depends on how you have configured your application, but updating your\nrequirements.txt to update the version should work. This will also update FFS and Django\nAxes as well as adding Python Dateutil.  -e git://github.com/openhealthcare/opal.git@v0.5.6#egg=opal  Migrations.  OPAL has fresh migrations in 0.5.x, which we should run. There are also changes to the\nbase abstract model classes (to add created/updated timestamps) so you'll need to create\nfresh migrations for your own application.  $ python manage.py migrate\n$ python manage.py makemigrations yourapp\n$ python manage.py migrate yourapp  At this stage you'll want to commit your new migrations, as well as any changes to your\napplication's requirements file.  Tags  As of 0.5.5, old tags in OPAL are stored directly on the Tagging model rather than via\nDjano Reversion. We can import those old tags by doing the following.  $ python manage.py shell  from opal.models import Tagging  Tagging.import_from_reversion()  Deployment  The first time you deploy your upgraded application you'll need to run the following\ncommands to upgrade your database:  $ python manage.py migrate --fake-initial  You'll also have to repeat the Tagging step once for each deployment.", 
            "title": "Upgrading Your OPAL Application"
        }
    ]
}